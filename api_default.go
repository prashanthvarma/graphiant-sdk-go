/*
Graphiant APIs

Graphiant API documentation.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package graphiant_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiV1AccountEmailPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountEmailPatchRequest *V1AccountEmailPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountEmailPatchRequest) Authorization(authorization string) ApiV1AccountEmailPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountEmailPatchRequest) V1AccountEmailPatchRequest(v1AccountEmailPatchRequest V1AccountEmailPatchRequest) ApiV1AccountEmailPatchRequest {
	r.v1AccountEmailPatchRequest = &v1AccountEmailPatchRequest
	return r
}

func (r ApiV1AccountEmailPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AccountEmailPatchExecute(r)
}

/*
V1AccountEmailPatch Method for V1AccountEmailPatch

Update user's email address with verification.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountEmailPatchRequest
*/
func (a *DefaultAPIService) V1AccountEmailPatch(ctx context.Context) ApiV1AccountEmailPatchRequest {
	return ApiV1AccountEmailPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AccountEmailPatchExecute(r ApiV1AccountEmailPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountEmailPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountEmailPatchRequest == nil {
		return nil, reportError("v1AccountEmailPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountEmailPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AccountInfoPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountInfoPatchRequest *V1AccountInfoPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountInfoPatchRequest) Authorization(authorization string) ApiV1AccountInfoPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountInfoPatchRequest) V1AccountInfoPatchRequest(v1AccountInfoPatchRequest V1AccountInfoPatchRequest) ApiV1AccountInfoPatchRequest {
	r.v1AccountInfoPatchRequest = &v1AccountInfoPatchRequest
	return r
}

func (r ApiV1AccountInfoPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AccountInfoPatchExecute(r)
}

/*
V1AccountInfoPatch Method for V1AccountInfoPatch

Update current user's profile information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountInfoPatchRequest
*/
func (a *DefaultAPIService) V1AccountInfoPatch(ctx context.Context) ApiV1AccountInfoPatchRequest {
	return ApiV1AccountInfoPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AccountInfoPatchExecute(r ApiV1AccountInfoPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountInfoPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountInfoPatchRequest == nil {
		return nil, reportError("v1AccountInfoPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountInfoPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AccountMfaConfirmationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountMfaConfirmationPostRequest *V1AccountMfaConfirmationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaConfirmationPostRequest) Authorization(authorization string) ApiV1AccountMfaConfirmationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaConfirmationPostRequest) V1AccountMfaConfirmationPostRequest(v1AccountMfaConfirmationPostRequest V1AccountMfaConfirmationPostRequest) ApiV1AccountMfaConfirmationPostRequest {
	r.v1AccountMfaConfirmationPostRequest = &v1AccountMfaConfirmationPostRequest
	return r
}

func (r ApiV1AccountMfaConfirmationPostRequest) Execute() (*V1AccountMfaConfirmationPostResponse, *http.Response, error) {
	return r.ApiService.V1AccountMfaConfirmationPostExecute(r)
}

/*
V1AccountMfaConfirmationPost Method for V1AccountMfaConfirmationPost

Confirm MFA type change with verification code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaConfirmationPostRequest
*/
func (a *DefaultAPIService) V1AccountMfaConfirmationPost(ctx context.Context) ApiV1AccountMfaConfirmationPostRequest {
	return ApiV1AccountMfaConfirmationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AccountMfaConfirmationPostResponse
func (a *DefaultAPIService) V1AccountMfaConfirmationPostExecute(r ApiV1AccountMfaConfirmationPostRequest) (*V1AccountMfaConfirmationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AccountMfaConfirmationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaConfirmationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa/confirmation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountMfaConfirmationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountMfaConfirmationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountMfaConfirmationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountMfaDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaDeleteRequest) Authorization(authorization string) ApiV1AccountMfaDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AccountMfaDeleteExecute(r)
}

/*
V1AccountMfaDelete Method for V1AccountMfaDelete

Remove user's MFA enrollment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaDeleteRequest
*/
func (a *DefaultAPIService) V1AccountMfaDelete(ctx context.Context) ApiV1AccountMfaDeleteRequest {
	return ApiV1AccountMfaDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AccountMfaDeleteExecute(r ApiV1AccountMfaDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AccountMfaGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaGetRequest) Authorization(authorization string) ApiV1AccountMfaGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaGetRequest) Execute() (*V1AccountMfaGetResponse, *http.Response, error) {
	return r.ApiService.V1AccountMfaGetExecute(r)
}

/*
V1AccountMfaGet Method for V1AccountMfaGet

Get user's current MFA type and enrollment status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaGetRequest
*/
func (a *DefaultAPIService) V1AccountMfaGet(ctx context.Context) ApiV1AccountMfaGetRequest {
	return ApiV1AccountMfaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AccountMfaGetResponse
func (a *DefaultAPIService) V1AccountMfaGetExecute(r ApiV1AccountMfaGetRequest) (*V1AccountMfaGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AccountMfaGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountMfaPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountMfaPutRequest *V1AccountMfaPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaPutRequest) Authorization(authorization string) ApiV1AccountMfaPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaPutRequest) V1AccountMfaPutRequest(v1AccountMfaPutRequest V1AccountMfaPutRequest) ApiV1AccountMfaPutRequest {
	r.v1AccountMfaPutRequest = &v1AccountMfaPutRequest
	return r
}

func (r ApiV1AccountMfaPutRequest) Execute() (*V1AccountMfaPutResponse, *http.Response, error) {
	return r.ApiService.V1AccountMfaPutExecute(r)
}

/*
V1AccountMfaPut Method for V1AccountMfaPut

Update user's MFA type (SMS, GoogleAuth) with verification.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaPutRequest
*/
func (a *DefaultAPIService) V1AccountMfaPut(ctx context.Context) ApiV1AccountMfaPutRequest {
	return ApiV1AccountMfaPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AccountMfaPutResponse
func (a *DefaultAPIService) V1AccountMfaPutExecute(r ApiV1AccountMfaPutRequest) (*V1AccountMfaPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AccountMfaPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountMfaPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountMfaPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountMfaPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountPasswordPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountPasswordPatchRequest *V1AccountPasswordPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountPasswordPatchRequest) Authorization(authorization string) ApiV1AccountPasswordPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountPasswordPatchRequest) V1AccountPasswordPatchRequest(v1AccountPasswordPatchRequest V1AccountPasswordPatchRequest) ApiV1AccountPasswordPatchRequest {
	r.v1AccountPasswordPatchRequest = &v1AccountPasswordPatchRequest
	return r
}

func (r ApiV1AccountPasswordPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AccountPasswordPatchExecute(r)
}

/*
V1AccountPasswordPatch Method for V1AccountPasswordPatch

Change user password with current password verification (Graphiant cloud only).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountPasswordPatchRequest
*/
func (a *DefaultAPIService) V1AccountPasswordPatch(ctx context.Context) ApiV1AccountPasswordPatchRequest {
	return ApiV1AccountPasswordPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AccountPasswordPatchExecute(r ApiV1AccountPasswordPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountPasswordPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountPasswordPatchRequest == nil {
		return nil, reportError("v1AccountPasswordPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountPasswordPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1ActivityLogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ActivityLogsPostRequest *V1ActivityLogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ActivityLogsPostRequest) Authorization(authorization string) ApiV1ActivityLogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ActivityLogsPostRequest) V1ActivityLogsPostRequest(v1ActivityLogsPostRequest V1ActivityLogsPostRequest) ApiV1ActivityLogsPostRequest {
	r.v1ActivityLogsPostRequest = &v1ActivityLogsPostRequest
	return r
}

func (r ApiV1ActivityLogsPostRequest) Execute() (*V1ActivityLogsPostResponse, *http.Response, error) {
	return r.ApiService.V1ActivityLogsPostExecute(r)
}

/*
V1ActivityLogsPost Method for V1ActivityLogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ActivityLogsPostRequest
*/
func (a *DefaultAPIService) V1ActivityLogsPost(ctx context.Context) ApiV1ActivityLogsPostRequest {
	return ApiV1ActivityLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ActivityLogsPostResponse
func (a *DefaultAPIService) V1ActivityLogsPostExecute(r ApiV1ActivityLogsPostRequest) (*V1ActivityLogsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ActivityLogsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ActivityLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/activity/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ActivityLogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ActivityLogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ActivityLogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmHistoryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmHistoryGetRequest) Authorization(authorization string) ApiV1AlarmHistoryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmHistoryGetRequest) Execute() (*V1AlarmHistoryGetResponse, *http.Response, error) {
	return r.ApiService.V1AlarmHistoryGetExecute(r)
}

/*
V1AlarmHistoryGet Method for V1AlarmHistoryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AlarmHistoryGetRequest
*/
func (a *DefaultAPIService) V1AlarmHistoryGet(ctx context.Context) ApiV1AlarmHistoryGetRequest {
	return ApiV1AlarmHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AlarmHistoryGetResponse
func (a *DefaultAPIService) V1AlarmHistoryGetExecute(r ApiV1AlarmHistoryGetRequest) (*V1AlarmHistoryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AlarmHistoryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarm-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmMuteAlarmIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	alarmId int64
	v1AlarmMuteAlarmIdPutRequest *V1AlarmMuteAlarmIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmMuteAlarmIdPutRequest) Authorization(authorization string) ApiV1AlarmMuteAlarmIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmMuteAlarmIdPutRequest) V1AlarmMuteAlarmIdPutRequest(v1AlarmMuteAlarmIdPutRequest V1AlarmMuteAlarmIdPutRequest) ApiV1AlarmMuteAlarmIdPutRequest {
	r.v1AlarmMuteAlarmIdPutRequest = &v1AlarmMuteAlarmIdPutRequest
	return r
}

func (r ApiV1AlarmMuteAlarmIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AlarmMuteAlarmIdPutExecute(r)
}

/*
V1AlarmMuteAlarmIdPut Method for V1AlarmMuteAlarmIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alarmId Unique ID for an alarm.
 @return ApiV1AlarmMuteAlarmIdPutRequest
*/
func (a *DefaultAPIService) V1AlarmMuteAlarmIdPut(ctx context.Context, alarmId int64) ApiV1AlarmMuteAlarmIdPutRequest {
	return ApiV1AlarmMuteAlarmIdPutRequest{
		ApiService: a,
		ctx: ctx,
		alarmId: alarmId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AlarmMuteAlarmIdPutExecute(r ApiV1AlarmMuteAlarmIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmMuteAlarmIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarm-mute/{alarmId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alarmId"+"}", url.PathEscape(parameterValueToString(r.alarmId, "alarmId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AlarmMuteAlarmIdPutRequest == nil {
		return nil, reportError("v1AlarmMuteAlarmIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AlarmMuteAlarmIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AlarmsEventsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmsEventsGetRequest) Authorization(authorization string) ApiV1AlarmsEventsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmsEventsGetRequest) Execute() (*V1AlarmsEventsGetResponse, *http.Response, error) {
	return r.ApiService.V1AlarmsEventsGetExecute(r)
}

/*
V1AlarmsEventsGet Method for V1AlarmsEventsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AlarmsEventsGetRequest
*/
func (a *DefaultAPIService) V1AlarmsEventsGet(ctx context.Context) ApiV1AlarmsEventsGetRequest {
	return ApiV1AlarmsEventsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AlarmsEventsGetResponse
func (a *DefaultAPIService) V1AlarmsEventsGetExecute(r ApiV1AlarmsEventsGetRequest) (*V1AlarmsEventsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AlarmsEventsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmsEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarms-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmsListGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmsListGetRequest) Authorization(authorization string) ApiV1AlarmsListGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmsListGetRequest) Execute() (*V1AlarmsListGetResponse, *http.Response, error) {
	return r.ApiService.V1AlarmsListGetExecute(r)
}

/*
V1AlarmsListGet Method for V1AlarmsListGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AlarmsListGetRequest
*/
func (a *DefaultAPIService) V1AlarmsListGet(ctx context.Context) ApiV1AlarmsListGetRequest {
	return ApiV1AlarmsListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AlarmsListGetResponse
func (a *DefaultAPIService) V1AlarmsListGetExecute(r ApiV1AlarmsListGetRequest) (*V1AlarmsListGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AlarmsListGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmsListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarms-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsAppSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AppsAppSummaryPostRequest *V1AppsAppSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsAppSummaryPostRequest) Authorization(authorization string) ApiV1AppsAppSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsAppSummaryPostRequest) V1AppsAppSummaryPostRequest(v1AppsAppSummaryPostRequest V1AppsAppSummaryPostRequest) ApiV1AppsAppSummaryPostRequest {
	r.v1AppsAppSummaryPostRequest = &v1AppsAppSummaryPostRequest
	return r
}

func (r ApiV1AppsAppSummaryPostRequest) Execute() (*V1AppsAppSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1AppsAppSummaryPostExecute(r)
}

/*
V1AppsAppSummaryPost Method for V1AppsAppSummaryPost

Get app state summary counts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AppsAppSummaryPostRequest
*/
func (a *DefaultAPIService) V1AppsAppSummaryPost(ctx context.Context) ApiV1AppsAppSummaryPostRequest {
	return ApiV1AppsAppSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AppsAppSummaryPostResponse
func (a *DefaultAPIService) V1AppsAppSummaryPostExecute(r ApiV1AppsAppSummaryPostRequest) (*V1AppsAppSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsAppSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsAppSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/app-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsAppSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsAppSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsAppSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsBandwidthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AppsBandwidthPostRequest *V1AppsBandwidthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsBandwidthPostRequest) Authorization(authorization string) ApiV1AppsBandwidthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsBandwidthPostRequest) V1AppsBandwidthPostRequest(v1AppsBandwidthPostRequest V1AppsBandwidthPostRequest) ApiV1AppsBandwidthPostRequest {
	r.v1AppsBandwidthPostRequest = &v1AppsBandwidthPostRequest
	return r
}

func (r ApiV1AppsBandwidthPostRequest) Execute() (*V1AppsBandwidthPostResponse, *http.Response, error) {
	return r.ApiService.V1AppsBandwidthPostExecute(r)
}

/*
V1AppsBandwidthPost Method for V1AppsBandwidthPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AppsBandwidthPostRequest
*/
func (a *DefaultAPIService) V1AppsBandwidthPost(ctx context.Context) ApiV1AppsBandwidthPostRequest {
	return ApiV1AppsBandwidthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AppsBandwidthPostResponse
func (a *DefaultAPIService) V1AppsBandwidthPostExecute(r ApiV1AppsBandwidthPostRequest) (*V1AppsBandwidthPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsBandwidthPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsBandwidthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsBandwidthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsBandwidthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsBandwidthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsDeviceDeviceIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1AppsDeviceDeviceIdTopPostRequest *V1AppsDeviceDeviceIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsDeviceDeviceIdTopPostRequest) Authorization(authorization string) ApiV1AppsDeviceDeviceIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsDeviceDeviceIdTopPostRequest) V1AppsDeviceDeviceIdTopPostRequest(v1AppsDeviceDeviceIdTopPostRequest V1AppsDeviceDeviceIdTopPostRequest) ApiV1AppsDeviceDeviceIdTopPostRequest {
	r.v1AppsDeviceDeviceIdTopPostRequest = &v1AppsDeviceDeviceIdTopPostRequest
	return r
}

func (r ApiV1AppsDeviceDeviceIdTopPostRequest) Execute() (*V1AppsDeviceDeviceIdTopPostResponse, *http.Response, error) {
	return r.ApiService.V1AppsDeviceDeviceIdTopPostExecute(r)
}

/*
V1AppsDeviceDeviceIdTopPost Method for V1AppsDeviceDeviceIdTopPost

Get top apps for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1AppsDeviceDeviceIdTopPostRequest
*/
func (a *DefaultAPIService) V1AppsDeviceDeviceIdTopPost(ctx context.Context, deviceId int64) ApiV1AppsDeviceDeviceIdTopPostRequest {
	return ApiV1AppsDeviceDeviceIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1AppsDeviceDeviceIdTopPostResponse
func (a *DefaultAPIService) V1AppsDeviceDeviceIdTopPostExecute(r ApiV1AppsDeviceDeviceIdTopPostRequest) (*V1AppsDeviceDeviceIdTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsDeviceDeviceIdTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsDeviceDeviceIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/device/{deviceId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsDeviceDeviceIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsDeviceDeviceIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsDeviceDeviceIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsSiteSiteIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v1AppsSiteSiteIdTopPostRequest *V1AppsSiteSiteIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsSiteSiteIdTopPostRequest) Authorization(authorization string) ApiV1AppsSiteSiteIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsSiteSiteIdTopPostRequest) V1AppsSiteSiteIdTopPostRequest(v1AppsSiteSiteIdTopPostRequest V1AppsSiteSiteIdTopPostRequest) ApiV1AppsSiteSiteIdTopPostRequest {
	r.v1AppsSiteSiteIdTopPostRequest = &v1AppsSiteSiteIdTopPostRequest
	return r
}

func (r ApiV1AppsSiteSiteIdTopPostRequest) Execute() (*V1AppsSiteSiteIdTopPostResponse, *http.Response, error) {
	return r.ApiService.V1AppsSiteSiteIdTopPostExecute(r)
}

/*
V1AppsSiteSiteIdTopPost Method for V1AppsSiteSiteIdTopPost

Get top apps for a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1AppsSiteSiteIdTopPostRequest
*/
func (a *DefaultAPIService) V1AppsSiteSiteIdTopPost(ctx context.Context, siteId int64) ApiV1AppsSiteSiteIdTopPostRequest {
	return ApiV1AppsSiteSiteIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1AppsSiteSiteIdTopPostResponse
func (a *DefaultAPIService) V1AppsSiteSiteIdTopPostExecute(r ApiV1AppsSiteSiteIdTopPostRequest) (*V1AppsSiteSiteIdTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsSiteSiteIdTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsSiteSiteIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/site/{siteId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsSiteSiteIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsSiteSiteIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsSiteSiteIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsVisualizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AppsVisualizationPostRequest *V1AppsVisualizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsVisualizationPostRequest) Authorization(authorization string) ApiV1AppsVisualizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsVisualizationPostRequest) V1AppsVisualizationPostRequest(v1AppsVisualizationPostRequest V1AppsVisualizationPostRequest) ApiV1AppsVisualizationPostRequest {
	r.v1AppsVisualizationPostRequest = &v1AppsVisualizationPostRequest
	return r
}

func (r ApiV1AppsVisualizationPostRequest) Execute() (*V1AppsVisualizationPostResponse, *http.Response, error) {
	return r.ApiService.V1AppsVisualizationPostExecute(r)
}

/*
V1AppsVisualizationPost Method for V1AppsVisualizationPost

Get the app and circuit visualization info for the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AppsVisualizationPostRequest
*/
func (a *DefaultAPIService) V1AppsVisualizationPost(ctx context.Context) ApiV1AppsVisualizationPostRequest {
	return ApiV1AppsVisualizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AppsVisualizationPostResponse
func (a *DefaultAPIService) V1AppsVisualizationPostExecute(r ApiV1AppsVisualizationPostRequest) (*V1AppsVisualizationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsVisualizationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsVisualizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/visualization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsVisualizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsVisualizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsVisualizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuditLogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuditLogsPostRequest *V1AuditLogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuditLogsPostRequest) Authorization(authorization string) ApiV1AuditLogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuditLogsPostRequest) V1AuditLogsPostRequest(v1AuditLogsPostRequest V1AuditLogsPostRequest) ApiV1AuditLogsPostRequest {
	r.v1AuditLogsPostRequest = &v1AuditLogsPostRequest
	return r
}

func (r ApiV1AuditLogsPostRequest) Execute() (*V1AuditLogsPostResponse, *http.Response, error) {
	return r.ApiService.V1AuditLogsPostExecute(r)
}

/*
V1AuditLogsPost Method for V1AuditLogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuditLogsPostRequest
*/
func (a *DefaultAPIService) V1AuditLogsPost(ctx context.Context) ApiV1AuditLogsPostRequest {
	return ApiV1AuditLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuditLogsPostResponse
func (a *DefaultAPIService) V1AuditLogsPostExecute(r ApiV1AuditLogsPostRequest) (*V1AuditLogsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuditLogsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuditLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/audit/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuditLogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuditLogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuditLogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthDeleteRequest) Authorization(authorization string) ApiV1AuthDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthDeleteExecute(r)
}

/*
V1AuthDelete Method for V1AuthDelete

Remove Identity Provider configuration and revert to default authentication.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthDeleteRequest
*/
func (a *DefaultAPIService) V1AuthDelete(ctx context.Context) ApiV1AuthDeleteRequest {
	return ApiV1AuthDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthDeleteExecute(r ApiV1AuthDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthGcsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1AuthGcsPostRequest *V1AuthGcsPostRequest
}

func (r ApiV1AuthGcsPostRequest) V1AuthGcsPostRequest(v1AuthGcsPostRequest V1AuthGcsPostRequest) ApiV1AuthGcsPostRequest {
	r.v1AuthGcsPostRequest = &v1AuthGcsPostRequest
	return r
}

func (r ApiV1AuthGcsPostRequest) Execute() (*V1AuthLoginPostResponse, *http.Response, error) {
	return r.ApiService.V1AuthGcsPostExecute(r)
}

/*
V1AuthGcsPost Method for V1AuthGcsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthGcsPostRequest
*/
func (a *DefaultAPIService) V1AuthGcsPost(ctx context.Context) ApiV1AuthGcsPostRequest {
	return ApiV1AuthGcsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPostResponse
func (a *DefaultAPIService) V1AuthGcsPostExecute(r ApiV1AuthGcsPostRequest) (*V1AuthLoginPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthGcsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/gcs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1AuthGcsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuthGcsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AuthGcsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V1AuthErrorPostResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthMfaPost500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthGetRequest) Authorization(authorization string) ApiV1AuthGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthGetRequest) Execute() (*V1AuthGetResponse, *http.Response, error) {
	return r.ApiService.V1AuthGetExecute(r)
}

/*
V1AuthGet Method for V1AuthGet

Get current Identity Provider configuration for enterprise.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthGetRequest
*/
func (a *DefaultAPIService) V1AuthGet(ctx context.Context) ApiV1AuthGetRequest {
	return ApiV1AuthGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthGetResponse
func (a *DefaultAPIService) V1AuthGetExecute(r ApiV1AuthGetRequest) (*V1AuthGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthLoginCallbackPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	sAMLResponse *string
	relayState *string
}

func (r ApiV1AuthLoginCallbackPostRequest) SAMLResponse(sAMLResponse string) ApiV1AuthLoginCallbackPostRequest {
	r.sAMLResponse = &sAMLResponse
	return r
}

func (r ApiV1AuthLoginCallbackPostRequest) RelayState(relayState string) ApiV1AuthLoginCallbackPostRequest {
	r.relayState = &relayState
	return r
}

func (r ApiV1AuthLoginCallbackPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthLoginCallbackPostExecute(r)
}

/*
V1AuthLoginCallbackPost Method for V1AuthLoginCallbackPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginCallbackPostRequest
*/
func (a *DefaultAPIService) V1AuthLoginCallbackPost(ctx context.Context) ApiV1AuthLoginCallbackPostRequest {
	return ApiV1AuthLoginCallbackPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthLoginCallbackPostExecute(r ApiV1AuthLoginCallbackPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginCallbackPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/callback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sAMLResponse == nil {
		return nil, reportError("sAMLResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "SAMLResponse", r.sAMLResponse, "", "")
	if r.relayState != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "RelayState", r.relayState, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v V1AuthErrorPostResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthLoginCallbackPost500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthLoginPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1AuthLoginPostRequest *V1AuthLoginPostRequest
}

func (r ApiV1AuthLoginPostRequest) V1AuthLoginPostRequest(v1AuthLoginPostRequest V1AuthLoginPostRequest) ApiV1AuthLoginPostRequest {
	r.v1AuthLoginPostRequest = &v1AuthLoginPostRequest
	return r
}

func (r ApiV1AuthLoginPostRequest) Execute() (*V1AuthLoginPostResponse, *http.Response, error) {
	return r.ApiService.V1AuthLoginPostExecute(r)
}

/*
V1AuthLoginPost Method for V1AuthLoginPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginPostRequest
*/
func (a *DefaultAPIService) V1AuthLoginPost(ctx context.Context) ApiV1AuthLoginPostRequest {
	return ApiV1AuthLoginPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPostResponse
func (a *DefaultAPIService) V1AuthLoginPostExecute(r ApiV1AuthLoginPostRequest) (*V1AuthLoginPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1AuthLoginPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuthLoginPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AuthLoginPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthLoginPreGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	email *string
	relayState *string
}

// User email address
func (r ApiV1AuthLoginPreGetRequest) Email(email string) ApiV1AuthLoginPreGetRequest {
	r.email = &email
	return r
}

// State to relay after authentication
func (r ApiV1AuthLoginPreGetRequest) RelayState(relayState string) ApiV1AuthLoginPreGetRequest {
	r.relayState = &relayState
	return r
}

func (r ApiV1AuthLoginPreGetRequest) Execute() (*V1AuthLoginPreGetResponse, *http.Response, error) {
	return r.ApiService.V1AuthLoginPreGetExecute(r)
}

/*
V1AuthLoginPreGet Method for V1AuthLoginPreGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginPreGetRequest
*/
func (a *DefaultAPIService) V1AuthLoginPreGet(ctx context.Context) ApiV1AuthLoginPreGetRequest {
	return ApiV1AuthLoginPreGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPreGetResponse
func (a *DefaultAPIService) V1AuthLoginPreGetExecute(r ApiV1AuthLoginPreGetRequest) (*V1AuthLoginPreGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPreGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginPreGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/pre"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.relayState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relayState", r.relayState, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthLoginSamlGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	email *string
	relayState *string
}

// User email address
func (r ApiV1AuthLoginSamlGetRequest) Email(email string) ApiV1AuthLoginSamlGetRequest {
	r.email = &email
	return r
}

// State to relay after authentication
func (r ApiV1AuthLoginSamlGetRequest) RelayState(relayState string) ApiV1AuthLoginSamlGetRequest {
	r.relayState = &relayState
	return r
}

func (r ApiV1AuthLoginSamlGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthLoginSamlGetExecute(r)
}

/*
V1AuthLoginSamlGet Method for V1AuthLoginSamlGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginSamlGetRequest
*/
func (a *DefaultAPIService) V1AuthLoginSamlGet(ctx context.Context) ApiV1AuthLoginSamlGetRequest {
	return ApiV1AuthLoginSamlGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthLoginSamlGetExecute(r ApiV1AuthLoginSamlGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginSamlGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/saml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return nil, reportError("email is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	if r.relayState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relayState", r.relayState, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v V1AuthLoginSamlGet401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthLoginSamlGet500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthLoginTempPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1AuthLoginTempPostRequest *V1AuthLoginTempPostRequest
}

func (r ApiV1AuthLoginTempPostRequest) V1AuthLoginTempPostRequest(v1AuthLoginTempPostRequest V1AuthLoginTempPostRequest) ApiV1AuthLoginTempPostRequest {
	r.v1AuthLoginTempPostRequest = &v1AuthLoginTempPostRequest
	return r
}

func (r ApiV1AuthLoginTempPostRequest) Execute() (*V1AuthLoginPostResponse, *http.Response, error) {
	return r.ApiService.V1AuthLoginTempPostExecute(r)
}

/*
V1AuthLoginTempPost Method for V1AuthLoginTempPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginTempPostRequest
*/
func (a *DefaultAPIService) V1AuthLoginTempPost(ctx context.Context) ApiV1AuthLoginTempPostRequest {
	return ApiV1AuthLoginTempPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPostResponse
func (a *DefaultAPIService) V1AuthLoginTempPostExecute(r ApiV1AuthLoginTempPostRequest) (*V1AuthLoginPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginTempPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/temp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1AuthLoginTempPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuthLoginTempPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AuthLoginTempPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthMfaDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthMfaDeleteRequest) Authorization(authorization string) ApiV1AuthMfaDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthMfaDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthMfaDeleteExecute(r)
}

/*
V1AuthMfaDelete Method for V1AuthMfaDelete

Remove Multi-Factor Authentication enrollment for the tenant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaDeleteRequest
*/
func (a *DefaultAPIService) V1AuthMfaDelete(ctx context.Context) ApiV1AuthMfaDeleteRequest {
	return ApiV1AuthMfaDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthMfaDeleteExecute(r ApiV1AuthMfaDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthMfaPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuthMfaPatchRequest *V1AuthMfaPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthMfaPatchRequest) Authorization(authorization string) ApiV1AuthMfaPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthMfaPatchRequest) V1AuthMfaPatchRequest(v1AuthMfaPatchRequest V1AuthMfaPatchRequest) ApiV1AuthMfaPatchRequest {
	r.v1AuthMfaPatchRequest = &v1AuthMfaPatchRequest
	return r
}

func (r ApiV1AuthMfaPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthMfaPatchExecute(r)
}

/*
V1AuthMfaPatch Method for V1AuthMfaPatch

Enroll tenant in Multi-Factor Authentication (SMS, GoogleAuth).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaPatchRequest
*/
func (a *DefaultAPIService) V1AuthMfaPatch(ctx context.Context) ApiV1AuthMfaPatchRequest {
	return ApiV1AuthMfaPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthMfaPatchExecute(r ApiV1AuthMfaPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuthMfaPatchRequest == nil {
		return nil, reportError("v1AuthMfaPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuthMfaPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthMfaPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1AuthMfaPostRequest *V1AuthMfaPostRequest
}

func (r ApiV1AuthMfaPostRequest) V1AuthMfaPostRequest(v1AuthMfaPostRequest V1AuthMfaPostRequest) ApiV1AuthMfaPostRequest {
	r.v1AuthMfaPostRequest = &v1AuthMfaPostRequest
	return r
}

func (r ApiV1AuthMfaPostRequest) Execute() (*V1AuthLoginPostResponse, *http.Response, error) {
	return r.ApiService.V1AuthMfaPostExecute(r)
}

/*
V1AuthMfaPost Method for V1AuthMfaPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaPostRequest
*/
func (a *DefaultAPIService) V1AuthMfaPost(ctx context.Context) ApiV1AuthMfaPostRequest {
	return ApiV1AuthMfaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPostResponse
func (a *DefaultAPIService) V1AuthMfaPostExecute(r ApiV1AuthMfaPostRequest) (*V1AuthLoginPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1AuthMfaPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuthMfaPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AuthMfaPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V1AuthErrorPostResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthMfaPost500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthMfaTypesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthMfaTypesGetRequest) Authorization(authorization string) ApiV1AuthMfaTypesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthMfaTypesGetRequest) Execute() (*V1AuthMfaTypesGetResponse, *http.Response, error) {
	return r.ApiService.V1AuthMfaTypesGetExecute(r)
}

/*
V1AuthMfaTypesGet Method for V1AuthMfaTypesGet

Get MFA types allowed by enterprise policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaTypesGetRequest
*/
func (a *DefaultAPIService) V1AuthMfaTypesGet(ctx context.Context) ApiV1AuthMfaTypesGetRequest {
	return ApiV1AuthMfaTypesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthMfaTypesGetResponse
func (a *DefaultAPIService) V1AuthMfaTypesGetExecute(r ApiV1AuthMfaTypesGetRequest) (*V1AuthMfaTypesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthMfaTypesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaTypesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthMfaTypesPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuthMfaTypesPutRequest *V1AuthMfaTypesPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthMfaTypesPutRequest) Authorization(authorization string) ApiV1AuthMfaTypesPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthMfaTypesPutRequest) V1AuthMfaTypesPutRequest(v1AuthMfaTypesPutRequest V1AuthMfaTypesPutRequest) ApiV1AuthMfaTypesPutRequest {
	r.v1AuthMfaTypesPutRequest = &v1AuthMfaTypesPutRequest
	return r
}

func (r ApiV1AuthMfaTypesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthMfaTypesPutExecute(r)
}

/*
V1AuthMfaTypesPut Method for V1AuthMfaTypesPut

Update enterprise MFA policy to allow/disallow specific MFA types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaTypesPutRequest
*/
func (a *DefaultAPIService) V1AuthMfaTypesPut(ctx context.Context) ApiV1AuthMfaTypesPutRequest {
	return ApiV1AuthMfaTypesPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthMfaTypesPutExecute(r ApiV1AuthMfaTypesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaTypesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuthMfaTypesPutRequest == nil {
		return nil, reportError("v1AuthMfaTypesPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuthMfaTypesPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuthPatchRequest *V1AuthPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthPatchRequest) Authorization(authorization string) ApiV1AuthPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthPatchRequest) V1AuthPatchRequest(v1AuthPatchRequest V1AuthPatchRequest) ApiV1AuthPatchRequest {
	r.v1AuthPatchRequest = &v1AuthPatchRequest
	return r
}

func (r ApiV1AuthPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthPatchExecute(r)
}

/*
V1AuthPatch Method for V1AuthPatch

Update Identity Provider configuration (certificates, endpoints, etc.).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthPatchRequest
*/
func (a *DefaultAPIService) V1AuthPatch(ctx context.Context) ApiV1AuthPatchRequest {
	return ApiV1AuthPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthPatchExecute(r ApiV1AuthPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuthPatchRequest == nil {
		return nil, reportError("v1AuthPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuthPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuthPutRequest *V1AuthPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthPutRequest) Authorization(authorization string) ApiV1AuthPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthPutRequest) V1AuthPutRequest(v1AuthPutRequest V1AuthPutRequest) ApiV1AuthPutRequest {
	r.v1AuthPutRequest = &v1AuthPutRequest
	return r
}

func (r ApiV1AuthPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1AuthPutExecute(r)
}

/*
V1AuthPut Method for V1AuthPut

Configure Identity Provider (SAML) for enterprise. Creates IDP configuration affecting all users in the enterprise.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthPutRequest
*/
func (a *DefaultAPIService) V1AuthPut(ctx context.Context) ApiV1AuthPutRequest {
	return ApiV1AuthPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1AuthPutExecute(r ApiV1AuthPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuthPutRequest == nil {
		return nil, reportError("v1AuthPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuthPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1AuthRefreshGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	currentPath *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthRefreshGetRequest) Authorization(authorization string) ApiV1AuthRefreshGetRequest {
	r.authorization = &authorization
	return r
}

// Current path to redirect to after refresh
func (r ApiV1AuthRefreshGetRequest) CurrentPath(currentPath string) ApiV1AuthRefreshGetRequest {
	r.currentPath = &currentPath
	return r
}

func (r ApiV1AuthRefreshGetRequest) Execute() (*V1AuthRefreshGet200Response, *http.Response, error) {
	return r.ApiService.V1AuthRefreshGetExecute(r)
}

/*
V1AuthRefreshGet Method for V1AuthRefreshGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthRefreshGetRequest
*/
func (a *DefaultAPIService) V1AuthRefreshGet(ctx context.Context) ApiV1AuthRefreshGetRequest {
	return ApiV1AuthRefreshGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthRefreshGet200Response
func (a *DefaultAPIService) V1AuthRefreshGetExecute(r ApiV1AuthRefreshGetRequest) (*V1AuthRefreshGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthRefreshGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthRefreshGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.currentPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currentPath", r.currentPath, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V1AuthRefreshGet403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v V1AuthRefreshGet422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthMfaPost500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthSessionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId *int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthSessionGetRequest) Authorization(authorization string) ApiV1AuthSessionGetRequest {
	r.authorization = &authorization
	return r
}

// Enterprise ID to get permissions for
func (r ApiV1AuthSessionGetRequest) EnterpriseId(enterpriseId int64) ApiV1AuthSessionGetRequest {
	r.enterpriseId = &enterpriseId
	return r
}

func (r ApiV1AuthSessionGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AuthSessionGetExecute(r)
}

/*
V1AuthSessionGet Method for V1AuthSessionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthSessionGetRequest
*/
func (a *DefaultAPIService) V1AuthSessionGet(ctx context.Context) ApiV1AuthSessionGetRequest {
	return ApiV1AuthSessionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AuthSessionGetExecute(r ApiV1AuthSessionGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthSessionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/session"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.enterpriseId == nil {
		return localVarReturnValue, nil, reportError("enterpriseId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "enterpriseId", r.enterpriseId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V1AuthSessionGet403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v V1AuthSessionGet422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthMfaPost500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthSessionRootGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthSessionRootGetRequest) Authorization(authorization string) ApiV1AuthSessionRootGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthSessionRootGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AuthSessionRootGetExecute(r)
}

/*
V1AuthSessionRootGet Method for V1AuthSessionRootGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthSessionRootGetRequest
*/
func (a *DefaultAPIService) V1AuthSessionRootGet(ctx context.Context) ApiV1AuthSessionRootGetRequest {
	return ApiV1AuthSessionRootGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AuthSessionRootGetExecute(r ApiV1AuthSessionRootGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthSessionRootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/session/root"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V1AuthSessionGet403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v V1AuthSessionGet422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v V1AuthMfaPost500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthUserGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthUserGetRequest) Authorization(authorization string) ApiV1AuthUserGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthUserGetRequest) Execute() (*V1AuthUserGetResponse, *http.Response, error) {
	return r.ApiService.V1AuthUserGetExecute(r)
}

/*
V1AuthUserGet Method for V1AuthUserGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthUserGetRequest
*/
func (a *DefaultAPIService) V1AuthUserGet(ctx context.Context) ApiV1AuthUserGetRequest {
	return ApiV1AuthUserGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthUserGetResponse
func (a *DefaultAPIService) V1AuthUserGetExecute(r ApiV1AuthUserGetRequest) (*V1AuthUserGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthUserGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthUserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1B2bExtranetMonitoringFilterPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1B2bExtranetMonitoringFilterPostRequest *V1B2bExtranetMonitoringFilterPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1B2bExtranetMonitoringFilterPostRequest) Authorization(authorization string) ApiV1B2bExtranetMonitoringFilterPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1B2bExtranetMonitoringFilterPostRequest) V1B2bExtranetMonitoringFilterPostRequest(v1B2bExtranetMonitoringFilterPostRequest V1B2bExtranetMonitoringFilterPostRequest) ApiV1B2bExtranetMonitoringFilterPostRequest {
	r.v1B2bExtranetMonitoringFilterPostRequest = &v1B2bExtranetMonitoringFilterPostRequest
	return r
}

func (r ApiV1B2bExtranetMonitoringFilterPostRequest) Execute() (*V1B2bExtranetMonitoringFilterPostResponse, *http.Response, error) {
	return r.ApiService.V1B2bExtranetMonitoringFilterPostExecute(r)
}

/*
V1B2bExtranetMonitoringFilterPost Method for V1B2bExtranetMonitoringFilterPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1B2bExtranetMonitoringFilterPostRequest
*/
func (a *DefaultAPIService) V1B2bExtranetMonitoringFilterPost(ctx context.Context) ApiV1B2bExtranetMonitoringFilterPostRequest {
	return ApiV1B2bExtranetMonitoringFilterPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1B2bExtranetMonitoringFilterPostResponse
func (a *DefaultAPIService) V1B2bExtranetMonitoringFilterPostExecute(r ApiV1B2bExtranetMonitoringFilterPostRequest) (*V1B2bExtranetMonitoringFilterPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1B2bExtranetMonitoringFilterPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1B2bExtranetMonitoringFilterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/b2b-extranet-monitoring/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1B2bExtranetMonitoringFilterPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1B2bExtranetMonitoringFilterPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1B2bExtranetMonitoringFilterPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthDeviceDeviceIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1BackboneHealthDeviceDeviceIdPostRequest *V1BackboneHealthDeviceDeviceIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthDeviceDeviceIdPostRequest) Authorization(authorization string) ApiV1BackboneHealthDeviceDeviceIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthDeviceDeviceIdPostRequest) V1BackboneHealthDeviceDeviceIdPostRequest(v1BackboneHealthDeviceDeviceIdPostRequest V1BackboneHealthDeviceDeviceIdPostRequest) ApiV1BackboneHealthDeviceDeviceIdPostRequest {
	r.v1BackboneHealthDeviceDeviceIdPostRequest = &v1BackboneHealthDeviceDeviceIdPostRequest
	return r
}

func (r ApiV1BackboneHealthDeviceDeviceIdPostRequest) Execute() (*V1BackboneHealthDeviceDeviceIdPostResponse, *http.Response, error) {
	return r.ApiService.V1BackboneHealthDeviceDeviceIdPostExecute(r)
}

/*
V1BackboneHealthDeviceDeviceIdPost Method for V1BackboneHealthDeviceDeviceIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1BackboneHealthDeviceDeviceIdPostRequest
*/
func (a *DefaultAPIService) V1BackboneHealthDeviceDeviceIdPost(ctx context.Context, deviceId int64) ApiV1BackboneHealthDeviceDeviceIdPostRequest {
	return ApiV1BackboneHealthDeviceDeviceIdPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1BackboneHealthDeviceDeviceIdPostResponse
func (a *DefaultAPIService) V1BackboneHealthDeviceDeviceIdPostExecute(r ApiV1BackboneHealthDeviceDeviceIdPostRequest) (*V1BackboneHealthDeviceDeviceIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthDeviceDeviceIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthDeviceDeviceIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/device/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BackboneHealthDeviceDeviceIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BackboneHealthDeviceDeviceIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BackboneHealthDeviceDeviceIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthEtWanMatrixGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthEtWanMatrixGetRequest) Authorization(authorization string) ApiV1BackboneHealthEtWanMatrixGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthEtWanMatrixGetRequest) Execute() (*V1BackboneHealthEtWanMatrixGetResponse, *http.Response, error) {
	return r.ApiService.V1BackboneHealthEtWanMatrixGetExecute(r)
}

/*
V1BackboneHealthEtWanMatrixGet Method for V1BackboneHealthEtWanMatrixGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthEtWanMatrixGetRequest
*/
func (a *DefaultAPIService) V1BackboneHealthEtWanMatrixGet(ctx context.Context) ApiV1BackboneHealthEtWanMatrixGetRequest {
	return ApiV1BackboneHealthEtWanMatrixGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthEtWanMatrixGetResponse
func (a *DefaultAPIService) V1BackboneHealthEtWanMatrixGetExecute(r ApiV1BackboneHealthEtWanMatrixGetRequest) (*V1BackboneHealthEtWanMatrixGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthEtWanMatrixGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthEtWanMatrixGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/et-wan-matrix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthEtetSlaMatrixGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthEtetSlaMatrixGetRequest) Authorization(authorization string) ApiV1BackboneHealthEtetSlaMatrixGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthEtetSlaMatrixGetRequest) Execute() (*V1BackboneHealthEtetSlaMatrixGetResponse, *http.Response, error) {
	return r.ApiService.V1BackboneHealthEtetSlaMatrixGetExecute(r)
}

/*
V1BackboneHealthEtetSlaMatrixGet Method for V1BackboneHealthEtetSlaMatrixGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthEtetSlaMatrixGetRequest
*/
func (a *DefaultAPIService) V1BackboneHealthEtetSlaMatrixGet(ctx context.Context) ApiV1BackboneHealthEtetSlaMatrixGetRequest {
	return ApiV1BackboneHealthEtetSlaMatrixGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthEtetSlaMatrixGetResponse
func (a *DefaultAPIService) V1BackboneHealthEtetSlaMatrixGetExecute(r ApiV1BackboneHealthEtetSlaMatrixGetRequest) (*V1BackboneHealthEtetSlaMatrixGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthEtetSlaMatrixGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthEtetSlaMatrixGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/etet-sla-matrix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthFilterGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthFilterGetRequest) Authorization(authorization string) ApiV1BackboneHealthFilterGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthFilterGetRequest) Execute() (*V1BackboneHealthFilterGetResponse, *http.Response, error) {
	return r.ApiService.V1BackboneHealthFilterGetExecute(r)
}

/*
V1BackboneHealthFilterGet Method for V1BackboneHealthFilterGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthFilterGetRequest
*/
func (a *DefaultAPIService) V1BackboneHealthFilterGet(ctx context.Context) ApiV1BackboneHealthFilterGetRequest {
	return ApiV1BackboneHealthFilterGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthFilterGetResponse
func (a *DefaultAPIService) V1BackboneHealthFilterGetExecute(r ApiV1BackboneHealthFilterGetRequest) (*V1BackboneHealthFilterGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthFilterGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthFilterGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BackboneHealthOverviewPostRequest *V1BackboneHealthOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthOverviewPostRequest) Authorization(authorization string) ApiV1BackboneHealthOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthOverviewPostRequest) V1BackboneHealthOverviewPostRequest(v1BackboneHealthOverviewPostRequest V1BackboneHealthOverviewPostRequest) ApiV1BackboneHealthOverviewPostRequest {
	r.v1BackboneHealthOverviewPostRequest = &v1BackboneHealthOverviewPostRequest
	return r
}

func (r ApiV1BackboneHealthOverviewPostRequest) Execute() (*V1BackboneHealthOverviewPostResponse, *http.Response, error) {
	return r.ApiService.V1BackboneHealthOverviewPostExecute(r)
}

/*
V1BackboneHealthOverviewPost Method for V1BackboneHealthOverviewPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthOverviewPostRequest
*/
func (a *DefaultAPIService) V1BackboneHealthOverviewPost(ctx context.Context) ApiV1BackboneHealthOverviewPostRequest {
	return ApiV1BackboneHealthOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthOverviewPostResponse
func (a *DefaultAPIService) V1BackboneHealthOverviewPostExecute(r ApiV1BackboneHealthOverviewPostRequest) (*V1BackboneHealthOverviewPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthOverviewPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BackboneHealthOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BackboneHealthOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BackboneHealthOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthTopDevicesByAlertsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BackboneHealthTopDevicesByAlertsPostRequest *V1BackboneHealthTopDevicesByAlertsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) Authorization(authorization string) ApiV1BackboneHealthTopDevicesByAlertsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) V1BackboneHealthTopDevicesByAlertsPostRequest(v1BackboneHealthTopDevicesByAlertsPostRequest V1BackboneHealthTopDevicesByAlertsPostRequest) ApiV1BackboneHealthTopDevicesByAlertsPostRequest {
	r.v1BackboneHealthTopDevicesByAlertsPostRequest = &v1BackboneHealthTopDevicesByAlertsPostRequest
	return r
}

func (r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) Execute() (*V1BackboneHealthTopDevicesByAlertsPostResponse, *http.Response, error) {
	return r.ApiService.V1BackboneHealthTopDevicesByAlertsPostExecute(r)
}

/*
V1BackboneHealthTopDevicesByAlertsPost Method for V1BackboneHealthTopDevicesByAlertsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthTopDevicesByAlertsPostRequest
*/
func (a *DefaultAPIService) V1BackboneHealthTopDevicesByAlertsPost(ctx context.Context) ApiV1BackboneHealthTopDevicesByAlertsPostRequest {
	return ApiV1BackboneHealthTopDevicesByAlertsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthTopDevicesByAlertsPostResponse
func (a *DefaultAPIService) V1BackboneHealthTopDevicesByAlertsPostExecute(r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) (*V1BackboneHealthTopDevicesByAlertsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthTopDevicesByAlertsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthTopDevicesByAlertsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/top-devices-by-alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BackboneHealthTopDevicesByAlertsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BackboneHealthTopDevicesByAlertsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BackboneHealthTopDevicesByAlertsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerEnterpriseCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerEnterpriseCsvPostRequest *V1BwtrackerEnterpriseCsvPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerEnterpriseCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerEnterpriseCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerEnterpriseCsvPostRequest) V1BwtrackerEnterpriseCsvPostRequest(v1BwtrackerEnterpriseCsvPostRequest V1BwtrackerEnterpriseCsvPostRequest) ApiV1BwtrackerEnterpriseCsvPostRequest {
	r.v1BwtrackerEnterpriseCsvPostRequest = &v1BwtrackerEnterpriseCsvPostRequest
	return r
}

func (r ApiV1BwtrackerEnterpriseCsvPostRequest) Execute() (*V1BwtrackerEnterpriseCsvPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerEnterpriseCsvPostExecute(r)
}

/*
V1BwtrackerEnterpriseCsvPost Method for V1BwtrackerEnterpriseCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerEnterpriseCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerEnterpriseCsvPost(ctx context.Context) ApiV1BwtrackerEnterpriseCsvPostRequest {
	return ApiV1BwtrackerEnterpriseCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseCsvPostResponse
func (a *DefaultAPIService) V1BwtrackerEnterpriseCsvPostExecute(r ApiV1BwtrackerEnterpriseCsvPostRequest) (*V1BwtrackerEnterpriseCsvPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseCsvPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerEnterpriseCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/enterprise/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerEnterpriseCsvPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerEnterpriseCsvPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerEnterpriseCsvPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerEnterpriseDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerEnterpriseDetailsPostRequest *V1BwtrackerEnterpriseDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerEnterpriseDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerEnterpriseDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerEnterpriseDetailsPostRequest) V1BwtrackerEnterpriseDetailsPostRequest(v1BwtrackerEnterpriseDetailsPostRequest V1BwtrackerEnterpriseDetailsPostRequest) ApiV1BwtrackerEnterpriseDetailsPostRequest {
	r.v1BwtrackerEnterpriseDetailsPostRequest = &v1BwtrackerEnterpriseDetailsPostRequest
	return r
}

func (r ApiV1BwtrackerEnterpriseDetailsPostRequest) Execute() (*V1BwtrackerEnterpriseDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerEnterpriseDetailsPostExecute(r)
}

/*
V1BwtrackerEnterpriseDetailsPost Method for V1BwtrackerEnterpriseDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerEnterpriseDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerEnterpriseDetailsPost(ctx context.Context) ApiV1BwtrackerEnterpriseDetailsPostRequest {
	return ApiV1BwtrackerEnterpriseDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseDetailsPostResponse
func (a *DefaultAPIService) V1BwtrackerEnterpriseDetailsPostExecute(r ApiV1BwtrackerEnterpriseDetailsPostRequest) (*V1BwtrackerEnterpriseDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerEnterpriseDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/enterprise/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerEnterpriseDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerEnterpriseDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerEnterpriseDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerEnterpriseSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerEnterpriseSummaryPostRequest *V1BwtrackerEnterpriseSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerEnterpriseSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerEnterpriseSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerEnterpriseSummaryPostRequest) V1BwtrackerEnterpriseSummaryPostRequest(v1BwtrackerEnterpriseSummaryPostRequest V1BwtrackerEnterpriseSummaryPostRequest) ApiV1BwtrackerEnterpriseSummaryPostRequest {
	r.v1BwtrackerEnterpriseSummaryPostRequest = &v1BwtrackerEnterpriseSummaryPostRequest
	return r
}

func (r ApiV1BwtrackerEnterpriseSummaryPostRequest) Execute() (*V1BwtrackerEnterpriseSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerEnterpriseSummaryPostExecute(r)
}

/*
V1BwtrackerEnterpriseSummaryPost Method for V1BwtrackerEnterpriseSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerEnterpriseSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerEnterpriseSummaryPost(ctx context.Context) ApiV1BwtrackerEnterpriseSummaryPostRequest {
	return ApiV1BwtrackerEnterpriseSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseSummaryPostResponse
func (a *DefaultAPIService) V1BwtrackerEnterpriseSummaryPostExecute(r ApiV1BwtrackerEnterpriseSummaryPostRequest) (*V1BwtrackerEnterpriseSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerEnterpriseSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/enterprise/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerEnterpriseSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerEnterpriseSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerEnterpriseSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionCloudChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionCloudChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionCloudChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionCloudChartPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionCloudChartPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionCloudChartPostRequest) Execute() (*V1BwtrackerRegionCloudChartPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionCloudChartPostExecute(r)
}

/*
V1BwtrackerRegionCloudChartPost Method for V1BwtrackerRegionCloudChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionCloudChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionCloudChartPost(ctx context.Context) ApiV1BwtrackerRegionCloudChartPostRequest {
	return ApiV1BwtrackerRegionCloudChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudChartPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionCloudChartPostExecute(r ApiV1BwtrackerRegionCloudChartPostRequest) (*V1BwtrackerRegionCloudChartPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudChartPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionCloudChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/cloud/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionCloudCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudCsvPostRequest *V1BwtrackerRegionCloudCsvPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionCloudCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionCloudCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionCloudCsvPostRequest) V1BwtrackerRegionCloudCsvPostRequest(v1BwtrackerRegionCloudCsvPostRequest V1BwtrackerRegionCloudCsvPostRequest) ApiV1BwtrackerRegionCloudCsvPostRequest {
	r.v1BwtrackerRegionCloudCsvPostRequest = &v1BwtrackerRegionCloudCsvPostRequest
	return r
}

func (r ApiV1BwtrackerRegionCloudCsvPostRequest) Execute() (*V1BwtrackerRegionCloudCsvPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionCloudCsvPostExecute(r)
}

/*
V1BwtrackerRegionCloudCsvPost Method for V1BwtrackerRegionCloudCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionCloudCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionCloudCsvPost(ctx context.Context) ApiV1BwtrackerRegionCloudCsvPostRequest {
	return ApiV1BwtrackerRegionCloudCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudCsvPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionCloudCsvPostExecute(r ApiV1BwtrackerRegionCloudCsvPostRequest) (*V1BwtrackerRegionCloudCsvPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudCsvPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionCloudCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/cloud/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudCsvPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudCsvPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudCsvPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionCloudSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudSummaryPostRequest *V1BwtrackerRegionCloudSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionCloudSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionCloudSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionCloudSummaryPostRequest) V1BwtrackerRegionCloudSummaryPostRequest(v1BwtrackerRegionCloudSummaryPostRequest V1BwtrackerRegionCloudSummaryPostRequest) ApiV1BwtrackerRegionCloudSummaryPostRequest {
	r.v1BwtrackerRegionCloudSummaryPostRequest = &v1BwtrackerRegionCloudSummaryPostRequest
	return r
}

func (r ApiV1BwtrackerRegionCloudSummaryPostRequest) Execute() (*V1BwtrackerRegionCloudSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionCloudSummaryPostExecute(r)
}

/*
V1BwtrackerRegionCloudSummaryPost Method for V1BwtrackerRegionCloudSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionCloudSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionCloudSummaryPost(ctx context.Context) ApiV1BwtrackerRegionCloudSummaryPostRequest {
	return ApiV1BwtrackerRegionCloudSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudSummaryPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionCloudSummaryPostExecute(r ApiV1BwtrackerRegionCloudSummaryPostRequest) (*V1BwtrackerRegionCloudSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionCloudSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/cloud/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionEdgeChartPostRequest *V1BwtrackerRegionEdgeChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeChartPostRequest) V1BwtrackerRegionEdgeChartPostRequest(v1BwtrackerRegionEdgeChartPostRequest V1BwtrackerRegionEdgeChartPostRequest) ApiV1BwtrackerRegionEdgeChartPostRequest {
	r.v1BwtrackerRegionEdgeChartPostRequest = &v1BwtrackerRegionEdgeChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeChartPostRequest) Execute() (*V1BwtrackerRegionEdgeChartPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeChartPostExecute(r)
}

/*
V1BwtrackerRegionEdgeChartPost Method for V1BwtrackerRegionEdgeChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeChartPost(ctx context.Context) ApiV1BwtrackerRegionEdgeChartPostRequest {
	return ApiV1BwtrackerRegionEdgeChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionEdgeChartPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionEdgeChartPostExecute(r ApiV1BwtrackerRegionEdgeChartPostRequest) (*V1BwtrackerRegionEdgeChartPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionEdgeChartPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionEdgeChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionEdgeChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionEdgeChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionEdgeCsvPostRequest *V1BwtrackerRegionEdgeCsvPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeCsvPostRequest) V1BwtrackerRegionEdgeCsvPostRequest(v1BwtrackerRegionEdgeCsvPostRequest V1BwtrackerRegionEdgeCsvPostRequest) ApiV1BwtrackerRegionEdgeCsvPostRequest {
	r.v1BwtrackerRegionEdgeCsvPostRequest = &v1BwtrackerRegionEdgeCsvPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeCsvPostRequest) Execute() (*V1BwtrackerRegionEdgeCsvPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeCsvPostExecute(r)
}

/*
V1BwtrackerRegionEdgeCsvPost Method for V1BwtrackerRegionEdgeCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeCsvPost(ctx context.Context) ApiV1BwtrackerRegionEdgeCsvPostRequest {
	return ApiV1BwtrackerRegionEdgeCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionEdgeCsvPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionEdgeCsvPostExecute(r ApiV1BwtrackerRegionEdgeCsvPostRequest) (*V1BwtrackerRegionEdgeCsvPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionEdgeCsvPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionEdgeCsvPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionEdgeCsvPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionEdgeCsvPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionEdgeDetailsPostRequest *V1BwtrackerRegionEdgeDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeDetailsPostRequest) V1BwtrackerRegionEdgeDetailsPostRequest(v1BwtrackerRegionEdgeDetailsPostRequest V1BwtrackerRegionEdgeDetailsPostRequest) ApiV1BwtrackerRegionEdgeDetailsPostRequest {
	r.v1BwtrackerRegionEdgeDetailsPostRequest = &v1BwtrackerRegionEdgeDetailsPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeDetailsPostRequest) Execute() (*V1BwtrackerRegionEdgeDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeDetailsPostExecute(r)
}

/*
V1BwtrackerRegionEdgeDetailsPost Method for V1BwtrackerRegionEdgeDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeDetailsPost(ctx context.Context) ApiV1BwtrackerRegionEdgeDetailsPostRequest {
	return ApiV1BwtrackerRegionEdgeDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionEdgeDetailsPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionEdgeDetailsPostExecute(r ApiV1BwtrackerRegionEdgeDetailsPostRequest) (*V1BwtrackerRegionEdgeDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionEdgeDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionEdgeDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionEdgeDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionEdgeDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionEdgeSummaryPostRequest *V1BwtrackerRegionEdgeSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeSummaryPostRequest) V1BwtrackerRegionEdgeSummaryPostRequest(v1BwtrackerRegionEdgeSummaryPostRequest V1BwtrackerRegionEdgeSummaryPostRequest) ApiV1BwtrackerRegionEdgeSummaryPostRequest {
	r.v1BwtrackerRegionEdgeSummaryPostRequest = &v1BwtrackerRegionEdgeSummaryPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeSummaryPostRequest) Execute() (*V1BwtrackerRegionEdgeSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeSummaryPostExecute(r)
}

/*
V1BwtrackerRegionEdgeSummaryPost Method for V1BwtrackerRegionEdgeSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeSummaryPost(ctx context.Context) ApiV1BwtrackerRegionEdgeSummaryPostRequest {
	return ApiV1BwtrackerRegionEdgeSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionEdgeSummaryPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionEdgeSummaryPostExecute(r ApiV1BwtrackerRegionEdgeSummaryPostRequest) (*V1BwtrackerRegionEdgeSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionEdgeSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionEdgeSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionEdgeSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionEdgeSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionGatewayChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionGatewayChartPostRequest *V1BwtrackerRegionGatewayChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionGatewayChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionGatewayChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionGatewayChartPostRequest) V1BwtrackerRegionGatewayChartPostRequest(v1BwtrackerRegionGatewayChartPostRequest V1BwtrackerRegionGatewayChartPostRequest) ApiV1BwtrackerRegionGatewayChartPostRequest {
	r.v1BwtrackerRegionGatewayChartPostRequest = &v1BwtrackerRegionGatewayChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionGatewayChartPostRequest) Execute() (*V1BwtrackerRegionGatewayChartPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionGatewayChartPostExecute(r)
}

/*
V1BwtrackerRegionGatewayChartPost Method for V1BwtrackerRegionGatewayChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionGatewayChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionGatewayChartPost(ctx context.Context) ApiV1BwtrackerRegionGatewayChartPostRequest {
	return ApiV1BwtrackerRegionGatewayChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionGatewayChartPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionGatewayChartPostExecute(r ApiV1BwtrackerRegionGatewayChartPostRequest) (*V1BwtrackerRegionGatewayChartPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionGatewayChartPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionGatewayChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/gateway/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionGatewayChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionGatewayChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionGatewayChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionGatewayCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionGatewayCsvPostRequest *V1BwtrackerRegionGatewayCsvPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionGatewayCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionGatewayCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionGatewayCsvPostRequest) V1BwtrackerRegionGatewayCsvPostRequest(v1BwtrackerRegionGatewayCsvPostRequest V1BwtrackerRegionGatewayCsvPostRequest) ApiV1BwtrackerRegionGatewayCsvPostRequest {
	r.v1BwtrackerRegionGatewayCsvPostRequest = &v1BwtrackerRegionGatewayCsvPostRequest
	return r
}

func (r ApiV1BwtrackerRegionGatewayCsvPostRequest) Execute() (*V1BwtrackerRegionGatewayCsvPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionGatewayCsvPostExecute(r)
}

/*
V1BwtrackerRegionGatewayCsvPost Method for V1BwtrackerRegionGatewayCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionGatewayCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionGatewayCsvPost(ctx context.Context) ApiV1BwtrackerRegionGatewayCsvPostRequest {
	return ApiV1BwtrackerRegionGatewayCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionGatewayCsvPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionGatewayCsvPostExecute(r ApiV1BwtrackerRegionGatewayCsvPostRequest) (*V1BwtrackerRegionGatewayCsvPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionGatewayCsvPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionGatewayCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/gateway/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionGatewayCsvPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionGatewayCsvPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionGatewayCsvPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionGatewayDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionGatewayDetailsPostRequest *V1BwtrackerRegionGatewayDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionGatewayDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionGatewayDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionGatewayDetailsPostRequest) V1BwtrackerRegionGatewayDetailsPostRequest(v1BwtrackerRegionGatewayDetailsPostRequest V1BwtrackerRegionGatewayDetailsPostRequest) ApiV1BwtrackerRegionGatewayDetailsPostRequest {
	r.v1BwtrackerRegionGatewayDetailsPostRequest = &v1BwtrackerRegionGatewayDetailsPostRequest
	return r
}

func (r ApiV1BwtrackerRegionGatewayDetailsPostRequest) Execute() (*V1BwtrackerRegionGatewayDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionGatewayDetailsPostExecute(r)
}

/*
V1BwtrackerRegionGatewayDetailsPost Method for V1BwtrackerRegionGatewayDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionGatewayDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionGatewayDetailsPost(ctx context.Context) ApiV1BwtrackerRegionGatewayDetailsPostRequest {
	return ApiV1BwtrackerRegionGatewayDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionGatewayDetailsPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionGatewayDetailsPostExecute(r ApiV1BwtrackerRegionGatewayDetailsPostRequest) (*V1BwtrackerRegionGatewayDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionGatewayDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionGatewayDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/gateway/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionGatewayDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionGatewayDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionGatewayDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionGatewaySummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionGatewaySummaryPostRequest *V1BwtrackerRegionGatewaySummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionGatewaySummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionGatewaySummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionGatewaySummaryPostRequest) V1BwtrackerRegionGatewaySummaryPostRequest(v1BwtrackerRegionGatewaySummaryPostRequest V1BwtrackerRegionGatewaySummaryPostRequest) ApiV1BwtrackerRegionGatewaySummaryPostRequest {
	r.v1BwtrackerRegionGatewaySummaryPostRequest = &v1BwtrackerRegionGatewaySummaryPostRequest
	return r
}

func (r ApiV1BwtrackerRegionGatewaySummaryPostRequest) Execute() (*V1BwtrackerRegionGatewaySummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionGatewaySummaryPostExecute(r)
}

/*
V1BwtrackerRegionGatewaySummaryPost Method for V1BwtrackerRegionGatewaySummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionGatewaySummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionGatewaySummaryPost(ctx context.Context) ApiV1BwtrackerRegionGatewaySummaryPostRequest {
	return ApiV1BwtrackerRegionGatewaySummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionGatewaySummaryPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionGatewaySummaryPostExecute(r ApiV1BwtrackerRegionGatewaySummaryPostRequest) (*V1BwtrackerRegionGatewaySummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionGatewaySummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionGatewaySummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/gateway/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionGatewaySummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionGatewaySummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionGatewaySummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteChartPostRequest *V1BwtrackerRegionSiteChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteChartPostRequest) V1BwtrackerRegionSiteChartPostRequest(v1BwtrackerRegionSiteChartPostRequest V1BwtrackerRegionSiteChartPostRequest) ApiV1BwtrackerRegionSiteChartPostRequest {
	r.v1BwtrackerRegionSiteChartPostRequest = &v1BwtrackerRegionSiteChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteChartPostRequest) Execute() (*V1BwtrackerRegionSiteChartPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteChartPostExecute(r)
}

/*
V1BwtrackerRegionSiteChartPost Method for V1BwtrackerRegionSiteChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteChartPost(ctx context.Context) ApiV1BwtrackerRegionSiteChartPostRequest {
	return ApiV1BwtrackerRegionSiteChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteChartPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionSiteChartPostExecute(r ApiV1BwtrackerRegionSiteChartPostRequest) (*V1BwtrackerRegionSiteChartPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteChartPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteDetailsPostRequest *V1BwtrackerRegionSiteDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteDetailsPostRequest) V1BwtrackerRegionSiteDetailsPostRequest(v1BwtrackerRegionSiteDetailsPostRequest V1BwtrackerRegionSiteDetailsPostRequest) ApiV1BwtrackerRegionSiteDetailsPostRequest {
	r.v1BwtrackerRegionSiteDetailsPostRequest = &v1BwtrackerRegionSiteDetailsPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteDetailsPostRequest) Execute() (*V1BwtrackerRegionSiteDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteDetailsPostExecute(r)
}

/*
V1BwtrackerRegionSiteDetailsPost Method for V1BwtrackerRegionSiteDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteDetailsPost(ctx context.Context) ApiV1BwtrackerRegionSiteDetailsPostRequest {
	return ApiV1BwtrackerRegionSiteDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteDetailsPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionSiteDetailsPostExecute(r ApiV1BwtrackerRegionSiteDetailsPostRequest) (*V1BwtrackerRegionSiteDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteGatewayChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteGatewayChartPostRequest *V1BwtrackerRegionSiteGatewayChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteGatewayChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteGatewayChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteGatewayChartPostRequest) V1BwtrackerRegionSiteGatewayChartPostRequest(v1BwtrackerRegionSiteGatewayChartPostRequest V1BwtrackerRegionSiteGatewayChartPostRequest) ApiV1BwtrackerRegionSiteGatewayChartPostRequest {
	r.v1BwtrackerRegionSiteGatewayChartPostRequest = &v1BwtrackerRegionSiteGatewayChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteGatewayChartPostRequest) Execute() (*V1BwtrackerRegionSiteGatewayChartPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteGatewayChartPostExecute(r)
}

/*
V1BwtrackerRegionSiteGatewayChartPost Method for V1BwtrackerRegionSiteGatewayChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteGatewayChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteGatewayChartPost(ctx context.Context) ApiV1BwtrackerRegionSiteGatewayChartPostRequest {
	return ApiV1BwtrackerRegionSiteGatewayChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteGatewayChartPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionSiteGatewayChartPostExecute(r ApiV1BwtrackerRegionSiteGatewayChartPostRequest) (*V1BwtrackerRegionSiteGatewayChartPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteGatewayChartPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteGatewayChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/gateway/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteGatewayChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteGatewayChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteGatewayChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteGatewayDetailsPostRequest *V1BwtrackerRegionSiteGatewayDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest) V1BwtrackerRegionSiteGatewayDetailsPostRequest(v1BwtrackerRegionSiteGatewayDetailsPostRequest V1BwtrackerRegionSiteGatewayDetailsPostRequest) ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest {
	r.v1BwtrackerRegionSiteGatewayDetailsPostRequest = &v1BwtrackerRegionSiteGatewayDetailsPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest) Execute() (*V1BwtrackerRegionSiteGatewayDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteGatewayDetailsPostExecute(r)
}

/*
V1BwtrackerRegionSiteGatewayDetailsPost Method for V1BwtrackerRegionSiteGatewayDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteGatewayDetailsPost(ctx context.Context) ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest {
	return ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteGatewayDetailsPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionSiteGatewayDetailsPostExecute(r ApiV1BwtrackerRegionSiteGatewayDetailsPostRequest) (*V1BwtrackerRegionSiteGatewayDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteGatewayDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteGatewayDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/gateway/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteGatewayDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteGatewayDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteGatewayDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteGatewaySummaryPostRequest *V1BwtrackerRegionSiteGatewaySummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest) V1BwtrackerRegionSiteGatewaySummaryPostRequest(v1BwtrackerRegionSiteGatewaySummaryPostRequest V1BwtrackerRegionSiteGatewaySummaryPostRequest) ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest {
	r.v1BwtrackerRegionSiteGatewaySummaryPostRequest = &v1BwtrackerRegionSiteGatewaySummaryPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest) Execute() (*V1BwtrackerRegionSiteGatewaySummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteGatewaySummaryPostExecute(r)
}

/*
V1BwtrackerRegionSiteGatewaySummaryPost Method for V1BwtrackerRegionSiteGatewaySummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteGatewaySummaryPost(ctx context.Context) ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest {
	return ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteGatewaySummaryPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionSiteGatewaySummaryPostExecute(r ApiV1BwtrackerRegionSiteGatewaySummaryPostRequest) (*V1BwtrackerRegionSiteGatewaySummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteGatewaySummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteGatewaySummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/gateway/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteGatewaySummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteGatewaySummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteGatewaySummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteSummaryPostRequest *V1BwtrackerRegionSiteSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteSummaryPostRequest) V1BwtrackerRegionSiteSummaryPostRequest(v1BwtrackerRegionSiteSummaryPostRequest V1BwtrackerRegionSiteSummaryPostRequest) ApiV1BwtrackerRegionSiteSummaryPostRequest {
	r.v1BwtrackerRegionSiteSummaryPostRequest = &v1BwtrackerRegionSiteSummaryPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteSummaryPostRequest) Execute() (*V1BwtrackerRegionSiteSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteSummaryPostExecute(r)
}

/*
V1BwtrackerRegionSiteSummaryPost Method for V1BwtrackerRegionSiteSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteSummaryPost(ctx context.Context) ApiV1BwtrackerRegionSiteSummaryPostRequest {
	return ApiV1BwtrackerRegionSiteSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteSummaryPostResponse
func (a *DefaultAPIService) V1BwtrackerRegionSiteSummaryPostExecute(r ApiV1BwtrackerRegionSiteSummaryPostRequest) (*V1BwtrackerRegionSiteSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerSiteCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerSiteCsvPostRequest *V1BwtrackerSiteCsvPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerSiteCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerSiteCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerSiteCsvPostRequest) V1BwtrackerSiteCsvPostRequest(v1BwtrackerSiteCsvPostRequest V1BwtrackerSiteCsvPostRequest) ApiV1BwtrackerSiteCsvPostRequest {
	r.v1BwtrackerSiteCsvPostRequest = &v1BwtrackerSiteCsvPostRequest
	return r
}

func (r ApiV1BwtrackerSiteCsvPostRequest) Execute() (*V1BwtrackerSiteCsvPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerSiteCsvPostExecute(r)
}

/*
V1BwtrackerSiteCsvPost Method for V1BwtrackerSiteCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerSiteCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerSiteCsvPost(ctx context.Context) ApiV1BwtrackerSiteCsvPostRequest {
	return ApiV1BwtrackerSiteCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerSiteCsvPostResponse
func (a *DefaultAPIService) V1BwtrackerSiteCsvPostExecute(r ApiV1BwtrackerSiteCsvPostRequest) (*V1BwtrackerSiteCsvPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerSiteCsvPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerSiteCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/site/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerSiteCsvPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerSiteCsvPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerSiteCsvPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerSiteGatewayCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerSiteGatewayCsvPostRequest *V1BwtrackerSiteGatewayCsvPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerSiteGatewayCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerSiteGatewayCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerSiteGatewayCsvPostRequest) V1BwtrackerSiteGatewayCsvPostRequest(v1BwtrackerSiteGatewayCsvPostRequest V1BwtrackerSiteGatewayCsvPostRequest) ApiV1BwtrackerSiteGatewayCsvPostRequest {
	r.v1BwtrackerSiteGatewayCsvPostRequest = &v1BwtrackerSiteGatewayCsvPostRequest
	return r
}

func (r ApiV1BwtrackerSiteGatewayCsvPostRequest) Execute() (*V1BwtrackerSiteGatewayCsvPostResponse, *http.Response, error) {
	return r.ApiService.V1BwtrackerSiteGatewayCsvPostExecute(r)
}

/*
V1BwtrackerSiteGatewayCsvPost Method for V1BwtrackerSiteGatewayCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerSiteGatewayCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerSiteGatewayCsvPost(ctx context.Context) ApiV1BwtrackerSiteGatewayCsvPostRequest {
	return ApiV1BwtrackerSiteGatewayCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerSiteGatewayCsvPostResponse
func (a *DefaultAPIService) V1BwtrackerSiteGatewayCsvPostExecute(r ApiV1BwtrackerSiteGatewayCsvPostRequest) (*V1BwtrackerSiteGatewayCsvPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerSiteGatewayCsvPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerSiteGatewayCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/site/gateway/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerSiteGatewayCsvPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerSiteGatewayCsvPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerSiteGatewayCsvPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	bucketAppName string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest) Execute() (*V1DataAssuranceAssurancesApplicationsBucketAppNameGetResponse, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesApplicationsBucketAppNameGetExecute(r)
}

/*
V1DataAssuranceAssurancesApplicationsBucketAppNameGet Method for V1DataAssuranceAssurancesApplicationsBucketAppNameGet

Gets the assurance details for all edges under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketAppName 
 @return ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesApplicationsBucketAppNameGet(ctx context.Context, bucketAppName string) ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest {
	return ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest{
		ApiService: a,
		ctx: ctx,
		bucketAppName: bucketAppName,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesApplicationsBucketAppNameGetResponse
func (a *DefaultAPIService) V1DataAssuranceAssurancesApplicationsBucketAppNameGetExecute(r ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest) (*V1DataAssuranceAssurancesApplicationsBucketAppNameGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesApplicationsBucketAppNameGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesApplicationsBucketAppNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/applications/{bucketAppName}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucketAppName"+"}", url.PathEscape(parameterValueToString(r.bucketAppName, "bucketAppName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalGetRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalGetRequest) Execute() (*V1DataAssuranceAssurancesGlobalGetResponse, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalGetExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalGet Method for V1DataAssuranceAssurancesGlobalGet

Get all assurances under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DataAssuranceAssurancesGlobalGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalGet(ctx context.Context) ApiV1DataAssuranceAssurancesGlobalGetRequest {
	return ApiV1DataAssuranceAssurancesGlobalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalGetResponse
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalGetExecute(r ApiV1DataAssuranceAssurancesGlobalGetRequest) (*V1DataAssuranceAssurancesGlobalGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalIdDeleteExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalIdDelete Method for V1DataAssuranceAssurancesGlobalIdDelete

Delete an assurance under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdDelete(ctx context.Context, id int64) ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest {
	return ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdDeleteExecute(r ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalIdGetRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdGetRequest) Execute() (*V1DataAssuranceAssurancesGlobalIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalIdGetExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalIdGet Method for V1DataAssuranceAssurancesGlobalIdGet

Get the config for an assurance under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1DataAssuranceAssurancesGlobalIdGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdGet(ctx context.Context, id int64) ApiV1DataAssuranceAssurancesGlobalIdGetRequest {
	return ApiV1DataAssuranceAssurancesGlobalIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalIdGetResponse
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdGetExecute(r ApiV1DataAssuranceAssurancesGlobalIdGetRequest) (*V1DataAssuranceAssurancesGlobalIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1DataAssuranceAssurancesGlobalIdPutRequest *V1DataAssuranceAssurancesGlobalIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) V1DataAssuranceAssurancesGlobalIdPutRequest(v1DataAssuranceAssurancesGlobalIdPutRequest V1DataAssuranceAssurancesGlobalIdPutRequest) ApiV1DataAssuranceAssurancesGlobalIdPutRequest {
	r.v1DataAssuranceAssurancesGlobalIdPutRequest = &v1DataAssuranceAssurancesGlobalIdPutRequest
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) Execute() (*V1DataAssuranceAssurancesGlobalIdPutResponse, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalIdPutExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalIdPut Method for V1DataAssuranceAssurancesGlobalIdPut

Overwrite a pre-existing assurance under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1DataAssuranceAssurancesGlobalIdPutRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdPut(ctx context.Context, id int64) ApiV1DataAssuranceAssurancesGlobalIdPutRequest {
	return ApiV1DataAssuranceAssurancesGlobalIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalIdPutResponse
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdPutExecute(r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) (*V1DataAssuranceAssurancesGlobalIdPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalIdPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DataAssuranceAssurancesGlobalIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DataAssuranceAssurancesGlobalIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DataAssuranceAssurancesGlobalIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DataAssuranceAssurancesGlobalPostRequest *V1DataAssuranceAssurancesGlobalPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalPostRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalPostRequest) V1DataAssuranceAssurancesGlobalPostRequest(v1DataAssuranceAssurancesGlobalPostRequest V1DataAssuranceAssurancesGlobalPostRequest) ApiV1DataAssuranceAssurancesGlobalPostRequest {
	r.v1DataAssuranceAssurancesGlobalPostRequest = &v1DataAssuranceAssurancesGlobalPostRequest
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalPostRequest) Execute() (*V1DataAssuranceAssurancesGlobalPostResponse, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalPostExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalPost Method for V1DataAssuranceAssurancesGlobalPost

Configure a new assurance under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DataAssuranceAssurancesGlobalPostRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalPost(ctx context.Context) ApiV1DataAssuranceAssurancesGlobalPostRequest {
	return ApiV1DataAssuranceAssurancesGlobalPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalPostResponse
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalPostExecute(r ApiV1DataAssuranceAssurancesGlobalPostRequest) (*V1DataAssuranceAssurancesGlobalPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DataAssuranceAssurancesGlobalPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DataAssuranceAssurancesGlobalPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DataAssuranceAssurancesGlobalPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceFlexAlgosGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceFlexAlgosGetRequest) Authorization(authorization string) ApiV1DataAssuranceFlexAlgosGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceFlexAlgosGetRequest) Execute() (*V1DataAssuranceFlexAlgosGetResponse, *http.Response, error) {
	return r.ApiService.V1DataAssuranceFlexAlgosGetExecute(r)
}

/*
V1DataAssuranceFlexAlgosGet Method for V1DataAssuranceFlexAlgosGet

Get all configurable flex algos under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DataAssuranceFlexAlgosGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceFlexAlgosGet(ctx context.Context) ApiV1DataAssuranceFlexAlgosGetRequest {
	return ApiV1DataAssuranceFlexAlgosGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DataAssuranceFlexAlgosGetResponse
func (a *DefaultAPIService) V1DataAssuranceFlexAlgosGetExecute(r ApiV1DataAssuranceFlexAlgosGetRequest) (*V1DataAssuranceFlexAlgosGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceFlexAlgosGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceFlexAlgosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/flex-algos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrStatsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	afiName *string
	deviceId *int64
	nbrAddress *string
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured BGP AfiSafi
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) AfiName(afiName string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.afiName = &afiName
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured BGP Nbr address
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) NbrAddress(nbrAddress string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.nbrAddress = &nbrAddress
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured BGP Instance name
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) Execute() (*V1DeviceRoutingBgpNbrStatsGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrStatsGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrStatsGet Method for V1DeviceRoutingBgpNbrStatsGet

Get BGP Nbr Stats Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrStatsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrStatsGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	return ApiV1DeviceRoutingBgpNbrStatsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrStatsGetResponse
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrStatsGetExecute(r ApiV1DeviceRoutingBgpNbrStatsGetRequest) (*V1DeviceRoutingBgpNbrStatsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrStatsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrStatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbr/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.afiName == nil {
		return localVarReturnValue, nil, reportError("afiName is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.nbrAddress == nil {
		return localVarReturnValue, nil, reportError("nbrAddress is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "afiName", r.afiName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "nbrAddress", r.nbrAddress, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingBgpNbridGetRequest) Execute() (*V1DeviceRoutingBgpNbridGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbridGetExecute(r)
}

/*
V1DeviceRoutingBgpNbridGet Method for V1DeviceRoutingBgpNbridGet

Get BGP Neighbor ID Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbridGet(ctx context.Context) ApiV1DeviceRoutingBgpNbridGetRequest {
	return ApiV1DeviceRoutingBgpNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbridGetResponse
func (a *DefaultAPIService) V1DeviceRoutingBgpNbridGetExecute(r ApiV1DeviceRoutingBgpNbridGetRequest) (*V1DeviceRoutingBgpNbridGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbridGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrsCountersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrsCountersGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrsCountersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceRoutingBgpNbrsCountersGetRequest) Execute() (*V1DeviceRoutingBgpNbrsCountersGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrsCountersGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrsCountersGet Method for V1DeviceRoutingBgpNbrsCountersGet

Get BGP Neighbor Counters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrsCountersGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsCountersGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrsCountersGetRequest {
	return ApiV1DeviceRoutingBgpNbrsCountersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrsCountersGetResponse
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsCountersGetExecute(r ApiV1DeviceRoutingBgpNbrsCountersGetRequest) (*V1DeviceRoutingBgpNbrsCountersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrsCountersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrsCountersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrs/counters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrsDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	address *string
	deviceId *int64
	vrfName *string
	interface_ *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.authorization = &authorization
	return r
}

// BGP Nbr address
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Address(address string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.address = &address
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.vrfName = &vrfName
	return r
}

// Interface name. Used in case of link local address
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Interface_(interface_ string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.interface_ = &interface_
	return r
}

func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Execute() (*V1DeviceRoutingBgpNbrsDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrsDetailsGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrsDetailsGet Method for V1DeviceRoutingBgpNbrsDetailsGet

Get BGP Neighbor Details Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrsDetailsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsDetailsGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	return ApiV1DeviceRoutingBgpNbrsDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrsDetailsGetResponse
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsDetailsGetExecute(r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) (*V1DeviceRoutingBgpNbrsDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrsDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrsDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrs/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.interface_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface", r.interface_, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	address *string
	deviceId *int64
	vrfName *string
	interface_ *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.authorization = &authorization
	return r
}

// BGP Nbr address
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Address(address string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.address = &address
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.vrfName = &vrfName
	return r
}

// Interface name. Used in case of link local address
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Interface_(interface_ string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.interface_ = &interface_
	return r
}

func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Execute() (*V1DeviceRoutingBgpNbrsPerAfiPrefixGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrsPerAfiPrefixGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrsPerAfiPrefixGet Method for V1DeviceRoutingBgpNbrsPerAfiPrefixGet

Get BGP Neighbor Per Afi Prefix Counter

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsPerAfiPrefixGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	return ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrsPerAfiPrefixGetResponse
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsPerAfiPrefixGetExecute(r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) (*V1DeviceRoutingBgpNbrsPerAfiPrefixGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrsPerAfiPrefixGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrsPerAfiPrefixGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrs/per-afi-prefix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.interface_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface", r.interface_, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOdpNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOdpNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOdpNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOdpNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOdpNbridGetRequest) Execute() (*V1DeviceRoutingOdpNbridGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOdpNbridGetExecute(r)
}

/*
V1DeviceRoutingOdpNbridGet Method for V1DeviceRoutingOdpNbridGet

Get BGP Neighbor addresses from ODP server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOdpNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOdpNbridGet(ctx context.Context) ApiV1DeviceRoutingOdpNbridGetRequest {
	return ApiV1DeviceRoutingOdpNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOdpNbridGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOdpNbridGetExecute(r ApiV1DeviceRoutingOdpNbridGetRequest) (*V1DeviceRoutingOdpNbridGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOdpNbridGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOdpNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/odp/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaInterfaceGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaInterfaceGet Method for V1DeviceRoutingOspfv2AreaInterfaceGet

Get OSPFv2 Area's Interface specific Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceGetExecute(r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaInterfaceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	interfaceId *string
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured Interface name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) InterfaceId(interfaceId string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.interfaceId = &interfaceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceNbridGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaInterfaceNbridGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaInterfaceNbridGet Method for V1DeviceRoutingOspfv2AreaInterfaceNbridGet

Get OSPFv2 Area's interface's Nbr ID table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceNbridGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceNbridGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceNbridGetExecute(r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceNbridGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceNbridGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaInterfaceNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/interface/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.interfaceId == nil {
		return localVarReturnValue, nil, reportError("interfaceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceId", r.interfaceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceidGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaInterfaceidGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaInterfaceidGet Method for V1DeviceRoutingOspfv2AreaInterfaceidGet

Get OSPFv2 Area's Interface ID Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceidGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceidGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceidGetExecute(r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceidGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceidGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaInterfaceidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/interfaceid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaLsdbGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaLsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaLsdbGet Method for V1DeviceRoutingOspfv2AreaLsdbGet

Get OSPFv2 Area specific LSDB Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaLsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaLsdbGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaLsdbGetExecute(r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) (*V1DeviceRoutingOspfv2AreaLsdbGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaLsdbGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaLsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.instanceName == nil {
		return localVarReturnValue, nil, reportError("instanceName is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaNbrGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaNbrGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaNbrGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaNbrGet Method for V1DeviceRoutingOspfv2AreaNbrGet

Get OSPFv2 Area's Neighbors Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaNbrGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaNbrGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaNbrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaNbrGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaNbrGetExecute(r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) (*V1DeviceRoutingOspfv2AreaNbrGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaNbrGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaNbrGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/nbr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaidGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaidGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaidGet Method for V1DeviceRoutingOspfv2AreaidGet

Get OSPFv2 Area ID Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaidGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaidGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaidGetExecute(r ApiV1DeviceRoutingOspfv2AreaidGetRequest) (*V1DeviceRoutingOspfv2AreaidGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaidGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/areaid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2LsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) Execute() (*V1DeviceRoutingOspfv2LsdbGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2LsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv2LsdbGet Method for V1DeviceRoutingOspfv2LsdbGet

Get OSPFv2 global LSDB Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2LsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2LsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	return ApiV1DeviceRoutingOspfv2LsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2LsdbGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2LsdbGetExecute(r ApiV1DeviceRoutingOspfv2LsdbGetRequest) (*V1DeviceRoutingOspfv2LsdbGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2LsdbGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2LsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2RibGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
	instanceName *string
	before *string
	last *int32
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Before(before string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.before = &before
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.last = &last
	return r
}

func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Execute() (*V1DeviceRoutingOspfv2RibGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2RibGetExecute(r)
}

/*
V1DeviceRoutingOspfv2RibGet Method for V1DeviceRoutingOspfv2RibGet

Get OSPFv2 Local RIB Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2RibGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2RibGet(ctx context.Context) ApiV1DeviceRoutingOspfv2RibGetRequest {
	return ApiV1DeviceRoutingOspfv2RibGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2RibGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2RibGetExecute(r ApiV1DeviceRoutingOspfv2RibGetRequest) (*V1DeviceRoutingOspfv2RibGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2RibGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2RibGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/rib"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2StatisticsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfNames *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) VrfNames(vrfNames []string) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	r.vrfNames = &vrfNames
	return r
}

func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) Execute() (*V1DeviceRoutingOspfv2StatisticsGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2StatisticsGetExecute(r)
}

/*
V1DeviceRoutingOspfv2StatisticsGet Method for V1DeviceRoutingOspfv2StatisticsGet

Get OSPFv2 Statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2StatisticsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2StatisticsGet(ctx context.Context) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	return ApiV1DeviceRoutingOspfv2StatisticsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2StatisticsGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv2StatisticsGetExecute(r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) (*V1DeviceRoutingOspfv2StatisticsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2StatisticsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2StatisticsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfNames == nil {
		return localVarReturnValue, nil, reportError("vrfNames is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	{
		t := *r.vrfNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) Execute() (*V1DeviceRoutingOspfv3AreaInterfaceGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaInterfaceGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaInterfaceGet Method for V1DeviceRoutingOspfv3AreaInterfaceGet

Get OSPFv3 Area's Interface specific Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3AreaInterfaceGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceGetExecute(r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) (*V1DeviceRoutingOspfv3AreaInterfaceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3AreaInterfaceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaInterfaceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	interfaceId *string
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured Interface name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) InterfaceId(interfaceId string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.interfaceId = &interfaceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) Execute() (*V1DeviceRoutingOspfv3AreaInterfaceNbridGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaInterfaceNbridGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaInterfaceNbridGet Method for V1DeviceRoutingOspfv3AreaInterfaceNbridGet

Get OSPFv3 Area's interface's List of Nbr IDs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceNbridGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3AreaInterfaceNbridGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceNbridGetExecute(r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) (*V1DeviceRoutingOspfv3AreaInterfaceNbridGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3AreaInterfaceNbridGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaInterfaceNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/interface/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.interfaceId == nil {
		return localVarReturnValue, nil, reportError("interfaceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceId", r.interfaceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) Execute() (*V1DeviceRoutingOspfv3AreaInterfaceidGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaInterfaceidGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaInterfaceidGet Method for V1DeviceRoutingOspfv3AreaInterfaceidGet

Get OSPFv3 Area's Interface ID Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceidGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3AreaInterfaceidGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceidGetExecute(r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) (*V1DeviceRoutingOspfv3AreaInterfaceidGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3AreaInterfaceidGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaInterfaceidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/interfaceid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) Execute() (*V1DeviceRoutingOspfv3AreaLsdbGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaLsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaLsdbGet Method for V1DeviceRoutingOspfv3AreaLsdbGet

Get OSPFv3 Area LSDB Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaLsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3AreaLsdbGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaLsdbGetExecute(r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) (*V1DeviceRoutingOspfv3AreaLsdbGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3AreaLsdbGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaLsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.instanceName == nil {
		return localVarReturnValue, nil, reportError("instanceName is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaNbrGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) Execute() (*V1DeviceRoutingOspfv3AreaNbrGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaNbrGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaNbrGet Method for V1DeviceRoutingOspfv3AreaNbrGet

Get OSPFv3 Area's Neighbors Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaNbrGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaNbrGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaNbrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3AreaNbrGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaNbrGetExecute(r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) (*V1DeviceRoutingOspfv3AreaNbrGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3AreaNbrGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaNbrGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/nbr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.areaId == nil {
		return localVarReturnValue, nil, reportError("areaId is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) Execute() (*V1DeviceRoutingOspfv3AreaidGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaidGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaidGet Method for V1DeviceRoutingOspfv3AreaidGet

Get OSPFv3 Area ID Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaidGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3AreaidGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaidGetExecute(r ApiV1DeviceRoutingOspfv3AreaidGetRequest) (*V1DeviceRoutingOspfv3AreaidGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3AreaidGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/areaid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3LsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) Execute() (*V1DeviceRoutingOspfv3LsdbGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3LsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv3LsdbGet Method for V1DeviceRoutingOspfv3LsdbGet

Get OSPFv3 global LSDB Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3LsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3LsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	return ApiV1DeviceRoutingOspfv3LsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3LsdbGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3LsdbGetExecute(r ApiV1DeviceRoutingOspfv3LsdbGetRequest) (*V1DeviceRoutingOspfv3LsdbGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3LsdbGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3LsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3RibGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
	instanceName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.vrfName = &vrfName
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiV1DeviceRoutingOspfv3RibGetRequest) Execute() (*V1DeviceRoutingOspfv3RibGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3RibGetExecute(r)
}

/*
V1DeviceRoutingOspfv3RibGet Method for V1DeviceRoutingOspfv3RibGet

Get OSPFv3 Local RIB Table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3RibGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3RibGet(ctx context.Context) ApiV1DeviceRoutingOspfv3RibGetRequest {
	return ApiV1DeviceRoutingOspfv3RibGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3RibGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3RibGetExecute(r ApiV1DeviceRoutingOspfv3RibGetRequest) (*V1DeviceRoutingOspfv3RibGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3RibGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3RibGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/rib"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3StatisticsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfNames *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) VrfNames(vrfNames []string) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	r.vrfNames = &vrfNames
	return r
}

func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) Execute() (*V1DeviceRoutingOspfv3StatisticsGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3StatisticsGetExecute(r)
}

/*
V1DeviceRoutingOspfv3StatisticsGet Method for V1DeviceRoutingOspfv3StatisticsGet

Get OSPFv3 Statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3StatisticsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3StatisticsGet(ctx context.Context) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	return ApiV1DeviceRoutingOspfv3StatisticsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv3StatisticsGetResponse
func (a *DefaultAPIService) V1DeviceRoutingOspfv3StatisticsGetExecute(r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) (*V1DeviceRoutingOspfv3StatisticsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv3StatisticsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3StatisticsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfNames == nil {
		return localVarReturnValue, nil, reportError("vrfNames is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	{
		t := *r.vrfNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingRibRouteCountPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *[]string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingRibRouteCountPostRequest) Authorization(authorization string) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingRibRouteCountPostRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF names
func (r ApiV1DeviceRoutingRibRouteCountPostRequest) VrfName(vrfName []string) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingRibRouteCountPostRequest) Body(body map[string]interface{}) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DeviceRoutingRibRouteCountPostRequest) Execute() (*V1DeviceRoutingRibRouteCountPostResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingRibRouteCountPostExecute(r)
}

/*
V1DeviceRoutingRibRouteCountPost Method for V1DeviceRoutingRibRouteCountPost

Get BGP VRF installed route count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingRibRouteCountPostRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingRibRouteCountPost(ctx context.Context) ApiV1DeviceRoutingRibRouteCountPostRequest {
	return ApiV1DeviceRoutingRibRouteCountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingRibRouteCountPostResponse
func (a *DefaultAPIService) V1DeviceRoutingRibRouteCountPostExecute(r ApiV1DeviceRoutingRibRouteCountPostRequest) (*V1DeviceRoutingRibRouteCountPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingRibRouteCountPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingRibRouteCountPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/rib/route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	{
		t := *r.vrfName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) Authorization(authorization string) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF names
func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) Execute() (*V1DeviceRoutingVrfBgpEibgpRouteCountGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingVrfBgpEibgpRouteCountGetExecute(r)
}

/*
V1DeviceRoutingVrfBgpEibgpRouteCountGet Method for V1DeviceRoutingVrfBgpEibgpRouteCountGet

Get eBGP/iBGP VRF route count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpEibgpRouteCountGet(ctx context.Context) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	return ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpEibgpRouteCountGetResponse
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpEibgpRouteCountGetExecute(r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) (*V1DeviceRoutingVrfBgpEibgpRouteCountGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpEibgpRouteCountGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingVrfBgpEibgpRouteCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/vrf/bgp/eibgp-route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) Authorization(authorization string) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF names
func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) Execute() (*V1DeviceRoutingVrfBgpGraphiantEirouteCountGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingVrfBgpGraphiantEirouteCountGetExecute(r)
}

/*
V1DeviceRoutingVrfBgpGraphiantEirouteCountGet Method for V1DeviceRoutingVrfBgpGraphiantEirouteCountGet

Get eBGP and iBGP VRF route count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpGraphiantEirouteCountGet(ctx context.Context) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	return ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpGraphiantEirouteCountGetResponse
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpGraphiantEirouteCountGetExecute(r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) (*V1DeviceRoutingVrfBgpGraphiantEirouteCountGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpGraphiantEirouteCountGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingVrfBgpGraphiantEirouteCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/vrf/bgp/graphiant-eiroute-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingVrfBgpRouteCountPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceRoutingVrfBgpRouteCountPostRequest *V1DeviceRoutingVrfBgpRouteCountPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) Authorization(authorization string) ApiV1DeviceRoutingVrfBgpRouteCountPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) V1DeviceRoutingVrfBgpRouteCountPostRequest(v1DeviceRoutingVrfBgpRouteCountPostRequest V1DeviceRoutingVrfBgpRouteCountPostRequest) ApiV1DeviceRoutingVrfBgpRouteCountPostRequest {
	r.v1DeviceRoutingVrfBgpRouteCountPostRequest = &v1DeviceRoutingVrfBgpRouteCountPostRequest
	return r
}

func (r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) Execute() (*V1DeviceRoutingVrfBgpRouteCountPostResponse, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingVrfBgpRouteCountPostExecute(r)
}

/*
V1DeviceRoutingVrfBgpRouteCountPost Method for V1DeviceRoutingVrfBgpRouteCountPost

Get BGP VRF route count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingVrfBgpRouteCountPostRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpRouteCountPost(ctx context.Context) ApiV1DeviceRoutingVrfBgpRouteCountPostRequest {
	return ApiV1DeviceRoutingVrfBgpRouteCountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpRouteCountPostResponse
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpRouteCountPostExecute(r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) (*V1DeviceRoutingVrfBgpRouteCountPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpRouteCountPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingVrfBgpRouteCountPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/vrf/bgp/route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceRoutingVrfBgpRouteCountPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceRoutingVrfBgpRouteCountPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceRoutingVrfBgpRouteCountPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotDeviceIdGetRequest) Authorization(authorization string) ApiV1DeviceSnapshotDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotDeviceIdGetRequest) Execute() (*V1DeviceSnapshotDeviceIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotDeviceIdGetExecute(r)
}

/*
V1DeviceSnapshotDeviceIdGet Method for V1DeviceSnapshotDeviceIdGet

Get all of a device's snapshots

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DeviceSnapshotDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DeviceSnapshotDeviceIdGetRequest {
	return ApiV1DeviceSnapshotDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DeviceSnapshotDeviceIdGetResponse
func (a *DefaultAPIService) V1DeviceSnapshotDeviceIdGetExecute(r ApiV1DeviceSnapshotDeviceIdGetRequest) (*V1DeviceSnapshotDeviceIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceSnapshotDeviceIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotGetRequest) Authorization(authorization string) ApiV1DeviceSnapshotGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotGetRequest) Execute() (*V1DeviceSnapshotGetResponse, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotGetExecute(r)
}

/*
V1DeviceSnapshotGet Method for V1DeviceSnapshotGet

Get the specified device snapshots using the snapshot id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceSnapshotGetRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotGet(ctx context.Context) ApiV1DeviceSnapshotGetRequest {
	return ApiV1DeviceSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceSnapshotGetResponse
func (a *DefaultAPIService) V1DeviceSnapshotGetExecute(r ApiV1DeviceSnapshotGetRequest) (*V1DeviceSnapshotGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceSnapshotGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceSnapshotPostRequest *V1DeviceSnapshotPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotPostRequest) Authorization(authorization string) ApiV1DeviceSnapshotPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotPostRequest) V1DeviceSnapshotPostRequest(v1DeviceSnapshotPostRequest V1DeviceSnapshotPostRequest) ApiV1DeviceSnapshotPostRequest {
	r.v1DeviceSnapshotPostRequest = &v1DeviceSnapshotPostRequest
	return r
}

func (r ApiV1DeviceSnapshotPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotPostExecute(r)
}

/*
V1DeviceSnapshotPost Method for V1DeviceSnapshotPost

Create a device snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceSnapshotPostRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotPost(ctx context.Context) ApiV1DeviceSnapshotPostRequest {
	return ApiV1DeviceSnapshotPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DeviceSnapshotPostExecute(r ApiV1DeviceSnapshotPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceSnapshotPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceSnapshotPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceSnapshotPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceSnapshotPutRequest *V1DeviceSnapshotPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotPutRequest) Authorization(authorization string) ApiV1DeviceSnapshotPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotPutRequest) V1DeviceSnapshotPutRequest(v1DeviceSnapshotPutRequest V1DeviceSnapshotPutRequest) ApiV1DeviceSnapshotPutRequest {
	r.v1DeviceSnapshotPutRequest = &v1DeviceSnapshotPutRequest
	return r
}

func (r ApiV1DeviceSnapshotPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotPutExecute(r)
}

/*
V1DeviceSnapshotPut Method for V1DeviceSnapshotPut

Update an existing device snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceSnapshotPutRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotPut(ctx context.Context) ApiV1DeviceSnapshotPutRequest {
	return ApiV1DeviceSnapshotPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DeviceSnapshotPutExecute(r ApiV1DeviceSnapshotPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceSnapshotPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceSnapshotPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceSnapshotPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotSnapshotIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	snapshotId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotSnapshotIdDeleteRequest) Authorization(authorization string) ApiV1DeviceSnapshotSnapshotIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotSnapshotIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DeviceSnapshotSnapshotIdDeleteExecute(r)
}

/*
V1DeviceSnapshotSnapshotIdDelete Method for V1DeviceSnapshotSnapshotIdDelete

Delete specified device snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param snapshotId 
 @return ApiV1DeviceSnapshotSnapshotIdDeleteRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotSnapshotIdDelete(ctx context.Context, snapshotId int64) ApiV1DeviceSnapshotSnapshotIdDeleteRequest {
	return ApiV1DeviceSnapshotSnapshotIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DeviceSnapshotSnapshotIdDeleteExecute(r ApiV1DeviceSnapshotSnapshotIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotSnapshotIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot/{snapshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DeviceStatusHistoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceStatusHistoryPostRequest *V1DeviceStatusHistoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceStatusHistoryPostRequest) Authorization(authorization string) ApiV1DeviceStatusHistoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceStatusHistoryPostRequest) V1DeviceStatusHistoryPostRequest(v1DeviceStatusHistoryPostRequest V1DeviceStatusHistoryPostRequest) ApiV1DeviceStatusHistoryPostRequest {
	r.v1DeviceStatusHistoryPostRequest = &v1DeviceStatusHistoryPostRequest
	return r
}

func (r ApiV1DeviceStatusHistoryPostRequest) Execute() (*V1DeviceStatusHistoryPostResponse, *http.Response, error) {
	return r.ApiService.V1DeviceStatusHistoryPostExecute(r)
}

/*
V1DeviceStatusHistoryPost Method for V1DeviceStatusHistoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceStatusHistoryPostRequest
*/
func (a *DefaultAPIService) V1DeviceStatusHistoryPost(ctx context.Context) ApiV1DeviceStatusHistoryPostRequest {
	return ApiV1DeviceStatusHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceStatusHistoryPostResponse
func (a *DefaultAPIService) V1DeviceStatusHistoryPostExecute(r ApiV1DeviceStatusHistoryPostRequest) (*V1DeviceStatusHistoryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceStatusHistoryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceStatusHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device-status/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceStatusHistoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceStatusHistoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceStatusHistoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceStatusPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceStatusPostRequest *V1DeviceStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceStatusPostRequest) Authorization(authorization string) ApiV1DeviceStatusPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceStatusPostRequest) V1DeviceStatusPostRequest(v1DeviceStatusPostRequest V1DeviceStatusPostRequest) ApiV1DeviceStatusPostRequest {
	r.v1DeviceStatusPostRequest = &v1DeviceStatusPostRequest
	return r
}

func (r ApiV1DeviceStatusPostRequest) Execute() (*V1DeviceStatusPostResponse, *http.Response, error) {
	return r.ApiService.V1DeviceStatusPostExecute(r)
}

/*
V1DeviceStatusPost Method for V1DeviceStatusPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceStatusPostRequest
*/
func (a *DefaultAPIService) V1DeviceStatusPost(ctx context.Context) ApiV1DeviceStatusPostRequest {
	return ApiV1DeviceStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceStatusPostResponse
func (a *DefaultAPIService) V1DeviceStatusPostExecute(r ApiV1DeviceStatusPostRequest) (*V1DeviceStatusPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceStatusPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesBringupPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupPostRequest *V1DevicesBringupPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesBringupPostRequest) Authorization(authorization string) ApiV1DevicesBringupPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesBringupPostRequest) V1DevicesBringupPostRequest(v1DevicesBringupPostRequest V1DevicesBringupPostRequest) ApiV1DevicesBringupPostRequest {
	r.v1DevicesBringupPostRequest = &v1DevicesBringupPostRequest
	return r
}

func (r ApiV1DevicesBringupPostRequest) Execute() (*V1DevicesBringupPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesBringupPostExecute(r)
}

/*
V1DevicesBringupPost Method for V1DevicesBringupPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesBringupPostRequest
*/
func (a *DefaultAPIService) V1DevicesBringupPost(ctx context.Context) ApiV1DevicesBringupPostRequest {
	return ApiV1DevicesBringupPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesBringupPostResponse
func (a *DefaultAPIService) V1DevicesBringupPostExecute(r ApiV1DevicesBringupPostRequest) (*V1DevicesBringupPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesBringupPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesBringupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/bringup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesBringupPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesBringupPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupPutRequest *V1DevicesBringupPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesBringupPutRequest) Authorization(authorization string) ApiV1DevicesBringupPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesBringupPutRequest) V1DevicesBringupPutRequest(v1DevicesBringupPutRequest V1DevicesBringupPutRequest) ApiV1DevicesBringupPutRequest {
	r.v1DevicesBringupPutRequest = &v1DevicesBringupPutRequest
	return r
}

func (r ApiV1DevicesBringupPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesBringupPutExecute(r)
}

/*
V1DevicesBringupPut Method for V1DevicesBringupPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesBringupPutRequest
*/
func (a *DefaultAPIService) V1DevicesBringupPut(ctx context.Context) ApiV1DevicesBringupPutRequest {
	return ApiV1DevicesBringupPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesBringupPutExecute(r ApiV1DevicesBringupPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesBringupPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/bringup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupPutRequest == nil {
		return nil, reportError("v1DevicesBringupPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DevicesBringupTokenPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupTokenPostRequest *V1DevicesBringupTokenPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesBringupTokenPostRequest) Authorization(authorization string) ApiV1DevicesBringupTokenPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesBringupTokenPostRequest) V1DevicesBringupTokenPostRequest(v1DevicesBringupTokenPostRequest V1DevicesBringupTokenPostRequest) ApiV1DevicesBringupTokenPostRequest {
	r.v1DevicesBringupTokenPostRequest = &v1DevicesBringupTokenPostRequest
	return r
}

func (r ApiV1DevicesBringupTokenPostRequest) Execute() (*V1DevicesBringupTokenPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesBringupTokenPostExecute(r)
}

/*
V1DevicesBringupTokenPost Method for V1DevicesBringupTokenPost

VM edge onboarding token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesBringupTokenPostRequest
*/
func (a *DefaultAPIService) V1DevicesBringupTokenPost(ctx context.Context) ApiV1DevicesBringupTokenPostRequest {
	return ApiV1DevicesBringupTokenPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesBringupTokenPostResponse
func (a *DefaultAPIService) V1DevicesBringupTokenPostExecute(r ApiV1DevicesBringupTokenPostRequest) (*V1DevicesBringupTokenPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesBringupTokenPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesBringupTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/bringup/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupTokenPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesBringupTokenPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupTokenPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesClearNewFlagPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesClearNewFlagPostRequest) Authorization(authorization string) ApiV1DevicesClearNewFlagPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesClearNewFlagPostRequest) Body(body map[string]interface{}) ApiV1DevicesClearNewFlagPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DevicesClearNewFlagPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesClearNewFlagPostExecute(r)
}

/*
V1DevicesClearNewFlagPost Method for V1DevicesClearNewFlagPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesClearNewFlagPostRequest
*/
func (a *DefaultAPIService) V1DevicesClearNewFlagPost(ctx context.Context) ApiV1DevicesClearNewFlagPostRequest {
	return ApiV1DevicesClearNewFlagPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesClearNewFlagPostExecute(r ApiV1DevicesClearNewFlagPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesClearNewFlagPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/clear-new-flag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdArpGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdArpGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdArpGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdArpGetRequest) Execute() (*V1DevicesDeviceIdArpGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdArpGetExecute(r)
}

/*
V1DevicesDeviceIdArpGet Method for V1DevicesDeviceIdArpGet

Get ARP monitoring table for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdArpGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdArpGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdArpGetRequest {
	return ApiV1DevicesDeviceIdArpGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdArpGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdArpGetExecute(r ApiV1DevicesDeviceIdArpGetRequest) (*V1DevicesDeviceIdArpGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdArpGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdArpGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/arp"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdCandidateCircuitsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdCandidateCircuitsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdCandidateCircuitsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdCandidateCircuitsGetRequest) Execute() (*V1DevicesDeviceIdCandidateCircuitsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdCandidateCircuitsGetExecute(r)
}

/*
V1DevicesDeviceIdCandidateCircuitsGet Method for V1DevicesDeviceIdCandidateCircuitsGet

Get the candidate circuits for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdCandidateCircuitsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdCandidateCircuitsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdCandidateCircuitsGetRequest {
	return ApiV1DevicesDeviceIdCandidateCircuitsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdCandidateCircuitsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdCandidateCircuitsGetExecute(r ApiV1DevicesDeviceIdCandidateCircuitsGetRequest) (*V1DevicesDeviceIdCandidateCircuitsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdCandidateCircuitsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdCandidateCircuitsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/candidate-circuits"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest) Execute() (*V1DevicesDeviceIdCircuitsVrfAssociationsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdCircuitsVrfAssociationsGetExecute(r)
}

/*
V1DevicesDeviceIdCircuitsVrfAssociationsGet Method for V1DevicesDeviceIdCircuitsVrfAssociationsGet

Get the VRF, interface, &, if relevant, loopback interfaces for a list of circuits

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdCircuitsVrfAssociationsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest {
	return ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdCircuitsVrfAssociationsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdCircuitsVrfAssociationsGetExecute(r ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest) (*V1DevicesDeviceIdCircuitsVrfAssociationsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdCircuitsVrfAssociationsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdCircuitsVrfAssociationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/circuits/vrf-associations"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdConfigPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DevicesDeviceIdConfigPutRequest *V1DevicesDeviceIdConfigPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdConfigPutRequest) Authorization(authorization string) ApiV1DevicesDeviceIdConfigPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdConfigPutRequest) V1DevicesDeviceIdConfigPutRequest(v1DevicesDeviceIdConfigPutRequest V1DevicesDeviceIdConfigPutRequest) ApiV1DevicesDeviceIdConfigPutRequest {
	r.v1DevicesDeviceIdConfigPutRequest = &v1DevicesDeviceIdConfigPutRequest
	return r
}

func (r ApiV1DevicesDeviceIdConfigPutRequest) Execute() (*V1DevicesDeviceIdConfigPutResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdConfigPutExecute(r)
}

/*
V1DevicesDeviceIdConfigPut Method for V1DevicesDeviceIdConfigPut

Update a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdConfigPutRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdConfigPut(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdConfigPutRequest {
	return ApiV1DevicesDeviceIdConfigPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdConfigPutResponse
func (a *DefaultAPIService) V1DevicesDeviceIdConfigPutExecute(r ApiV1DevicesDeviceIdConfigPutRequest) (*V1DevicesDeviceIdConfigPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdConfigPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdConfigPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesDeviceIdConfigPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesDeviceIdConfigPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesDeviceIdConfigPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdConnectivityGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdConnectivityGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdConnectivityGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdConnectivityGetRequest) Execute() (*V1DevicesDeviceIdConnectivityGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdConnectivityGetExecute(r)
}

/*
V1DevicesDeviceIdConnectivityGet Method for V1DevicesDeviceIdConnectivityGet

Get the connectivity graph for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdConnectivityGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdConnectivityGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdConnectivityGetRequest {
	return ApiV1DevicesDeviceIdConnectivityGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdConnectivityGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdConnectivityGetExecute(r ApiV1DevicesDeviceIdConnectivityGetRequest) (*V1DevicesDeviceIdConnectivityGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdConnectivityGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdConnectivityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/connectivity"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdControllerPeersPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DevicesDeviceIdControllerPeersPutRequest *V1DevicesDeviceIdControllerPeersPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdControllerPeersPutRequest) Authorization(authorization string) ApiV1DevicesDeviceIdControllerPeersPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdControllerPeersPutRequest) V1DevicesDeviceIdControllerPeersPutRequest(v1DevicesDeviceIdControllerPeersPutRequest V1DevicesDeviceIdControllerPeersPutRequest) ApiV1DevicesDeviceIdControllerPeersPutRequest {
	r.v1DevicesDeviceIdControllerPeersPutRequest = &v1DevicesDeviceIdControllerPeersPutRequest
	return r
}

func (r ApiV1DevicesDeviceIdControllerPeersPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdControllerPeersPutExecute(r)
}

/*
V1DevicesDeviceIdControllerPeersPut Method for V1DevicesDeviceIdControllerPeersPut

Update peer list for controller

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdControllerPeersPutRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdControllerPeersPut(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdControllerPeersPutRequest {
	return ApiV1DevicesDeviceIdControllerPeersPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesDeviceIdControllerPeersPutExecute(r ApiV1DevicesDeviceIdControllerPeersPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdControllerPeersPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/controller-peers"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesDeviceIdControllerPeersPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesDeviceIdControllerPeersPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesDeviceIdControllerPeersPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest) Execute() (*V1DevicesDeviceIdDhcpServerLeasesGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDhcpServerLeasesGetExecute(r)
}

/*
V1DevicesDeviceIdDhcpServerLeasesGet Method for V1DevicesDeviceIdDhcpServerLeasesGet

Get current DHCP leases for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDhcpServerLeasesGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest {
	return ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdDhcpServerLeasesGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdDhcpServerLeasesGetExecute(r ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest) (*V1DevicesDeviceIdDhcpServerLeasesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdDhcpServerLeasesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDhcpServerLeasesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/dhcp-server/leases"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDraftDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDraftDeleteRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDraftDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDraftDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDraftDeleteExecute(r)
}

/*
V1DevicesDeviceIdDraftDelete Method for V1DevicesDeviceIdDraftDelete

Delete draft configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDraftDeleteRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDraftDelete(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDraftDeleteRequest {
	return ApiV1DevicesDeviceIdDraftDeleteRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesDeviceIdDraftDeleteExecute(r ApiV1DevicesDeviceIdDraftDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDraftDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDraftGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDraftGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDraftGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDraftGetRequest) Execute() (*V1DevicesDeviceIdDraftGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDraftGetExecute(r)
}

/*
V1DevicesDeviceIdDraftGet Method for V1DevicesDeviceIdDraftGet

Get draft configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDraftGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDraftGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDraftGetRequest {
	return ApiV1DevicesDeviceIdDraftGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdDraftGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdDraftGetExecute(r ApiV1DevicesDeviceIdDraftGetRequest) (*V1DevicesDeviceIdDraftGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdDraftGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDraftGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDraftPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DevicesDeviceIdDraftPostRequest *V1DevicesDeviceIdDraftPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDraftPostRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDraftPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDraftPostRequest) V1DevicesDeviceIdDraftPostRequest(v1DevicesDeviceIdDraftPostRequest V1DevicesDeviceIdDraftPostRequest) ApiV1DevicesDeviceIdDraftPostRequest {
	r.v1DevicesDeviceIdDraftPostRequest = &v1DevicesDeviceIdDraftPostRequest
	return r
}

func (r ApiV1DevicesDeviceIdDraftPostRequest) Execute() (*V1DevicesDeviceIdDraftPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDraftPostExecute(r)
}

/*
V1DevicesDeviceIdDraftPost Method for V1DevicesDeviceIdDraftPost

Save draft configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDraftPostRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDraftPost(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDraftPostRequest {
	return ApiV1DevicesDeviceIdDraftPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdDraftPostResponse
func (a *DefaultAPIService) V1DevicesDeviceIdDraftPostExecute(r ApiV1DevicesDeviceIdDraftPostRequest) (*V1DevicesDeviceIdDraftPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdDraftPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDraftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesDeviceIdDraftPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesDeviceIdDraftPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesDeviceIdDraftPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdEdgesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdEdgesGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdEdgesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdEdgesGetRequest) Execute() (*V1DevicesDeviceIdEdgesGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdEdgesGetExecute(r)
}

/*
V1DevicesDeviceIdEdgesGet Method for V1DevicesDeviceIdEdgesGet

Get a list of candidate edges for a Core, ODP server or T2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdEdgesGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdEdgesGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdEdgesGetRequest {
	return ApiV1DevicesDeviceIdEdgesGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdEdgesGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdEdgesGetExecute(r ApiV1DevicesDeviceIdEdgesGetRequest) (*V1DevicesDeviceIdEdgesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdEdgesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdEdgesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/edges"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdGetRequest) Execute() (*V1DevicesDeviceIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdGetExecute(r)
}

/*
V1DevicesDeviceIdGet Method for V1DevicesDeviceIdGet

Get a specific device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdGetRequest {
	return ApiV1DevicesDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdGetExecute(r ApiV1DevicesDeviceIdGetRequest) (*V1DevicesDeviceIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdInterfacesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdInterfacesGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdInterfacesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdInterfacesGetRequest) Execute() (*V1DevicesDeviceIdInterfacesGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdInterfacesGetExecute(r)
}

/*
V1DevicesDeviceIdInterfacesGet Method for V1DevicesDeviceIdInterfacesGet

Get interfaces for the given device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdInterfacesGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdInterfacesGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdInterfacesGetRequest {
	return ApiV1DevicesDeviceIdInterfacesGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdInterfacesGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdInterfacesGetExecute(r ApiV1DevicesDeviceIdInterfacesGetRequest) (*V1DevicesDeviceIdInterfacesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdInterfacesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdInterfacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdJobsJobIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	jobId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdJobsJobIdGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdJobsJobIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdJobsJobIdGetRequest) Execute() (*V1DevicesDeviceIdJobsJobIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdJobsJobIdGetExecute(r)
}

/*
V1DevicesDeviceIdJobsJobIdGet Method for V1DevicesDeviceIdJobsJobIdGet

Get device job status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @param jobId id of the job as received from the Enqueue* calls.
 @return ApiV1DevicesDeviceIdJobsJobIdGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdJobsJobIdGet(ctx context.Context, deviceId int64, jobId int64) ApiV1DevicesDeviceIdJobsJobIdGetRequest {
	return ApiV1DevicesDeviceIdJobsJobIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdJobsJobIdGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdJobsJobIdGetExecute(r ApiV1DevicesDeviceIdJobsJobIdGetRequest) (*V1DevicesDeviceIdJobsJobIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdJobsJobIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdJobsJobIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdNdcacheGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdNdcacheGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdNdcacheGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdNdcacheGetRequest) Execute() (*V1DevicesDeviceIdNdcacheGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdNdcacheGetExecute(r)
}

/*
V1DevicesDeviceIdNdcacheGet Method for V1DevicesDeviceIdNdcacheGet

Get ND ipv6 Cache for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdNdcacheGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdNdcacheGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdNdcacheGetRequest {
	return ApiV1DevicesDeviceIdNdcacheGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdNdcacheGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdNdcacheGetExecute(r ApiV1DevicesDeviceIdNdcacheGetRequest) (*V1DevicesDeviceIdNdcacheGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdNdcacheGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdNdcacheGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/ndcache"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest) Execute() (*V1DevicesDeviceIdOspfv2DefaultOriginateGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdOspfv2DefaultOriginateGetExecute(r)
}

/*
V1DevicesDeviceIdOspfv2DefaultOriginateGet Method for V1DevicesDeviceIdOspfv2DefaultOriginateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv2DefaultOriginateGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest {
	return ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdOspfv2DefaultOriginateGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv2DefaultOriginateGetExecute(r ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest) (*V1DevicesDeviceIdOspfv2DefaultOriginateGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdOspfv2DefaultOriginateGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdOspfv2DefaultOriginateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/ospfv2/defaultOriginate"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest) Execute() (*V1DevicesDeviceIdOspfv3DefaultOriginateGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdOspfv3DefaultOriginateGetExecute(r)
}

/*
V1DevicesDeviceIdOspfv3DefaultOriginateGet Method for V1DevicesDeviceIdOspfv3DefaultOriginateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv3DefaultOriginateGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest {
	return ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdOspfv3DefaultOriginateGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv3DefaultOriginateGetExecute(r ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest) (*V1DevicesDeviceIdOspfv3DefaultOriginateGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdOspfv3DefaultOriginateGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdOspfv3DefaultOriginateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/ospfv3/defaultOriginate"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdPolicyApplicationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdPolicyApplicationsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdPolicyApplicationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdPolicyApplicationsGetRequest) Execute() (*V1DevicesDeviceIdPolicyApplicationsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdPolicyApplicationsGetExecute(r)
}

/*
V1DevicesDeviceIdPolicyApplicationsGet Method for V1DevicesDeviceIdPolicyApplicationsGet

Get a list of builtin DPI applications able to be configured on a given device based on GNOS version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdPolicyApplicationsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyApplicationsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdPolicyApplicationsGetRequest {
	return ApiV1DevicesDeviceIdPolicyApplicationsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdPolicyApplicationsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyApplicationsGetExecute(r ApiV1DevicesDeviceIdPolicyApplicationsGetRequest) (*V1DevicesDeviceIdPolicyApplicationsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdPolicyApplicationsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdPolicyApplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/policy/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest) Execute() (*V1DevicesDeviceIdPolicyCustomapplicationsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdPolicyCustomapplicationsGetExecute(r)
}

/*
V1DevicesDeviceIdPolicyCustomapplicationsGet Method for V1DevicesDeviceIdPolicyCustomapplicationsGet

Get a list of custom DPI applications able to be configured on a given device based on GNOS version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyCustomapplicationsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest {
	return ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdPolicyCustomapplicationsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyCustomapplicationsGetExecute(r ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest) (*V1DevicesDeviceIdPolicyCustomapplicationsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdPolicyCustomapplicationsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdPolicyCustomapplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/policy/customapplications"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdPolicyZonepairsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdPolicyZonepairsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdPolicyZonepairsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdPolicyZonepairsGetRequest) Execute() (*V1DevicesDeviceIdPolicyZonepairsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdPolicyZonepairsGetExecute(r)
}

/*
V1DevicesDeviceIdPolicyZonepairsGet Method for V1DevicesDeviceIdPolicyZonepairsGet

Get a list of firewall zone pairs each with holding nested policy rule sets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdPolicyZonepairsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyZonepairsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdPolicyZonepairsGetRequest {
	return ApiV1DevicesDeviceIdPolicyZonepairsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdPolicyZonepairsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyZonepairsGetExecute(r ApiV1DevicesDeviceIdPolicyZonepairsGetRequest) (*V1DevicesDeviceIdPolicyZonepairsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdPolicyZonepairsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdPolicyZonepairsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/policy/zonepairs"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdSlicePeersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdSlicePeersGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdSlicePeersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdSlicePeersGetRequest) Execute() (*V1DevicesDeviceIdSlicePeersGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdSlicePeersGetExecute(r)
}

/*
V1DevicesDeviceIdSlicePeersGet Method for V1DevicesDeviceIdSlicePeersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdSlicePeersGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdSlicePeersGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdSlicePeersGetRequest {
	return ApiV1DevicesDeviceIdSlicePeersGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdSlicePeersGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdSlicePeersGetExecute(r ApiV1DevicesDeviceIdSlicePeersGetRequest) (*V1DevicesDeviceIdSlicePeersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdSlicePeersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdSlicePeersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/slice/peers"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdTwampCoreGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdTwampCoreGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdTwampCoreGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdTwampCoreGetRequest) Execute() (*V1DevicesDeviceIdTwampCoreGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdTwampCoreGetExecute(r)
}

/*
V1DevicesDeviceIdTwampCoreGet Method for V1DevicesDeviceIdTwampCoreGet

Get core TWAMP neighbors for a given device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdTwampCoreGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdTwampCoreGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdTwampCoreGetRequest {
	return ApiV1DevicesDeviceIdTwampCoreGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdTwampCoreGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdTwampCoreGetExecute(r ApiV1DevicesDeviceIdTwampCoreGetRequest) (*V1DevicesDeviceIdTwampCoreGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdTwampCoreGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdTwampCoreGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/twamp/core"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVersionsCompareGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVersionsCompareGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVersionsCompareGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVersionsCompareGetRequest) Execute() (*V1DevicesDeviceIdVersionsCompareGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVersionsCompareGetExecute(r)
}

/*
V1DevicesDeviceIdVersionsCompareGet Method for V1DevicesDeviceIdVersionsCompareGet

Compare device config versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 16 bytes (base64 encoded) identifier for the device.
 @return ApiV1DevicesDeviceIdVersionsCompareGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsCompareGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVersionsCompareGetRequest {
	return ApiV1DevicesDeviceIdVersionsCompareGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVersionsCompareGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsCompareGetExecute(r ApiV1DevicesDeviceIdVersionsCompareGetRequest) (*V1DevicesDeviceIdVersionsCompareGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVersionsCompareGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVersionsCompareGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/versions/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVersionsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVersionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVersionsGetRequest) Execute() (*V1DevicesDeviceIdVersionsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVersionsGetExecute(r)
}

/*
V1DevicesDeviceIdVersionsGet Method for V1DevicesDeviceIdVersionsGet

Get device config versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 16 bytes (base64 encoded) identifier for the device.
 @return ApiV1DevicesDeviceIdVersionsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVersionsGetRequest {
	return ApiV1DevicesDeviceIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVersionsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsGetExecute(r ApiV1DevicesDeviceIdVersionsGetRequest) (*V1DevicesDeviceIdVersionsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVersionsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVersionsVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	version int32
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVersionsVersionGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVersionsVersionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVersionsVersionGetRequest) Execute() (*V1DevicesDeviceIdVersionsVersionGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVersionsVersionGetExecute(r)
}

/*
V1DevicesDeviceIdVersionsVersionGet Method for V1DevicesDeviceIdVersionsVersionGet

Get device config for a specific version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 16 bytes (base64 encoded) identifier for the device.
 @param version 8 bytes (base32 encoded) version number.
 @return ApiV1DevicesDeviceIdVersionsVersionGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsVersionGet(ctx context.Context, deviceId int64, version int32) ApiV1DevicesDeviceIdVersionsVersionGetRequest {
	return ApiV1DevicesDeviceIdVersionsVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		version: version,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVersionsVersionGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsVersionGetExecute(r ApiV1DevicesDeviceIdVersionsVersionGetRequest) (*V1DevicesDeviceIdVersionsVersionGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVersionsVersionGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVersionsVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.version < 0 {
		return localVarReturnValue, nil, reportError("version must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVrfBgpAsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVrfBgpAsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVrfBgpAsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVrfBgpAsGetRequest) Execute() (*V1DevicesDeviceIdVrfBgpAsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVrfBgpAsGetExecute(r)
}

/*
V1DevicesDeviceIdVrfBgpAsGet Method for V1DevicesDeviceIdVrfBgpAsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdVrfBgpAsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVrfBgpAsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVrfBgpAsGetRequest {
	return ApiV1DevicesDeviceIdVrfBgpAsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVrfBgpAsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdVrfBgpAsGetExecute(r ApiV1DevicesDeviceIdVrfBgpAsGetRequest) (*V1DevicesDeviceIdVrfBgpAsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVrfBgpAsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVrfBgpAsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/vrf/bgp/as"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVrfProtocolsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVrfProtocolsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVrfProtocolsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVrfProtocolsGetRequest) Execute() (*V1DevicesDeviceIdVrfProtocolsGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVrfProtocolsGetExecute(r)
}

/*
V1DevicesDeviceIdVrfProtocolsGet Method for V1DevicesDeviceIdVrfProtocolsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdVrfProtocolsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVrfProtocolsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVrfProtocolsGetRequest {
	return ApiV1DevicesDeviceIdVrfProtocolsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVrfProtocolsGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdVrfProtocolsGetExecute(r ApiV1DevicesDeviceIdVrfProtocolsGetRequest) (*V1DevicesDeviceIdVrfProtocolsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVrfProtocolsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVrfProtocolsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/vrf/protocols"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVrrpGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVrrpGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVrrpGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVrrpGetRequest) Execute() (*V1DevicesDeviceIdVrrpGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVrrpGetExecute(r)
}

/*
V1DevicesDeviceIdVrrpGet Method for V1DevicesDeviceIdVrrpGet

Get VRRP monitoring table for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdVrrpGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVrrpGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVrrpGetRequest {
	return ApiV1DevicesDeviceIdVrrpGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVrrpGetResponse
func (a *DefaultAPIService) V1DevicesDeviceIdVrrpGetExecute(r ApiV1DevicesDeviceIdVrrpGetRequest) (*V1DevicesDeviceIdVrrpGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVrrpGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVrrpGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/vrrp"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesGetRequest) Authorization(authorization string) ApiV1DevicesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesGetRequest) Execute() (*V1DevicesGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesGetExecute(r)
}

/*
V1DevicesGet Method for V1DevicesGet

Get devices for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesGetRequest
*/
func (a *DefaultAPIService) V1DevicesGet(ctx context.Context) ApiV1DevicesGetRequest {
	return ApiV1DevicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesGetResponse
func (a *DefaultAPIService) V1DevicesGetExecute(r ApiV1DevicesGetRequest) (*V1DevicesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryApproveReturnPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryApproveReturnPostRequest *V1DevicesInventoryApproveReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryApproveReturnPostRequest) Authorization(authorization string) ApiV1DevicesInventoryApproveReturnPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryApproveReturnPostRequest) V1DevicesInventoryApproveReturnPostRequest(v1DevicesInventoryApproveReturnPostRequest V1DevicesInventoryApproveReturnPostRequest) ApiV1DevicesInventoryApproveReturnPostRequest {
	r.v1DevicesInventoryApproveReturnPostRequest = &v1DevicesInventoryApproveReturnPostRequest
	return r
}

func (r ApiV1DevicesInventoryApproveReturnPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryApproveReturnPostExecute(r)
}

/*
V1DevicesInventoryApproveReturnPost Method for V1DevicesInventoryApproveReturnPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryApproveReturnPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryApproveReturnPost(ctx context.Context) ApiV1DevicesInventoryApproveReturnPostRequest {
	return ApiV1DevicesInventoryApproveReturnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryApproveReturnPostExecute(r ApiV1DevicesInventoryApproveReturnPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryApproveReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/approve-return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryApproveReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryApproveReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryApproveReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryClearNewFlagPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryClearNewFlagPostRequest) Authorization(authorization string) ApiV1DevicesInventoryClearNewFlagPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryClearNewFlagPostRequest) Body(body map[string]interface{}) ApiV1DevicesInventoryClearNewFlagPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DevicesInventoryClearNewFlagPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryClearNewFlagPostExecute(r)
}

/*
V1DevicesInventoryClearNewFlagPost Method for V1DevicesInventoryClearNewFlagPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryClearNewFlagPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryClearNewFlagPost(ctx context.Context) ApiV1DevicesInventoryClearNewFlagPostRequest {
	return ApiV1DevicesInventoryClearNewFlagPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryClearNewFlagPostExecute(r ApiV1DevicesInventoryClearNewFlagPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryClearNewFlagPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/clear-new-flag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryClearReturnPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryClearReturnPostRequest *V1DevicesInventoryClearReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryClearReturnPostRequest) Authorization(authorization string) ApiV1DevicesInventoryClearReturnPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryClearReturnPostRequest) V1DevicesInventoryClearReturnPostRequest(v1DevicesInventoryClearReturnPostRequest V1DevicesInventoryClearReturnPostRequest) ApiV1DevicesInventoryClearReturnPostRequest {
	r.v1DevicesInventoryClearReturnPostRequest = &v1DevicesInventoryClearReturnPostRequest
	return r
}

func (r ApiV1DevicesInventoryClearReturnPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryClearReturnPostExecute(r)
}

/*
V1DevicesInventoryClearReturnPost Method for V1DevicesInventoryClearReturnPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryClearReturnPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryClearReturnPost(ctx context.Context) ApiV1DevicesInventoryClearReturnPostRequest {
	return ApiV1DevicesInventoryClearReturnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryClearReturnPostExecute(r ApiV1DevicesInventoryClearReturnPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryClearReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/clear-return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryClearReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryClearReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryClearReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryEnterprisePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryEnterprisePutRequest *V1DevicesInventoryEnterprisePutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryEnterprisePutRequest) Authorization(authorization string) ApiV1DevicesInventoryEnterprisePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryEnterprisePutRequest) V1DevicesInventoryEnterprisePutRequest(v1DevicesInventoryEnterprisePutRequest V1DevicesInventoryEnterprisePutRequest) ApiV1DevicesInventoryEnterprisePutRequest {
	r.v1DevicesInventoryEnterprisePutRequest = &v1DevicesInventoryEnterprisePutRequest
	return r
}

func (r ApiV1DevicesInventoryEnterprisePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesInventoryEnterprisePutExecute(r)
}

/*
V1DevicesInventoryEnterprisePut Method for V1DevicesInventoryEnterprisePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryEnterprisePutRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryEnterprisePut(ctx context.Context) ApiV1DevicesInventoryEnterprisePutRequest {
	return ApiV1DevicesInventoryEnterprisePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesInventoryEnterprisePutExecute(r ApiV1DevicesInventoryEnterprisePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryEnterprisePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryEnterprisePutRequest == nil {
		return nil, reportError("v1DevicesInventoryEnterprisePutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryEnterprisePutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryGetRequest) Authorization(authorization string) ApiV1DevicesInventoryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryGetRequest) Execute() (*V1DevicesInventoryGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryGetExecute(r)
}

/*
V1DevicesInventoryGet Method for V1DevicesInventoryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryGetRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryGet(ctx context.Context) ApiV1DevicesInventoryGetRequest {
	return ApiV1DevicesInventoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesInventoryGetResponse
func (a *DefaultAPIService) V1DevicesInventoryGetExecute(r ApiV1DevicesInventoryGetRequest) (*V1DevicesInventoryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesInventoryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryPostRequest *V1DevicesInventoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryPostRequest) Authorization(authorization string) ApiV1DevicesInventoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryPostRequest) V1DevicesInventoryPostRequest(v1DevicesInventoryPostRequest V1DevicesInventoryPostRequest) ApiV1DevicesInventoryPostRequest {
	r.v1DevicesInventoryPostRequest = &v1DevicesInventoryPostRequest
	return r
}

func (r ApiV1DevicesInventoryPostRequest) Execute() (*V1DevicesInventoryPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryPostExecute(r)
}

/*
V1DevicesInventoryPost Method for V1DevicesInventoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryPost(ctx context.Context) ApiV1DevicesInventoryPostRequest {
	return ApiV1DevicesInventoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesInventoryPostResponse
func (a *DefaultAPIService) V1DevicesInventoryPostExecute(r ApiV1DevicesInventoryPostRequest) (*V1DevicesInventoryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesInventoryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryRequestReturnPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryRequestReturnPostRequest *V1DevicesInventoryRequestReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryRequestReturnPostRequest) Authorization(authorization string) ApiV1DevicesInventoryRequestReturnPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryRequestReturnPostRequest) V1DevicesInventoryRequestReturnPostRequest(v1DevicesInventoryRequestReturnPostRequest V1DevicesInventoryRequestReturnPostRequest) ApiV1DevicesInventoryRequestReturnPostRequest {
	r.v1DevicesInventoryRequestReturnPostRequest = &v1DevicesInventoryRequestReturnPostRequest
	return r
}

func (r ApiV1DevicesInventoryRequestReturnPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryRequestReturnPostExecute(r)
}

/*
V1DevicesInventoryRequestReturnPost Method for V1DevicesInventoryRequestReturnPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryRequestReturnPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryRequestReturnPost(ctx context.Context) ApiV1DevicesInventoryRequestReturnPostRequest {
	return ApiV1DevicesInventoryRequestReturnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryRequestReturnPostExecute(r ApiV1DevicesInventoryRequestReturnPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryRequestReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/request-return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryRequestReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryRequestReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryRequestReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventorySerialNumDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceSerials *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventorySerialNumDeleteRequest) Authorization(authorization string) ApiV1DevicesInventorySerialNumDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1DevicesInventorySerialNumDeleteRequest) DeviceSerials(deviceSerials []string) ApiV1DevicesInventorySerialNumDeleteRequest {
	r.deviceSerials = &deviceSerials
	return r
}

func (r ApiV1DevicesInventorySerialNumDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesInventorySerialNumDeleteExecute(r)
}

/*
V1DevicesInventorySerialNumDelete Method for V1DevicesInventorySerialNumDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventorySerialNumDeleteRequest
*/
func (a *DefaultAPIService) V1DevicesInventorySerialNumDelete(ctx context.Context) ApiV1DevicesInventorySerialNumDeleteRequest {
	return ApiV1DevicesInventorySerialNumDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesInventorySerialNumDeleteExecute(r ApiV1DevicesInventorySerialNumDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventorySerialNumDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/serial-num"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.deviceSerials != nil {
		t := *r.deviceSerials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceSerials", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceSerials", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DevicesInventorySerialNumPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventorySerialNumPostRequest *V1DevicesInventorySerialNumPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventorySerialNumPostRequest) Authorization(authorization string) ApiV1DevicesInventorySerialNumPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventorySerialNumPostRequest) V1DevicesInventorySerialNumPostRequest(v1DevicesInventorySerialNumPostRequest V1DevicesInventorySerialNumPostRequest) ApiV1DevicesInventorySerialNumPostRequest {
	r.v1DevicesInventorySerialNumPostRequest = &v1DevicesInventorySerialNumPostRequest
	return r
}

func (r ApiV1DevicesInventorySerialNumPostRequest) Execute() (*V1DevicesInventorySerialNumPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesInventorySerialNumPostExecute(r)
}

/*
V1DevicesInventorySerialNumPost Method for V1DevicesInventorySerialNumPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventorySerialNumPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventorySerialNumPost(ctx context.Context) ApiV1DevicesInventorySerialNumPostRequest {
	return ApiV1DevicesInventorySerialNumPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesInventorySerialNumPostResponse
func (a *DefaultAPIService) V1DevicesInventorySerialNumPostExecute(r ApiV1DevicesInventorySerialNumPostRequest) (*V1DevicesInventorySerialNumPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesInventorySerialNumPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventorySerialNumPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/serial-num"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventorySerialNumPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventorySerialNumPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventorySerialNumPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesOauthAuthorizationGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	relayState *string
}

// Base64 encoded relay state containing OAuth parameters
func (r ApiV1DevicesOauthAuthorizationGetRequest) RelayState(relayState string) ApiV1DevicesOauthAuthorizationGetRequest {
	r.relayState = &relayState
	return r
}

func (r ApiV1DevicesOauthAuthorizationGetRequest) Execute() (*V1DevicesOauthAuthorizationGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesOauthAuthorizationGetExecute(r)
}

/*
V1DevicesOauthAuthorizationGet Method for V1DevicesOauthAuthorizationGet

Process OAuth authorization for device onboarding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesOauthAuthorizationGetRequest
*/
func (a *DefaultAPIService) V1DevicesOauthAuthorizationGet(ctx context.Context) ApiV1DevicesOauthAuthorizationGetRequest {
	return ApiV1DevicesOauthAuthorizationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesOauthAuthorizationGetResponse
func (a *DefaultAPIService) V1DevicesOauthAuthorizationGetExecute(r ApiV1DevicesOauthAuthorizationGetRequest) (*V1DevicesOauthAuthorizationGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesOauthAuthorizationGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesOauthAuthorizationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/oauth/authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.relayState == nil {
		return localVarReturnValue, nil, reportError("relayState is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "relayState", r.relayState, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesOauthGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	scope *string
	state *string
	codeChallenge *string
	codeChallengeMethod *string
	pt *string
	bm *string
}

// OAuth scope containing device type, UUID, and hostname
func (r ApiV1DevicesOauthGetRequest) Scope(scope string) ApiV1DevicesOauthGetRequest {
	r.scope = &scope
	return r
}

// OAuth state parameter
func (r ApiV1DevicesOauthGetRequest) State(state string) ApiV1DevicesOauthGetRequest {
	r.state = &state
	return r
}

// PKCE code challenge
func (r ApiV1DevicesOauthGetRequest) CodeChallenge(codeChallenge string) ApiV1DevicesOauthGetRequest {
	r.codeChallenge = &codeChallenge
	return r
}

// PKCE code challenge method
func (r ApiV1DevicesOauthGetRequest) CodeChallengeMethod(codeChallengeMethod string) ApiV1DevicesOauthGetRequest {
	r.codeChallengeMethod = &codeChallengeMethod
	return r
}

// Platform type
func (r ApiV1DevicesOauthGetRequest) Pt(pt string) ApiV1DevicesOauthGetRequest {
	r.pt = &pt
	return r
}

// Boot mode
func (r ApiV1DevicesOauthGetRequest) Bm(bm string) ApiV1DevicesOauthGetRequest {
	r.bm = &bm
	return r
}

func (r ApiV1DevicesOauthGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesOauthGetExecute(r)
}

/*
V1DevicesOauthGet Method for V1DevicesOauthGet

Redirect to OAuth authorization page for device onboarding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesOauthGetRequest
*/
func (a *DefaultAPIService) V1DevicesOauthGet(ctx context.Context) ApiV1DevicesOauthGetRequest {
	return ApiV1DevicesOauthGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesOauthGetExecute(r ApiV1DevicesOauthGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesOauthGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/oauth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scope == nil {
		return nil, reportError("scope is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "")
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.codeChallenge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code_challenge", r.codeChallenge, "form", "")
	}
	if r.codeChallengeMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code_challenge_method", r.codeChallengeMethod, "form", "")
	}
	if r.pt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pt", r.pt, "form", "")
	}
	if r.bm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bm", r.bm, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DevicesOauthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1DevicesOauthPostRequest *V1DevicesOauthPostRequest
}

func (r ApiV1DevicesOauthPostRequest) V1DevicesOauthPostRequest(v1DevicesOauthPostRequest V1DevicesOauthPostRequest) ApiV1DevicesOauthPostRequest {
	r.v1DevicesOauthPostRequest = &v1DevicesOauthPostRequest
	return r
}

func (r ApiV1DevicesOauthPostRequest) Execute() (*V1DevicesOauthPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesOauthPostExecute(r)
}

/*
V1DevicesOauthPost Method for V1DevicesOauthPost

Process OAuth client credentials for device onboarding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesOauthPostRequest
*/
func (a *DefaultAPIService) V1DevicesOauthPost(ctx context.Context) ApiV1DevicesOauthPostRequest {
	return ApiV1DevicesOauthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesOauthPostResponse
func (a *DefaultAPIService) V1DevicesOauthPostExecute(r ApiV1DevicesOauthPostRequest) (*V1DevicesOauthPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesOauthPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesOauthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/oauth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1DevicesOauthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesOauthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1DevicesOauthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesOauthRedirectGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesOauthRedirectGetRequest) Authorization(authorization string) ApiV1DevicesOauthRedirectGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesOauthRedirectGetRequest) Execute() (*V1DevicesOauthRedirectGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesOauthRedirectGetExecute(r)
}

/*
V1DevicesOauthRedirectGet Method for V1DevicesOauthRedirectGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesOauthRedirectGetRequest
*/
func (a *DefaultAPIService) V1DevicesOauthRedirectGet(ctx context.Context) ApiV1DevicesOauthRedirectGetRequest {
	return ApiV1DevicesOauthRedirectGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesOauthRedirectGetResponse
func (a *DefaultAPIService) V1DevicesOauthRedirectGetExecute(r ApiV1DevicesOauthRedirectGetRequest) (*V1DevicesOauthRedirectGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesOauthRedirectGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesOauthRedirectGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "//v1/devices/oauth/redirect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesRmaPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesRmaPostRequest *V1DevicesRmaPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesRmaPostRequest) Authorization(authorization string) ApiV1DevicesRmaPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesRmaPostRequest) V1DevicesRmaPostRequest(v1DevicesRmaPostRequest V1DevicesRmaPostRequest) ApiV1DevicesRmaPostRequest {
	r.v1DevicesRmaPostRequest = &v1DevicesRmaPostRequest
	return r
}

func (r ApiV1DevicesRmaPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesRmaPostExecute(r)
}

/*
V1DevicesRmaPost Method for V1DevicesRmaPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesRmaPostRequest
*/
func (a *DefaultAPIService) V1DevicesRmaPost(ctx context.Context) ApiV1DevicesRmaPostRequest {
	return ApiV1DevicesRmaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesRmaPostExecute(r ApiV1DevicesRmaPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesRmaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/rma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesRmaPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesRmaPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesRmaPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	protocols *[]string
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) Authorization(authorization string) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) DeviceId(deviceId int64) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.deviceId = &deviceId
	return r
}

// List of protocols names for which route count is needed
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) Protocols(protocols []string) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.protocols = &protocols
	return r
}

// Valid configured VRF names
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) VrfName(vrfName string) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) Execute() (*V1DevicesRoutingVrfProtocolRouteCountGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesRoutingVrfProtocolRouteCountGetExecute(r)
}

/*
V1DevicesRoutingVrfProtocolRouteCountGet Method for V1DevicesRoutingVrfProtocolRouteCountGet

Get per VRF per protocol route count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest
*/
func (a *DefaultAPIService) V1DevicesRoutingVrfProtocolRouteCountGet(ctx context.Context) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	return ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesRoutingVrfProtocolRouteCountGetResponse
func (a *DefaultAPIService) V1DevicesRoutingVrfProtocolRouteCountGetExecute(r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) (*V1DevicesRoutingVrfProtocolRouteCountGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesRoutingVrfProtocolRouteCountGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesRoutingVrfProtocolRouteCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/routing/vrf/protocol-route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.protocols == nil {
		return localVarReturnValue, nil, reportError("protocols is required and must be specified")
	}
	if r.vrfName == nil {
		return localVarReturnValue, nil, reportError("vrfName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	{
		t := *r.protocols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocols", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocols", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesRunningVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesRunningVersionPostRequest *V1DevicesRunningVersionPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesRunningVersionPostRequest) Authorization(authorization string) ApiV1DevicesRunningVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesRunningVersionPostRequest) V1DevicesRunningVersionPostRequest(v1DevicesRunningVersionPostRequest V1DevicesRunningVersionPostRequest) ApiV1DevicesRunningVersionPostRequest {
	r.v1DevicesRunningVersionPostRequest = &v1DevicesRunningVersionPostRequest
	return r
}

func (r ApiV1DevicesRunningVersionPostRequest) Execute() (*V1DevicesRunningVersionPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesRunningVersionPostExecute(r)
}

/*
V1DevicesRunningVersionPost Method for V1DevicesRunningVersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesRunningVersionPostRequest
*/
func (a *DefaultAPIService) V1DevicesRunningVersionPost(ctx context.Context) ApiV1DevicesRunningVersionPostRequest {
	return ApiV1DevicesRunningVersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesRunningVersionPostResponse
func (a *DefaultAPIService) V1DevicesRunningVersionPostExecute(r ApiV1DevicesRunningVersionPostRequest) (*V1DevicesRunningVersionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesRunningVersionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesRunningVersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/running/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesRunningVersionPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesRunningVersionPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesRunningVersionPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesSessionStatusPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesSessionStatusPostRequest *V1DevicesSessionStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesSessionStatusPostRequest) Authorization(authorization string) ApiV1DevicesSessionStatusPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesSessionStatusPostRequest) V1DevicesSessionStatusPostRequest(v1DevicesSessionStatusPostRequest V1DevicesSessionStatusPostRequest) ApiV1DevicesSessionStatusPostRequest {
	r.v1DevicesSessionStatusPostRequest = &v1DevicesSessionStatusPostRequest
	return r
}

func (r ApiV1DevicesSessionStatusPostRequest) Execute() (*V1DevicesSessionStatusPostResponse, *http.Response, error) {
	return r.ApiService.V1DevicesSessionStatusPostExecute(r)
}

/*
V1DevicesSessionStatusPost Method for V1DevicesSessionStatusPost

Get all the BGP session states for the devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesSessionStatusPostRequest
*/
func (a *DefaultAPIService) V1DevicesSessionStatusPost(ctx context.Context) ApiV1DevicesSessionStatusPostRequest {
	return ApiV1DevicesSessionStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesSessionStatusPostResponse
func (a *DefaultAPIService) V1DevicesSessionStatusPostExecute(r ApiV1DevicesSessionStatusPostRequest) (*V1DevicesSessionStatusPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesSessionStatusPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesSessionStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/session-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesSessionStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesSessionStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesSessionStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesSummaryGetRequest) Authorization(authorization string) ApiV1DevicesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesSummaryGetRequest) Execute() (*V1DevicesSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1DevicesSummaryGetExecute(r)
}

/*
V1DevicesSummaryGet Method for V1DevicesSummaryGet

Get devices summary for the specified enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesSummaryGetRequest
*/
func (a *DefaultAPIService) V1DevicesSummaryGet(ctx context.Context) ApiV1DevicesSummaryGetRequest {
	return ApiV1DevicesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesSummaryGetResponse
func (a *DefaultAPIService) V1DevicesSummaryGetExecute(r ApiV1DevicesSummaryGetRequest) (*V1DevicesSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesUpgradeCancelPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesUpgradeCancelPutRequest *V1DevicesUpgradeCancelPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesUpgradeCancelPutRequest) Authorization(authorization string) ApiV1DevicesUpgradeCancelPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesUpgradeCancelPutRequest) V1DevicesUpgradeCancelPutRequest(v1DevicesUpgradeCancelPutRequest V1DevicesUpgradeCancelPutRequest) ApiV1DevicesUpgradeCancelPutRequest {
	r.v1DevicesUpgradeCancelPutRequest = &v1DevicesUpgradeCancelPutRequest
	return r
}

func (r ApiV1DevicesUpgradeCancelPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesUpgradeCancelPutExecute(r)
}

/*
V1DevicesUpgradeCancelPut Method for V1DevicesUpgradeCancelPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesUpgradeCancelPutRequest
*/
func (a *DefaultAPIService) V1DevicesUpgradeCancelPut(ctx context.Context) ApiV1DevicesUpgradeCancelPutRequest {
	return ApiV1DevicesUpgradeCancelPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesUpgradeCancelPutExecute(r ApiV1DevicesUpgradeCancelPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesUpgradeCancelPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/upgrade/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesUpgradeCancelPutRequest == nil {
		return nil, reportError("v1DevicesUpgradeCancelPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesUpgradeCancelPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DevicesUpgradeSchedulePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesUpgradeSchedulePutRequest *V1DevicesUpgradeSchedulePutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesUpgradeSchedulePutRequest) Authorization(authorization string) ApiV1DevicesUpgradeSchedulePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesUpgradeSchedulePutRequest) V1DevicesUpgradeSchedulePutRequest(v1DevicesUpgradeSchedulePutRequest V1DevicesUpgradeSchedulePutRequest) ApiV1DevicesUpgradeSchedulePutRequest {
	r.v1DevicesUpgradeSchedulePutRequest = &v1DevicesUpgradeSchedulePutRequest
	return r
}

func (r ApiV1DevicesUpgradeSchedulePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DevicesUpgradeSchedulePutExecute(r)
}

/*
V1DevicesUpgradeSchedulePut Method for V1DevicesUpgradeSchedulePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesUpgradeSchedulePutRequest
*/
func (a *DefaultAPIService) V1DevicesUpgradeSchedulePut(ctx context.Context) ApiV1DevicesUpgradeSchedulePutRequest {
	return ApiV1DevicesUpgradeSchedulePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DevicesUpgradeSchedulePutExecute(r ApiV1DevicesUpgradeSchedulePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesUpgradeSchedulePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/upgrade/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesUpgradeSchedulePutRequest == nil {
		return nil, reportError("v1DevicesUpgradeSchedulePutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesUpgradeSchedulePutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchiveCreateDeviceIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticArchiveCreateDeviceIdPostRequest *V1DiagnosticArchiveCreateDeviceIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) Authorization(authorization string) ApiV1DiagnosticArchiveCreateDeviceIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) V1DiagnosticArchiveCreateDeviceIdPostRequest(v1DiagnosticArchiveCreateDeviceIdPostRequest V1DiagnosticArchiveCreateDeviceIdPostRequest) ApiV1DiagnosticArchiveCreateDeviceIdPostRequest {
	r.v1DiagnosticArchiveCreateDeviceIdPostRequest = &v1DiagnosticArchiveCreateDeviceIdPostRequest
	return r
}

func (r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) Execute() (*V1DiagnosticArchiveCreateDeviceIdPostResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticArchiveCreateDeviceIdPostExecute(r)
}

/*
V1DiagnosticArchiveCreateDeviceIdPost Method for V1DiagnosticArchiveCreateDeviceIdPost

Create a device debug archive

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Valid Provisioned device ID
 @return ApiV1DiagnosticArchiveCreateDeviceIdPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchiveCreateDeviceIdPost(ctx context.Context, deviceId int64) ApiV1DiagnosticArchiveCreateDeviceIdPostRequest {
	return ApiV1DiagnosticArchiveCreateDeviceIdPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DiagnosticArchiveCreateDeviceIdPostResponse
func (a *DefaultAPIService) V1DiagnosticArchiveCreateDeviceIdPostExecute(r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) (*V1DiagnosticArchiveCreateDeviceIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticArchiveCreateDeviceIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchiveCreateDeviceIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archive-create/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticArchiveCreateDeviceIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticArchiveCreateDeviceIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticArchiveCreateDeviceIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	archiveId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest) Authorization(authorization string) ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticArchiveDeleteArchiveIdDeleteExecute(r)
}

/*
V1DiagnosticArchiveDeleteArchiveIdDelete Method for V1DiagnosticArchiveDeleteArchiveIdDelete

Delete a device debug archive

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param archiveId Unique identifier for a specific archive
 @return ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchiveDeleteArchiveIdDelete(ctx context.Context, archiveId int64) ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest {
	return ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		archiveId: archiveId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticArchiveDeleteArchiveIdDeleteExecute(r ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchiveDeleteArchiveIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archive-delete/{archiveId}"
	localVarPath = strings.Replace(localVarPath, "{"+"archiveId"+"}", url.PathEscape(parameterValueToString(r.archiveId, "archiveId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchiveEditArchiveIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	archiveId int64
	v1DiagnosticArchiveEditArchiveIdPutRequest *V1DiagnosticArchiveEditArchiveIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) Authorization(authorization string) ApiV1DiagnosticArchiveEditArchiveIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) V1DiagnosticArchiveEditArchiveIdPutRequest(v1DiagnosticArchiveEditArchiveIdPutRequest V1DiagnosticArchiveEditArchiveIdPutRequest) ApiV1DiagnosticArchiveEditArchiveIdPutRequest {
	r.v1DiagnosticArchiveEditArchiveIdPutRequest = &v1DiagnosticArchiveEditArchiveIdPutRequest
	return r
}

func (r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticArchiveEditArchiveIdPutExecute(r)
}

/*
V1DiagnosticArchiveEditArchiveIdPut Method for V1DiagnosticArchiveEditArchiveIdPut

Edit metadata for a previously generated device debug archive

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param archiveId Unique identifier for a specific archive
 @return ApiV1DiagnosticArchiveEditArchiveIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchiveEditArchiveIdPut(ctx context.Context, archiveId int64) ApiV1DiagnosticArchiveEditArchiveIdPutRequest {
	return ApiV1DiagnosticArchiveEditArchiveIdPutRequest{
		ApiService: a,
		ctx: ctx,
		archiveId: archiveId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticArchiveEditArchiveIdPutExecute(r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchiveEditArchiveIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archive-edit/{archiveId}"
	localVarPath = strings.Replace(localVarPath, "{"+"archiveId"+"}", url.PathEscape(parameterValueToString(r.archiveId, "archiveId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticArchiveEditArchiveIdPutRequest == nil {
		return nil, reportError("v1DiagnosticArchiveEditArchiveIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticArchiveEditArchiveIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchivesDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchivesDeviceIdGetRequest) Authorization(authorization string) ApiV1DiagnosticArchivesDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchivesDeviceIdGetRequest) Execute() (*V1DiagnosticArchivesDeviceIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticArchivesDeviceIdGetExecute(r)
}

/*
V1DiagnosticArchivesDeviceIdGet Method for V1DiagnosticArchivesDeviceIdGet

Get a list of device debug archive collections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Valid Provisioned device ID
 @return ApiV1DiagnosticArchivesDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchivesDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DiagnosticArchivesDeviceIdGetRequest {
	return ApiV1DiagnosticArchivesDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DiagnosticArchivesDeviceIdGetResponse
func (a *DefaultAPIService) V1DiagnosticArchivesDeviceIdGetExecute(r ApiV1DiagnosticArchivesDeviceIdGetRequest) (*V1DiagnosticArchivesDeviceIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticArchivesDeviceIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchivesDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archives/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticBgpResetDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticBgpResetDeviceIdPutRequest *V1DiagnosticBgpResetDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticBgpResetDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticBgpResetDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticBgpResetDeviceIdPutRequest) V1DiagnosticBgpResetDeviceIdPutRequest(v1DiagnosticBgpResetDeviceIdPutRequest V1DiagnosticBgpResetDeviceIdPutRequest) ApiV1DiagnosticBgpResetDeviceIdPutRequest {
	r.v1DiagnosticBgpResetDeviceIdPutRequest = &v1DiagnosticBgpResetDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticBgpResetDeviceIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticBgpResetDeviceIdPutExecute(r)
}

/*
V1DiagnosticBgpResetDeviceIdPut Method for V1DiagnosticBgpResetDeviceIdPut

Reset a BGP neighbor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticBgpResetDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticBgpResetDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticBgpResetDeviceIdPutRequest {
	return ApiV1DiagnosticBgpResetDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticBgpResetDeviceIdPutExecute(r ApiV1DiagnosticBgpResetDeviceIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticBgpResetDeviceIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/bgp-reset/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticBgpResetDeviceIdPutRequest == nil {
		return nil, reportError("v1DiagnosticBgpResetDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticBgpResetDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticClearArpDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticClearArpDeviceIdPutRequest *V1DiagnosticClearArpDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticClearArpDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticClearArpDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticClearArpDeviceIdPutRequest) V1DiagnosticClearArpDeviceIdPutRequest(v1DiagnosticClearArpDeviceIdPutRequest V1DiagnosticClearArpDeviceIdPutRequest) ApiV1DiagnosticClearArpDeviceIdPutRequest {
	r.v1DiagnosticClearArpDeviceIdPutRequest = &v1DiagnosticClearArpDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticClearArpDeviceIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticClearArpDeviceIdPutExecute(r)
}

/*
V1DiagnosticClearArpDeviceIdPut Method for V1DiagnosticClearArpDeviceIdPut

Clear arp entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticClearArpDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticClearArpDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticClearArpDeviceIdPutRequest {
	return ApiV1DiagnosticClearArpDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticClearArpDeviceIdPutExecute(r ApiV1DiagnosticClearArpDeviceIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticClearArpDeviceIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/clear-arp/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticClearArpDeviceIdPutRequest == nil {
		return nil, reportError("v1DiagnosticClearArpDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticClearArpDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticGnmiPingGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticGnmiPingGetRequest) Authorization(authorization string) ApiV1DiagnosticGnmiPingGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticGnmiPingGetRequest) Execute() (*V1DiagnosticGnmiPingGetResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticGnmiPingGetExecute(r)
}

/*
V1DiagnosticGnmiPingGet Method for V1DiagnosticGnmiPingGet

perform GNMI ping test

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticGnmiPingGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticGnmiPingGet(ctx context.Context) ApiV1DiagnosticGnmiPingGetRequest {
	return ApiV1DiagnosticGnmiPingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticGnmiPingGetResponse
func (a *DefaultAPIService) V1DiagnosticGnmiPingGetExecute(r ApiV1DiagnosticGnmiPingGetRequest) (*V1DiagnosticGnmiPingGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticGnmiPingGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticGnmiPingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/gnmi-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticInterfaceResetDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticInterfaceResetDeviceIdPutRequest *V1DiagnosticInterfaceResetDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticInterfaceResetDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) V1DiagnosticInterfaceResetDeviceIdPutRequest(v1DiagnosticInterfaceResetDeviceIdPutRequest V1DiagnosticInterfaceResetDeviceIdPutRequest) ApiV1DiagnosticInterfaceResetDeviceIdPutRequest {
	r.v1DiagnosticInterfaceResetDeviceIdPutRequest = &v1DiagnosticInterfaceResetDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticInterfaceResetDeviceIdPutExecute(r)
}

/*
V1DiagnosticInterfaceResetDeviceIdPut Method for V1DiagnosticInterfaceResetDeviceIdPut

Reset an interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticInterfaceResetDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticInterfaceResetDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticInterfaceResetDeviceIdPutRequest {
	return ApiV1DiagnosticInterfaceResetDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticInterfaceResetDeviceIdPutExecute(r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticInterfaceResetDeviceIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/interface-reset/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticInterfaceResetDeviceIdPutRequest == nil {
		return nil, reportError("v1DiagnosticInterfaceResetDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticInterfaceResetDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticOtpDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticOtpDeviceIdGetRequest) Authorization(authorization string) ApiV1DiagnosticOtpDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticOtpDeviceIdGetRequest) Execute() (*V1DiagnosticOtpDeviceIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticOtpDeviceIdGetExecute(r)
}

/*
V1DiagnosticOtpDeviceIdGet Method for V1DiagnosticOtpDeviceIdGet

Get a one-time passcode to access a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticOtpDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticOtpDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DiagnosticOtpDeviceIdGetRequest {
	return ApiV1DiagnosticOtpDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DiagnosticOtpDeviceIdGetResponse
func (a *DefaultAPIService) V1DiagnosticOtpDeviceIdGetExecute(r ApiV1DiagnosticOtpDeviceIdGetRequest) (*V1DiagnosticOtpDeviceIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticOtpDeviceIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticOtpDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/otp/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPacketcapturePcapIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	pcapId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPacketcapturePcapIdGetRequest) Authorization(authorization string) ApiV1DiagnosticPacketcapturePcapIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPacketcapturePcapIdGetRequest) Execute() (*V1DiagnosticPacketcapturePcapIdGetResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticPacketcapturePcapIdGetExecute(r)
}

/*
V1DiagnosticPacketcapturePcapIdGet Method for V1DiagnosticPacketcapturePcapIdGet

get a packet capture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pcapId Unique identifier for a specific packet capture
 @return ApiV1DiagnosticPacketcapturePcapIdGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticPacketcapturePcapIdGet(ctx context.Context, pcapId int64) ApiV1DiagnosticPacketcapturePcapIdGetRequest {
	return ApiV1DiagnosticPacketcapturePcapIdGetRequest{
		ApiService: a,
		ctx: ctx,
		pcapId: pcapId,
	}
}

// Execute executes the request
//  @return V1DiagnosticPacketcapturePcapIdGetResponse
func (a *DefaultAPIService) V1DiagnosticPacketcapturePcapIdGetExecute(r ApiV1DiagnosticPacketcapturePcapIdGetRequest) (*V1DiagnosticPacketcapturePcapIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPacketcapturePcapIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPacketcapturePcapIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/packetcapture/{pcapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pcapId"+"}", url.PathEscape(parameterValueToString(r.pcapId, "pcapId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPacketcaptureStartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPacketcaptureStartPostRequest *V1DiagnosticPacketcaptureStartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPacketcaptureStartPostRequest) Authorization(authorization string) ApiV1DiagnosticPacketcaptureStartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPacketcaptureStartPostRequest) V1DiagnosticPacketcaptureStartPostRequest(v1DiagnosticPacketcaptureStartPostRequest V1DiagnosticPacketcaptureStartPostRequest) ApiV1DiagnosticPacketcaptureStartPostRequest {
	r.v1DiagnosticPacketcaptureStartPostRequest = &v1DiagnosticPacketcaptureStartPostRequest
	return r
}

func (r ApiV1DiagnosticPacketcaptureStartPostRequest) Execute() (*V1DiagnosticPacketcaptureStartPostResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticPacketcaptureStartPostExecute(r)
}

/*
V1DiagnosticPacketcaptureStartPost Method for V1DiagnosticPacketcaptureStartPost

Start packet capture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPacketcaptureStartPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStartPost(ctx context.Context) ApiV1DiagnosticPacketcaptureStartPostRequest {
	return ApiV1DiagnosticPacketcaptureStartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticPacketcaptureStartPostResponse
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStartPostExecute(r ApiV1DiagnosticPacketcaptureStartPostRequest) (*V1DiagnosticPacketcaptureStartPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPacketcaptureStartPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPacketcaptureStartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/packetcapture-start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPacketcaptureStartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPacketcaptureStartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPacketcaptureStartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPacketcaptureStopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPacketcaptureStopPostRequest *V1DiagnosticPacketcaptureStopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPacketcaptureStopPostRequest) Authorization(authorization string) ApiV1DiagnosticPacketcaptureStopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPacketcaptureStopPostRequest) V1DiagnosticPacketcaptureStopPostRequest(v1DiagnosticPacketcaptureStopPostRequest V1DiagnosticPacketcaptureStopPostRequest) ApiV1DiagnosticPacketcaptureStopPostRequest {
	r.v1DiagnosticPacketcaptureStopPostRequest = &v1DiagnosticPacketcaptureStopPostRequest
	return r
}

func (r ApiV1DiagnosticPacketcaptureStopPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticPacketcaptureStopPostExecute(r)
}

/*
V1DiagnosticPacketcaptureStopPost Method for V1DiagnosticPacketcaptureStopPost

Stop packet capture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPacketcaptureStopPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStopPost(ctx context.Context) ApiV1DiagnosticPacketcaptureStopPostRequest {
	return ApiV1DiagnosticPacketcaptureStopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStopPostExecute(r ApiV1DiagnosticPacketcaptureStopPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPacketcaptureStopPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/packetcapture-stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPacketcaptureStopPostRequest == nil {
		return nil, reportError("v1DiagnosticPacketcaptureStopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPacketcaptureStopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticPingPauseResumePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPingPauseResumePostRequest *V1DiagnosticPingPauseResumePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPingPauseResumePostRequest) Authorization(authorization string) ApiV1DiagnosticPingPauseResumePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPingPauseResumePostRequest) V1DiagnosticPingPauseResumePostRequest(v1DiagnosticPingPauseResumePostRequest V1DiagnosticPingPauseResumePostRequest) ApiV1DiagnosticPingPauseResumePostRequest {
	r.v1DiagnosticPingPauseResumePostRequest = &v1DiagnosticPingPauseResumePostRequest
	return r
}

func (r ApiV1DiagnosticPingPauseResumePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticPingPauseResumePostExecute(r)
}

/*
V1DiagnosticPingPauseResumePost Method for V1DiagnosticPingPauseResumePost

Pause and/or Resume a ping session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPingPauseResumePostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPingPauseResumePost(ctx context.Context) ApiV1DiagnosticPingPauseResumePostRequest {
	return ApiV1DiagnosticPingPauseResumePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticPingPauseResumePostExecute(r ApiV1DiagnosticPingPauseResumePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPingPauseResumePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/ping-pause-resume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPingPauseResumePostRequest == nil {
		return nil, reportError("v1DiagnosticPingPauseResumePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPingPauseResumePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticPingPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPingPostRequest *V1DiagnosticPingPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPingPostRequest) Authorization(authorization string) ApiV1DiagnosticPingPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPingPostRequest) V1DiagnosticPingPostRequest(v1DiagnosticPingPostRequest V1DiagnosticPingPostRequest) ApiV1DiagnosticPingPostRequest {
	r.v1DiagnosticPingPostRequest = &v1DiagnosticPingPostRequest
	return r
}

func (r ApiV1DiagnosticPingPostRequest) Execute() (*V1DiagnosticPingPostResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticPingPostExecute(r)
}

/*
V1DiagnosticPingPost Method for V1DiagnosticPingPost

Trigger a diagnostic test

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPingPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPingPost(ctx context.Context) ApiV1DiagnosticPingPostRequest {
	return ApiV1DiagnosticPingPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticPingPostResponse
func (a *DefaultAPIService) V1DiagnosticPingPostExecute(r ApiV1DiagnosticPingPostRequest) (*V1DiagnosticPingPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPingPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPingPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPingPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPingPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPingStopTokenPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	token string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPingStopTokenPostRequest) Authorization(authorization string) ApiV1DiagnosticPingStopTokenPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPingStopTokenPostRequest) Body(body map[string]interface{}) ApiV1DiagnosticPingStopTokenPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DiagnosticPingStopTokenPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticPingStopTokenPostExecute(r)
}

/*
V1DiagnosticPingStopTokenPost Method for V1DiagnosticPingStopTokenPost

Stop ping session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Identifier which was received in initial response
 @return ApiV1DiagnosticPingStopTokenPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPingStopTokenPost(ctx context.Context, token string) ApiV1DiagnosticPingStopTokenPostRequest {
	return ApiV1DiagnosticPingStopTokenPostRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticPingStopTokenPostExecute(r ApiV1DiagnosticPingStopTokenPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPingStopTokenPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/ping-stop/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticRebootDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticRebootDeviceIdPutRequest *V1DiagnosticRebootDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticRebootDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticRebootDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticRebootDeviceIdPutRequest) V1DiagnosticRebootDeviceIdPutRequest(v1DiagnosticRebootDeviceIdPutRequest V1DiagnosticRebootDeviceIdPutRequest) ApiV1DiagnosticRebootDeviceIdPutRequest {
	r.v1DiagnosticRebootDeviceIdPutRequest = &v1DiagnosticRebootDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticRebootDeviceIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticRebootDeviceIdPutExecute(r)
}

/*
V1DiagnosticRebootDeviceIdPut Method for V1DiagnosticRebootDeviceIdPut

Trigger a device reboot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Valid Provisioned device ID
 @return ApiV1DiagnosticRebootDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticRebootDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticRebootDeviceIdPutRequest {
	return ApiV1DiagnosticRebootDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticRebootDeviceIdPutExecute(r ApiV1DiagnosticRebootDeviceIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticRebootDeviceIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/reboot/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId < 0 {
		return nil, reportError("deviceId must be greater than 0")
	}
	if r.v1DiagnosticRebootDeviceIdPutRequest == nil {
		return nil, reportError("v1DiagnosticRebootDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticRebootDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticResetIpsecSessionDeviceIdPutRequest *V1DiagnosticResetIpsecSessionDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) V1DiagnosticResetIpsecSessionDeviceIdPutRequest(v1DiagnosticResetIpsecSessionDeviceIdPutRequest V1DiagnosticResetIpsecSessionDeviceIdPutRequest) ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest {
	r.v1DiagnosticResetIpsecSessionDeviceIdPutRequest = &v1DiagnosticResetIpsecSessionDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1DiagnosticResetIpsecSessionDeviceIdPutExecute(r)
}

/*
V1DiagnosticResetIpsecSessionDeviceIdPut Method for V1DiagnosticResetIpsecSessionDeviceIdPut

Reset IPSec sessions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticResetIpsecSessionDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest {
	return ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1DiagnosticResetIpsecSessionDeviceIdPutExecute(r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticResetIpsecSessionDeviceIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/reset-ipsec-session/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticResetIpsecSessionDeviceIdPutRequest == nil {
		return nil, reportError("v1DiagnosticResetIpsecSessionDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticResetIpsecSessionDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticSpeedtestPostRequest *V1DiagnosticSpeedtestPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestPostRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestPostRequest) V1DiagnosticSpeedtestPostRequest(v1DiagnosticSpeedtestPostRequest V1DiagnosticSpeedtestPostRequest) ApiV1DiagnosticSpeedtestPostRequest {
	r.v1DiagnosticSpeedtestPostRequest = &v1DiagnosticSpeedtestPostRequest
	return r
}

func (r ApiV1DiagnosticSpeedtestPostRequest) Execute() (*V1DiagnosticSpeedtestPostResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestPostExecute(r)
}

/*
V1DiagnosticSpeedtestPost Method for V1DiagnosticSpeedtestPost

Trigger Speedtest utility

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestPost(ctx context.Context) ApiV1DiagnosticSpeedtestPostRequest {
	return ApiV1DiagnosticSpeedtestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestPostResponse
func (a *DefaultAPIService) V1DiagnosticSpeedtestPostExecute(r ApiV1DiagnosticSpeedtestPostRequest) (*V1DiagnosticSpeedtestPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticSpeedtestPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticSpeedtestPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticSpeedtestPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestProvidersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestProvidersGetRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestProvidersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestProvidersGetRequest) Execute() (*V1DiagnosticSpeedtestProvidersGetResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestProvidersGetExecute(r)
}

/*
V1DiagnosticSpeedtestProvidersGet Method for V1DiagnosticSpeedtestProvidersGet

Get list of supported speedtest service providers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestProvidersGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestProvidersGet(ctx context.Context) ApiV1DiagnosticSpeedtestProvidersGetRequest {
	return ApiV1DiagnosticSpeedtestProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestProvidersGetResponse
func (a *DefaultAPIService) V1DiagnosticSpeedtestProvidersGetExecute(r ApiV1DiagnosticSpeedtestProvidersGetRequest) (*V1DiagnosticSpeedtestProvidersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestProvidersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest-providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestReportPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticSpeedtestReportPutRequest *V1DiagnosticSpeedtestReportPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestReportPutRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestReportPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestReportPutRequest) V1DiagnosticSpeedtestReportPutRequest(v1DiagnosticSpeedtestReportPutRequest V1DiagnosticSpeedtestReportPutRequest) ApiV1DiagnosticSpeedtestReportPutRequest {
	r.v1DiagnosticSpeedtestReportPutRequest = &v1DiagnosticSpeedtestReportPutRequest
	return r
}

func (r ApiV1DiagnosticSpeedtestReportPutRequest) Execute() (*V1DiagnosticSpeedtestReportPutResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestReportPutExecute(r)
}

/*
V1DiagnosticSpeedtestReportPut Method for V1DiagnosticSpeedtestReportPut

Generate a speedtest history report

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestReportPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestReportPut(ctx context.Context) ApiV1DiagnosticSpeedtestReportPutRequest {
	return ApiV1DiagnosticSpeedtestReportPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestReportPutResponse
func (a *DefaultAPIService) V1DiagnosticSpeedtestReportPutExecute(r ApiV1DiagnosticSpeedtestReportPutRequest) (*V1DiagnosticSpeedtestReportPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestReportPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestReportPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticSpeedtestReportPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticSpeedtestReportPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticSpeedtestReportPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestServersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestServersGetRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestServersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestServersGetRequest) Execute() (*V1DiagnosticSpeedtestServersGetResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestServersGetExecute(r)
}

/*
V1DiagnosticSpeedtestServersGet Method for V1DiagnosticSpeedtestServersGet

Get list of servers for a provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestServersGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestServersGet(ctx context.Context) ApiV1DiagnosticSpeedtestServersGetRequest {
	return ApiV1DiagnosticSpeedtestServersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestServersGetResponse
func (a *DefaultAPIService) V1DiagnosticSpeedtestServersGetExecute(r ApiV1DiagnosticSpeedtestServersGetRequest) (*V1DiagnosticSpeedtestServersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestServersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestServersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest-servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticTraceroutePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticTraceroutePostRequest *V1DiagnosticTraceroutePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticTraceroutePostRequest) Authorization(authorization string) ApiV1DiagnosticTraceroutePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticTraceroutePostRequest) V1DiagnosticTraceroutePostRequest(v1DiagnosticTraceroutePostRequest V1DiagnosticTraceroutePostRequest) ApiV1DiagnosticTraceroutePostRequest {
	r.v1DiagnosticTraceroutePostRequest = &v1DiagnosticTraceroutePostRequest
	return r
}

func (r ApiV1DiagnosticTraceroutePostRequest) Execute() (*V1DiagnosticTraceroutePostResponse, *http.Response, error) {
	return r.ApiService.V1DiagnosticTraceroutePostExecute(r)
}

/*
V1DiagnosticTraceroutePost Method for V1DiagnosticTraceroutePost

Trigger a diagnostic test

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticTraceroutePostRequest
*/
func (a *DefaultAPIService) V1DiagnosticTraceroutePost(ctx context.Context) ApiV1DiagnosticTraceroutePostRequest {
	return ApiV1DiagnosticTraceroutePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticTraceroutePostResponse
func (a *DefaultAPIService) V1DiagnosticTraceroutePostExecute(r ApiV1DiagnosticTraceroutePostRequest) (*V1DiagnosticTraceroutePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticTraceroutePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticTraceroutePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/traceroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticTraceroutePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticTraceroutePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticTraceroutePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesHardwareAssignedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesHardwareAssignedGetRequest) Authorization(authorization string) ApiV1EdgesHardwareAssignedGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesHardwareAssignedGetRequest) Execute() (*V1EdgesHardwareAssignedGetResponse, *http.Response, error) {
	return r.ApiService.V1EdgesHardwareAssignedGetExecute(r)
}

/*
V1EdgesHardwareAssignedGet Method for V1EdgesHardwareAssignedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesHardwareAssignedGetRequest
*/
func (a *DefaultAPIService) V1EdgesHardwareAssignedGet(ctx context.Context) ApiV1EdgesHardwareAssignedGetRequest {
	return ApiV1EdgesHardwareAssignedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesHardwareAssignedGetResponse
func (a *DefaultAPIService) V1EdgesHardwareAssignedGetExecute(r ApiV1EdgesHardwareAssignedGetRequest) (*V1EdgesHardwareAssignedGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesHardwareAssignedGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesHardwareAssignedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-hardware/assigned"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesHardwareUnassignedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesHardwareUnassignedGetRequest) Authorization(authorization string) ApiV1EdgesHardwareUnassignedGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesHardwareUnassignedGetRequest) Execute() (*V1EdgesHardwareUnassignedGetResponse, *http.Response, error) {
	return r.ApiService.V1EdgesHardwareUnassignedGetExecute(r)
}

/*
V1EdgesHardwareUnassignedGet Method for V1EdgesHardwareUnassignedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesHardwareUnassignedGetRequest
*/
func (a *DefaultAPIService) V1EdgesHardwareUnassignedGet(ctx context.Context) ApiV1EdgesHardwareUnassignedGetRequest {
	return ApiV1EdgesHardwareUnassignedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesHardwareUnassignedGetResponse
func (a *DefaultAPIService) V1EdgesHardwareUnassignedGetExecute(r ApiV1EdgesHardwareUnassignedGetRequest) (*V1EdgesHardwareUnassignedGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesHardwareUnassignedGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesHardwareUnassignedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-hardware/unassigned"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesSummaryGetRequest) Authorization(authorization string) ApiV1EdgesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesSummaryGetRequest) Execute() (*V1EdgesSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1EdgesSummaryGetExecute(r)
}

/*
V1EdgesSummaryGet Method for V1EdgesSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesSummaryGetRequest
*/
func (a *DefaultAPIService) V1EdgesSummaryGet(ctx context.Context) ApiV1EdgesSummaryGetRequest {
	return ApiV1EdgesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesSummaryGetResponse
func (a *DefaultAPIService) V1EdgesSummaryGetExecute(r ApiV1EdgesSummaryGetRequest) (*V1EdgesSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EdgesSummaryPostRequest *V1EdgesSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesSummaryPostRequest) Authorization(authorization string) ApiV1EdgesSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesSummaryPostRequest) V1EdgesSummaryPostRequest(v1EdgesSummaryPostRequest V1EdgesSummaryPostRequest) ApiV1EdgesSummaryPostRequest {
	r.v1EdgesSummaryPostRequest = &v1EdgesSummaryPostRequest
	return r
}

func (r ApiV1EdgesSummaryPostRequest) Execute() (*V1EdgesSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1EdgesSummaryPostExecute(r)
}

/*
V1EdgesSummaryPost Method for V1EdgesSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesSummaryPostRequest
*/
func (a *DefaultAPIService) V1EdgesSummaryPost(ctx context.Context) ApiV1EdgesSummaryPostRequest {
	return ApiV1EdgesSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesSummaryPostResponse
func (a *DefaultAPIService) V1EdgesSummaryPostExecute(r ApiV1EdgesSummaryPostRequest) (*V1EdgesSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EdgesSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1EdgesSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EdgesSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseAllocationGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseAllocationGetRequest) Authorization(authorization string) ApiV1EnterpriseAllocationGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseAllocationGetRequest) Execute() (*V1EnterpriseAllocationGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterpriseAllocationGetExecute(r)
}

/*
V1EnterpriseAllocationGet Method for V1EnterpriseAllocationGet

Get all allocation for the given enterprise on a given month

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseAllocationGetRequest
*/
func (a *DefaultAPIService) V1EnterpriseAllocationGet(ctx context.Context) ApiV1EnterpriseAllocationGetRequest {
	return ApiV1EnterpriseAllocationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterpriseAllocationGetResponse
func (a *DefaultAPIService) V1EnterpriseAllocationGetExecute(r ApiV1EnterpriseAllocationGetRequest) (*V1EnterpriseAllocationGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterpriseAllocationGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseAllocationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/allocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseConfigurationGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseConfigurationGetRequest) Authorization(authorization string) ApiV1EnterpriseConfigurationGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseConfigurationGetRequest) Execute() (*V1EnterpriseConfigurationGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterpriseConfigurationGetExecute(r)
}

/*
V1EnterpriseConfigurationGet Method for V1EnterpriseConfigurationGet

Get enterprise-level information relevant to device configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseConfigurationGetRequest
*/
func (a *DefaultAPIService) V1EnterpriseConfigurationGet(ctx context.Context) ApiV1EnterpriseConfigurationGetRequest {
	return ApiV1EnterpriseConfigurationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterpriseConfigurationGetResponse
func (a *DefaultAPIService) V1EnterpriseConfigurationGetExecute(r ApiV1EnterpriseConfigurationGetRequest) (*V1EnterpriseConfigurationGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterpriseConfigurationGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseConfigurationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseConfigurationPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterpriseConfigurationPutRequest *V1EnterpriseConfigurationPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseConfigurationPutRequest) Authorization(authorization string) ApiV1EnterpriseConfigurationPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseConfigurationPutRequest) V1EnterpriseConfigurationPutRequest(v1EnterpriseConfigurationPutRequest V1EnterpriseConfigurationPutRequest) ApiV1EnterpriseConfigurationPutRequest {
	r.v1EnterpriseConfigurationPutRequest = &v1EnterpriseConfigurationPutRequest
	return r
}

func (r ApiV1EnterpriseConfigurationPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterpriseConfigurationPutExecute(r)
}

/*
V1EnterpriseConfigurationPut Method for V1EnterpriseConfigurationPut

Update enterprise-level information relevant to device configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseConfigurationPutRequest
*/
func (a *DefaultAPIService) V1EnterpriseConfigurationPut(ctx context.Context) ApiV1EnterpriseConfigurationPutRequest {
	return ApiV1EnterpriseConfigurationPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterpriseConfigurationPutExecute(r ApiV1EnterpriseConfigurationPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseConfigurationPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterpriseConfigurationPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1EnterpriseConfigurationPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterpriseConfigurationPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseContractPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterpriseContractPutRequest *V1EnterpriseContractPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseContractPutRequest) Authorization(authorization string) ApiV1EnterpriseContractPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseContractPutRequest) V1EnterpriseContractPutRequest(v1EnterpriseContractPutRequest V1EnterpriseContractPutRequest) ApiV1EnterpriseContractPutRequest {
	r.v1EnterpriseContractPutRequest = &v1EnterpriseContractPutRequest
	return r
}

func (r ApiV1EnterpriseContractPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterpriseContractPutExecute(r)
}

/*
V1EnterpriseContractPut Method for V1EnterpriseContractPut

Update an enterprise to use a new monthly or term-based contract

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseContractPutRequest
*/
func (a *DefaultAPIService) V1EnterpriseContractPut(ctx context.Context) ApiV1EnterpriseContractPutRequest {
	return ApiV1EnterpriseContractPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterpriseContractPutExecute(r ApiV1EnterpriseContractPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseContractPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/contract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterpriseContractPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1EnterpriseContractPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterpriseContractPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseSnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseSnapshotGetRequest) Authorization(authorization string) ApiV1EnterpriseSnapshotGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseSnapshotGetRequest) Execute() (*V1EnterpriseSnapshotGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterpriseSnapshotGetExecute(r)
}

/*
V1EnterpriseSnapshotGet Method for V1EnterpriseSnapshotGet

Get a all of the device snapshots for every device in an enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseSnapshotGetRequest
*/
func (a *DefaultAPIService) V1EnterpriseSnapshotGet(ctx context.Context) ApiV1EnterpriseSnapshotGetRequest {
	return ApiV1EnterpriseSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterpriseSnapshotGetResponse
func (a *DefaultAPIService) V1EnterpriseSnapshotGetExecute(r ApiV1EnterpriseSnapshotGetRequest) (*V1EnterpriseSnapshotGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterpriseSnapshotGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEnterpriseIdAdminGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEnterpriseIdAdminGetRequest) Authorization(authorization string) ApiV1EnterprisesEnterpriseIdAdminGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEnterpriseIdAdminGetRequest) Execute() (*V1EnterprisesEnterpriseIdAdminGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterprisesEnterpriseIdAdminGetExecute(r)
}

/*
V1EnterprisesEnterpriseIdAdminGet Method for V1EnterprisesEnterpriseIdAdminGet

Get the admin account for an enterprise.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @return ApiV1EnterprisesEnterpriseIdAdminGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdAdminGet(ctx context.Context, enterpriseId int64) ApiV1EnterprisesEnterpriseIdAdminGetRequest {
	return ApiV1EnterprisesEnterpriseIdAdminGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V1EnterprisesEnterpriseIdAdminGetResponse
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdAdminGetExecute(r ApiV1EnterprisesEnterpriseIdAdminGetRequest) (*V1EnterprisesEnterpriseIdAdminGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesEnterpriseIdAdminGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEnterpriseIdAdminGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/{enterpriseId}/admin"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEnterpriseIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEnterpriseIdDeleteRequest) Authorization(authorization string) ApiV1EnterprisesEnterpriseIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEnterpriseIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnterprisesEnterpriseIdDeleteExecute(r)
}

/*
V1EnterprisesEnterpriseIdDelete Method for V1EnterprisesEnterpriseIdDelete

Delete a specific enterprise by ID (you must manage this tenant).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @return ApiV1EnterprisesEnterpriseIdDeleteRequest
*/
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDelete(ctx context.Context, enterpriseId int64) ApiV1EnterprisesEnterpriseIdDeleteRequest {
	return ApiV1EnterprisesEnterpriseIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDeleteExecute(r ApiV1EnterprisesEnterpriseIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEnterpriseIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/{enterpriseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest) Authorization(authorization string) ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest) Execute() (*V1EnterprisesEnterpriseIdDeviceStatusGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterprisesEnterpriseIdDeviceStatusGetExecute(r)
}

/*
V1EnterprisesEnterpriseIdDeviceStatusGet Method for V1EnterprisesEnterpriseIdDeviceStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @return ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDeviceStatusGet(ctx context.Context, enterpriseId int64) ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest {
	return ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V1EnterprisesEnterpriseIdDeviceStatusGetResponse
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDeviceStatusGetExecute(r ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest) (*V1EnterprisesEnterpriseIdDeviceStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesEnterpriseIdDeviceStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEnterpriseIdDeviceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/{enterpriseId}/device-status"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.enterpriseId < 0 {
		return localVarReturnValue, nil, reportError("enterpriseId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEulaPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEulaPostRequest) Authorization(authorization string) ApiV1EnterprisesEulaPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEulaPostRequest) Body(body map[string]interface{}) ApiV1EnterprisesEulaPostRequest {
	r.body = &body
	return r
}

func (r ApiV1EnterprisesEulaPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnterprisesEulaPostExecute(r)
}

/*
V1EnterprisesEulaPost Method for V1EnterprisesEulaPost

Accept End User License Agreement for the enterprise.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesEulaPostRequest
*/
func (a *DefaultAPIService) V1EnterprisesEulaPost(ctx context.Context) ApiV1EnterprisesEulaPostRequest {
	return ApiV1EnterprisesEulaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1EnterprisesEulaPostExecute(r ApiV1EnterprisesEulaPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEulaPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/eula"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseIds *[]int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesGetRequest) Authorization(authorization string) ApiV1EnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

// Lists enterprises
func (r ApiV1EnterprisesGetRequest) EnterpriseIds(enterpriseIds []int64) ApiV1EnterprisesGetRequest {
	r.enterpriseIds = &enterpriseIds
	return r
}

func (r ApiV1EnterprisesGetRequest) Execute() (*V1EnterprisesGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterprisesGetExecute(r)
}

/*
V1EnterprisesGet Method for V1EnterprisesGet

Get specific enterprises by their IDs with detailed information. Query just your own enterprise Id for more detailed info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesGet(ctx context.Context) ApiV1EnterprisesGetRequest {
	return ApiV1EnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterprisesGetResponse
func (a *DefaultAPIService) V1EnterprisesGetExecute(r ApiV1EnterprisesGetRequest) (*V1EnterprisesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.enterpriseIds != nil {
		t := *r.enterpriseIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enterpriseIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enterpriseIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesManagedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	type_ *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesManagedGetRequest) Authorization(authorization string) ApiV1EnterprisesManagedGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1EnterprisesManagedGetRequest) Type_(type_ string) ApiV1EnterprisesManagedGetRequest {
	r.type_ = &type_
	return r
}

func (r ApiV1EnterprisesManagedGetRequest) Execute() (*V1EnterprisesManagedGetResponse, *http.Response, error) {
	return r.ApiService.V1EnterprisesManagedGetExecute(r)
}

/*
V1EnterprisesManagedGet Method for V1EnterprisesManagedGet

Get enterprises managed by your tenant, filtered by enterprise type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesManagedGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesManagedGet(ctx context.Context) ApiV1EnterprisesManagedGetRequest {
	return ApiV1EnterprisesManagedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterprisesManagedGetResponse
func (a *DefaultAPIService) V1EnterprisesManagedGetExecute(r ApiV1EnterprisesManagedGetRequest) (*V1EnterprisesManagedGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesManagedGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesManagedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/managed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterprisesPatchRequest *V1EnterprisesPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesPatchRequest) Authorization(authorization string) ApiV1EnterprisesPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesPatchRequest) V1EnterprisesPatchRequest(v1EnterprisesPatchRequest V1EnterprisesPatchRequest) ApiV1EnterprisesPatchRequest {
	r.v1EnterprisesPatchRequest = &v1EnterprisesPatchRequest
	return r
}

func (r ApiV1EnterprisesPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnterprisesPatchExecute(r)
}

/*
V1EnterprisesPatch Method for V1EnterprisesPatch

Updates all relevent enterprise information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesPatchRequest
*/
func (a *DefaultAPIService) V1EnterprisesPatch(ctx context.Context) ApiV1EnterprisesPatchRequest {
	return ApiV1EnterprisesPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1EnterprisesPatchExecute(r ApiV1EnterprisesPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterprisesPatchRequest == nil {
		return nil, reportError("v1EnterprisesPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterprisesPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EnterprisesPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterprisesPutRequest *V1EnterprisesPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesPutRequest) Authorization(authorization string) ApiV1EnterprisesPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesPutRequest) V1EnterprisesPutRequest(v1EnterprisesPutRequest V1EnterprisesPutRequest) ApiV1EnterprisesPutRequest {
	r.v1EnterprisesPutRequest = &v1EnterprisesPutRequest
	return r
}

func (r ApiV1EnterprisesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnterprisesPutExecute(r)
}

/*
V1EnterprisesPut Method for V1EnterprisesPut

Create a new enterprise with company details, account type, and admin user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesPutRequest
*/
func (a *DefaultAPIService) V1EnterprisesPut(ctx context.Context) ApiV1EnterprisesPutRequest {
	return ApiV1EnterprisesPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1EnterprisesPutExecute(r ApiV1EnterprisesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterprisesPutRequest == nil {
		return nil, reportError("v1EnterprisesPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterprisesPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EnterprisesSelfDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesSelfDeleteRequest) Authorization(authorization string) ApiV1EnterprisesSelfDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesSelfDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1EnterprisesSelfDeleteExecute(r)
}

/*
V1EnterprisesSelfDelete Method for V1EnterprisesSelfDelete

Delete the current user's enterprise (self-deletion).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesSelfDeleteRequest
*/
func (a *DefaultAPIService) V1EnterprisesSelfDelete(ctx context.Context) ApiV1EnterprisesSelfDeleteRequest {
	return ApiV1EnterprisesSelfDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1EnterprisesSelfDeleteExecute(r ApiV1EnterprisesSelfDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesSelfDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/self"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1EventDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventDeviceGetRequest) Authorization(authorization string) ApiV1EventDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventDeviceGetRequest) Execute() (*V1EventDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1EventDeviceGetExecute(r)
}

/*
V1EventDeviceGet Method for V1EventDeviceGet

Get All events by DeviceID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventDeviceGetRequest
*/
func (a *DefaultAPIService) V1EventDeviceGet(ctx context.Context) ApiV1EventDeviceGetRequest {
	return ApiV1EventDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EventDeviceGetResponse
func (a *DefaultAPIService) V1EventDeviceGetExecute(r ApiV1EventDeviceGetRequest) (*V1EventDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EventDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventEnterpriseGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventEnterpriseGetRequest) Authorization(authorization string) ApiV1EventEnterpriseGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventEnterpriseGetRequest) Execute() (*V1EventEnterpriseGetResponse, *http.Response, error) {
	return r.ApiService.V1EventEnterpriseGetExecute(r)
}

/*
V1EventEnterpriseGet Method for V1EventEnterpriseGet

Get All events by EnterpriseID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventEnterpriseGetRequest
*/
func (a *DefaultAPIService) V1EventEnterpriseGet(ctx context.Context) ApiV1EventEnterpriseGetRequest {
	return ApiV1EventEnterpriseGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EventEnterpriseGetResponse
func (a *DefaultAPIService) V1EventEnterpriseGetExecute(r ApiV1EventEnterpriseGetRequest) (*V1EventEnterpriseGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EventEnterpriseGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventEnterpriseGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventSystemAckPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EventSystemAckPostRequest *V1EventSystemAckPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventSystemAckPostRequest) Authorization(authorization string) ApiV1EventSystemAckPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventSystemAckPostRequest) V1EventSystemAckPostRequest(v1EventSystemAckPostRequest V1EventSystemAckPostRequest) ApiV1EventSystemAckPostRequest {
	r.v1EventSystemAckPostRequest = &v1EventSystemAckPostRequest
	return r
}

func (r ApiV1EventSystemAckPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EventSystemAckPostExecute(r)
}

/*
V1EventSystemAckPost Method for V1EventSystemAckPost

Update User Acknowledgement for an event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventSystemAckPostRequest
*/
func (a *DefaultAPIService) V1EventSystemAckPost(ctx context.Context) ApiV1EventSystemAckPostRequest {
	return ApiV1EventSystemAckPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EventSystemAckPostExecute(r ApiV1EventSystemAckPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventSystemAckPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/system/ack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EventSystemAckPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1EventSystemAckPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EventSystemAckPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventSystemGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventSystemGetRequest) Authorization(authorization string) ApiV1EventSystemGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventSystemGetRequest) Execute() (*V1EventSystemGetResponse, *http.Response, error) {
	return r.ApiService.V1EventSystemGetExecute(r)
}

/*
V1EventSystemGet Method for V1EventSystemGet

Get All system level events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventSystemGetRequest
*/
func (a *DefaultAPIService) V1EventSystemGet(ctx context.Context) ApiV1EventSystemGetRequest {
	return ApiV1EventSystemGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EventSystemGetResponse
func (a *DefaultAPIService) V1EventSystemGetExecute(r ApiV1EventSystemGetRequest) (*V1EventSystemGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EventSystemGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventSystemGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest *V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest) Authorization(authorization string) ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest) V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest(v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest) ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest {
	r.v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest = &v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest) Execute() (*V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostExecute(r)
}

/*
V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePost Method for V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePost

Get b2b extranet peering service sites usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest
*/
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePost(ctx context.Context) ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest {
	return ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostResponse
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostExecute(r ApiV1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest) (*V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet-b2b-monitoring/peering-service/bandwidth-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetB2bMonitoringPeeringServiceBandwidthUsagePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest *V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest) Authorization(authorization string) ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest) V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest(v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest) ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest {
	r.v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest = &v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest) Execute() (*V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostExecute(r)
}

/*
V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPost Method for V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPost

Get b2b extranet peering service top consumers usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest
*/
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPost(ctx context.Context) ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest {
	return ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostResponse
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostExecute(r ApiV1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest) (*V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet-b2b-monitoring/peering-service/consumers-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetB2bMonitoringPeeringServiceConsumersUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest *V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest) Authorization(authorization string) ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest) V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest(v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest) ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest {
	r.v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest = &v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest) Execute() (*V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostExecute(r)
}

/*
V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPost Method for V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPost

Get b2b extranet peering consumption overview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest
*/
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPost(ctx context.Context) ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest {
	return ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostResponse
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostExecute(r ApiV1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest) (*V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet-b2b-monitoring/peering-service/consumption-overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetB2bMonitoringPeeringServiceConsumptionOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest *V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest) Authorization(authorization string) ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest) V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest(v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest) ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest {
	r.v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest = &v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest) Execute() (*V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostExecute(r)
}

/*
V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPost Method for V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPost

Get b2b extranet peering service customer list within a time window

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest
*/
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPost(ctx context.Context) ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest {
	return ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostResponse
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostExecute(r ApiV1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest) (*V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet-b2b-monitoring/peering-service/service-customer-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetB2bMonitoringPeeringServiceServiceCustomerListPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest *V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest) Authorization(authorization string) ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest) V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest(v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest) ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest {
	r.v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest = &v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest) Execute() (*V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostExecute(r)
}

/*
V1ExtranetB2bMonitoringPeeringServiceServiceHealthPost Method for V1ExtranetB2bMonitoringPeeringServiceServiceHealthPost

Returns connectivity status for a b2b peering service. Provides overall service connectivity status and detailed status for producer and customer prefixes for each consumer of the serviceShows whether the service is healthy, impaired, or down, and lists any missing prefixes in Impaired state. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest
*/
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceServiceHealthPost(ctx context.Context) ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest {
	return ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostResponse
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostExecute(r ApiV1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest) (*V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetB2bMonitoringPeeringServiceServiceHealthPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetB2bMonitoringPeeringServiceServiceHealthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet-b2b-monitoring/peering-service/service-health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetB2bMonitoringPeeringServiceServiceHealthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest *V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest) Authorization(authorization string) ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest) V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest(v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest) ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest {
	r.v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest = &v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest
	return r
}

func (r ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest) Execute() (*V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostExecute(r)
}

/*
V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPost Method for V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPost

Get b2b extranet peering service overtime consumption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest
*/
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPost(ctx context.Context) ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest {
	return ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostResponse
func (a *DefaultAPIService) V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostExecute(r ApiV1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest) (*V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet-b2b-monitoring/peering-service/service-overtime-consumption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetB2bMonitoringPeeringServiceServiceOvertimeConsumptionPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetSitesUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetSitesUsagePostRequest *V1ExtranetSitesUsagePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetSitesUsagePostRequest) Authorization(authorization string) ApiV1ExtranetSitesUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetSitesUsagePostRequest) V1ExtranetSitesUsagePostRequest(v1ExtranetSitesUsagePostRequest V1ExtranetSitesUsagePostRequest) ApiV1ExtranetSitesUsagePostRequest {
	r.v1ExtranetSitesUsagePostRequest = &v1ExtranetSitesUsagePostRequest
	return r
}

func (r ApiV1ExtranetSitesUsagePostRequest) Execute() (*V1ExtranetSitesUsagePostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetSitesUsagePostExecute(r)
}

/*
V1ExtranetSitesUsagePost Method for V1ExtranetSitesUsagePost

Get extranet service sites usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetSitesUsagePostRequest
*/
func (a *DefaultAPIService) V1ExtranetSitesUsagePost(ctx context.Context) ApiV1ExtranetSitesUsagePostRequest {
	return ApiV1ExtranetSitesUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetSitesUsagePostResponse
func (a *DefaultAPIService) V1ExtranetSitesUsagePostExecute(r ApiV1ExtranetSitesUsagePostRequest) (*V1ExtranetSitesUsagePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetSitesUsagePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetSitesUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet/sites-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetSitesUsagePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetSitesUsagePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetSitesUsagePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetSitesUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetSitesUsageTopPostRequest *V1ExtranetSitesUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetSitesUsageTopPostRequest) Authorization(authorization string) ApiV1ExtranetSitesUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetSitesUsageTopPostRequest) V1ExtranetSitesUsageTopPostRequest(v1ExtranetSitesUsageTopPostRequest V1ExtranetSitesUsageTopPostRequest) ApiV1ExtranetSitesUsageTopPostRequest {
	r.v1ExtranetSitesUsageTopPostRequest = &v1ExtranetSitesUsageTopPostRequest
	return r
}

func (r ApiV1ExtranetSitesUsageTopPostRequest) Execute() (*V1ExtranetSitesUsageTopPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetSitesUsageTopPostExecute(r)
}

/*
V1ExtranetSitesUsageTopPost Method for V1ExtranetSitesUsageTopPost

Get extranet service top sites usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetSitesUsageTopPostRequest
*/
func (a *DefaultAPIService) V1ExtranetSitesUsageTopPost(ctx context.Context) ApiV1ExtranetSitesUsageTopPostRequest {
	return ApiV1ExtranetSitesUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetSitesUsageTopPostResponse
func (a *DefaultAPIService) V1ExtranetSitesUsageTopPostExecute(r ApiV1ExtranetSitesUsageTopPostRequest) (*V1ExtranetSitesUsageTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetSitesUsageTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetSitesUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet/sites-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetSitesUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetSitesUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetSitesUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest) Execute() (*V1ExtranetsB2bConsumerDeviceStatusIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerDeviceStatusIdGetExecute(r)
}

/*
V1ExtranetsB2bConsumerDeviceStatusIdGet Method for V1ExtranetsB2bConsumerDeviceStatusIdGet

Get B2B extranet consumer status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerDeviceStatusIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest {
	return ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerDeviceStatusIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bConsumerDeviceStatusIdGetExecute(r ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest) (*V1ExtranetsB2bConsumerDeviceStatusIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerDeviceStatusIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerDeviceStatusIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer-device-status/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerIdDeleteExecute(r)
}

/*
V1ExtranetsB2bConsumerIdDelete Method for V1ExtranetsB2bConsumerIdDelete

Delete a B2B extranet consumer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bConsumerIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bConsumerIdDeleteRequest {
	return ApiV1ExtranetsB2bConsumerIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdDeleteExecute(r ApiV1ExtranetsB2bConsumerIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerIdGetRequest) Execute() (*V1ExtranetsB2bConsumerIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerIdGetExecute(r)
}

/*
V1ExtranetsB2bConsumerIdGet Method for V1ExtranetsB2bConsumerIdGet

Get a B2B extranet consumer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bConsumerIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bConsumerIdGetRequest {
	return ApiV1ExtranetsB2bConsumerIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdGetExecute(r ApiV1ExtranetsB2bConsumerIdGetRequest) (*V1ExtranetsB2bConsumerIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bConsumerPostRequest *V1ExtranetsB2bConsumerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerPostRequest) V1ExtranetsB2bConsumerPostRequest(v1ExtranetsB2bConsumerPostRequest V1ExtranetsB2bConsumerPostRequest) ApiV1ExtranetsB2bConsumerPostRequest {
	r.v1ExtranetsB2bConsumerPostRequest = &v1ExtranetsB2bConsumerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bConsumerPostRequest) Execute() (*V1ExtranetsB2bConsumerPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerPostExecute(r)
}

/*
V1ExtranetsB2bConsumerPost Method for V1ExtranetsB2bConsumerPost

Create a new B2B extranet consumer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bConsumerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerPost(ctx context.Context) ApiV1ExtranetsB2bConsumerPostRequest {
	return ApiV1ExtranetsB2bConsumerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bConsumerPostExecute(r ApiV1ExtranetsB2bConsumerPostRequest) (*V1ExtranetsB2bConsumerPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bConsumerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bConsumerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bConsumerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerSummaryGetRequest) Execute() (*V1ExtranetsB2bConsumerSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerSummaryGetExecute(r)
}

/*
V1ExtranetsB2bConsumerSummaryGet Method for V1ExtranetsB2bConsumerSummaryGet

Get B2B extranet consumers summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bConsumerSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerSummaryGet(ctx context.Context) ApiV1ExtranetsB2bConsumerSummaryGetRequest {
	return ApiV1ExtranetsB2bConsumerSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerSummaryGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bConsumerSummaryGetExecute(r ApiV1ExtranetsB2bConsumerSummaryGetRequest) (*V1ExtranetsB2bConsumerSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bCustomerIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bCustomerIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bCustomerIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bCustomerIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bCustomerIdDeleteExecute(r)
}

/*
V1ExtranetsB2bCustomerIdDelete Method for V1ExtranetsB2bCustomerIdDelete

Delete a B2B extranet customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bCustomerIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bCustomerIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bCustomerIdDeleteRequest {
	return ApiV1ExtranetsB2bCustomerIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bCustomerIdDeleteExecute(r ApiV1ExtranetsB2bCustomerIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bCustomerIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/customer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bCustomerInfoIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bCustomerInfoIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bCustomerInfoIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bCustomerInfoIdGetRequest) Execute() (*V1ExtranetsB2bCustomerInfoIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bCustomerInfoIdGetExecute(r)
}

/*
V1ExtranetsB2bCustomerInfoIdGet Method for V1ExtranetsB2bCustomerInfoIdGet

Get B2B extranet application customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bCustomerInfoIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bCustomerInfoIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bCustomerInfoIdGetRequest {
	return ApiV1ExtranetsB2bCustomerInfoIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bCustomerInfoIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bCustomerInfoIdGetExecute(r ApiV1ExtranetsB2bCustomerInfoIdGetRequest) (*V1ExtranetsB2bCustomerInfoIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bCustomerInfoIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bCustomerInfoIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/customer-info/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest) Execute() (*V1ExtranetsB2bGeneralCustomersSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bGeneralCustomersSummaryGetExecute(r)
}

/*
V1ExtranetsB2bGeneralCustomersSummaryGet Method for V1ExtranetsB2bGeneralCustomersSummaryGet

Get summary for a B2B extranet peering services customers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bGeneralCustomersSummaryGet(ctx context.Context) ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest {
	return ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bGeneralCustomersSummaryGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bGeneralCustomersSummaryGetExecute(r ApiV1ExtranetsB2bGeneralCustomersSummaryGetRequest) (*V1ExtranetsB2bGeneralCustomersSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bGeneralCustomersSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bGeneralCustomersSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-general/customers-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest) Execute() (*V1ExtranetsB2bGeneralServicesSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bGeneralServicesSummaryGetExecute(r)
}

/*
V1ExtranetsB2bGeneralServicesSummaryGet Method for V1ExtranetsB2bGeneralServicesSummaryGet

Get a summary for all the B2B extranet services

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bGeneralServicesSummaryGet(ctx context.Context) ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest {
	return ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bGeneralServicesSummaryGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bGeneralServicesSummaryGetExecute(r ApiV1ExtranetsB2bGeneralServicesSummaryGetRequest) (*V1ExtranetsB2bGeneralServicesSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bGeneralServicesSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bGeneralServicesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-general/services-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdCustomerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsB2bIdCustomerPostRequest *V1ExtranetsB2bIdCustomerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdCustomerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdCustomerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerPostRequest) V1ExtranetsB2bIdCustomerPostRequest(v1ExtranetsB2bIdCustomerPostRequest V1ExtranetsB2bIdCustomerPostRequest) ApiV1ExtranetsB2bIdCustomerPostRequest {
	r.v1ExtranetsB2bIdCustomerPostRequest = &v1ExtranetsB2bIdCustomerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerPostRequest) Execute() (*V1ExtranetsB2bIdCustomerPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdCustomerPostExecute(r)
}

/*
V1ExtranetsB2bIdCustomerPost Method for V1ExtranetsB2bIdCustomerPost

Create B2B extranet application customer invite

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Service ID of the application customer is invited to
 @return ApiV1ExtranetsB2bIdCustomerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerPost(ctx context.Context, id int64) ApiV1ExtranetsB2bIdCustomerPostRequest {
	return ApiV1ExtranetsB2bIdCustomerPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bIdCustomerPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerPostExecute(r ApiV1ExtranetsB2bIdCustomerPostRequest) (*V1ExtranetsB2bIdCustomerPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bIdCustomerPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdCustomerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/customer/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bIdCustomerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bIdCustomerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bIdCustomerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdCustomerSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdCustomerSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdCustomerSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerSummaryGetRequest) Execute() (*V1ExtranetsB2bIdCustomerSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdCustomerSummaryGetExecute(r)
}

/*
V1ExtranetsB2bIdCustomerSummaryGet Method for V1ExtranetsB2bIdCustomerSummaryGet

Get B2B extranet application customers summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdCustomerSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerSummaryGet(ctx context.Context, id int64) ApiV1ExtranetsB2bIdCustomerSummaryGetRequest {
	return ApiV1ExtranetsB2bIdCustomerSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bIdCustomerSummaryGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerSummaryGetExecute(r ApiV1ExtranetsB2bIdCustomerSummaryGetRequest) (*V1ExtranetsB2bIdCustomerSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bIdCustomerSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdCustomerSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/customer-summary"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdDeleteExecute(r)
}

/*
V1ExtranetsB2bIdDelete Method for V1ExtranetsB2bIdDelete

Delete a B2B extranet producer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the producer service to be deleted
 @return ApiV1ExtranetsB2bIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bIdDeleteRequest {
	return ApiV1ExtranetsB2bIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bIdDeleteExecute(r ApiV1ExtranetsB2bIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdProducerGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	type_ *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdProducerGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdProducerGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1ExtranetsB2bIdProducerGetRequest) Type_(type_ string) ApiV1ExtranetsB2bIdProducerGetRequest {
	r.type_ = &type_
	return r
}

func (r ApiV1ExtranetsB2bIdProducerGetRequest) Execute() (*V1ExtranetsB2bIdProducerGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdProducerGetExecute(r)
}

/*
V1ExtranetsB2bIdProducerGet Method for V1ExtranetsB2bIdProducerGet

Get a B2B extranet producer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdProducerGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdProducerGet(ctx context.Context, id int64) ApiV1ExtranetsB2bIdProducerGetRequest {
	return ApiV1ExtranetsB2bIdProducerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bIdProducerGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bIdProducerGetExecute(r ApiV1ExtranetsB2bIdProducerGetRequest) (*V1ExtranetsB2bIdProducerGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bIdProducerGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdProducerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/producer"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsB2bIdPutRequest *V1ExtranetsB2bIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdPutRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdPutRequest) V1ExtranetsB2bIdPutRequest(v1ExtranetsB2bIdPutRequest V1ExtranetsB2bIdPutRequest) ApiV1ExtranetsB2bIdPutRequest {
	r.v1ExtranetsB2bIdPutRequest = &v1ExtranetsB2bIdPutRequest
	return r
}

func (r ApiV1ExtranetsB2bIdPutRequest) Execute() (*V1ExtranetsB2bIdPutResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdPutExecute(r)
}

/*
V1ExtranetsB2bIdPut Method for V1ExtranetsB2bIdPut

Update a B2B extranet producer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the B2B Application service
 @return ApiV1ExtranetsB2bIdPutRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdPut(ctx context.Context, id int64) ApiV1ExtranetsB2bIdPutRequest {
	return ApiV1ExtranetsB2bIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bIdPutResponse
func (a *DefaultAPIService) V1ExtranetsB2bIdPutExecute(r ApiV1ExtranetsB2bIdPutRequest) (*V1ExtranetsB2bIdPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bIdPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	customerId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest) Execute() (*V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetExecute(r)
}

/*
V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGet Method for V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGet

Get details of a service subscription for a customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerId 
 @return ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGet(ctx context.Context, customerId int64) ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest {
	return ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetExecute(r ApiV1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetRequest) (*V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringConsumerCustomerIdConsumerDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/consumer/{customerId}/consumer-details"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	matchId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest) Execute() (*V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetExecute(r)
}

/*
V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGet Method for V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGet

Get details of a service match for a customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId 
 @return ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGet(ctx context.Context, matchId int64) ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest {
	return ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetExecute(r ApiV1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetRequest) (*V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringConsumerMatchIdMatchDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/consumer/{matchId}/match-details"
	localVarPath = strings.Replace(localVarPath, "{"+"matchId"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	matchId int64
	v1ExtranetsB2bPeeringConsumerMatchIdPostRequest *V1ExtranetsB2bPeeringConsumerMatchIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest) V1ExtranetsB2bPeeringConsumerMatchIdPostRequest(v1ExtranetsB2bPeeringConsumerMatchIdPostRequest V1ExtranetsB2bPeeringConsumerMatchIdPostRequest) ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest {
	r.v1ExtranetsB2bPeeringConsumerMatchIdPostRequest = &v1ExtranetsB2bPeeringConsumerMatchIdPostRequest
	return r
}

func (r ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest) Execute() (*V1ExtranetsB2bPeeringConsumerMatchIdPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringConsumerMatchIdPostExecute(r)
}

/*
V1ExtranetsB2bPeeringConsumerMatchIdPost Method for V1ExtranetsB2bPeeringConsumerMatchIdPost

Create B2B extranet peering service consumer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId ID of the match for the customer subscription of the service
 @return ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringConsumerMatchIdPost(ctx context.Context, matchId int64) ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest {
	return ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringConsumerMatchIdPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringConsumerMatchIdPostExecute(r ApiV1ExtranetsB2bPeeringConsumerMatchIdPostRequest) (*V1ExtranetsB2bPeeringConsumerMatchIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringConsumerMatchIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringConsumerMatchIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/consumer/{matchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"matchId"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bPeeringConsumerMatchIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bPeeringConsumerMatchIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bPeeringConsumerMatchIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest) Execute() (*V1ExtranetsB2bPeeringCustomerIdDeleteResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringCustomerIdDeleteExecute(r)
}

/*
V1ExtranetsB2bPeeringCustomerIdDelete Method for V1ExtranetsB2bPeeringCustomerIdDelete

Delete a B2B extranet peering service customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the peering service customer
 @return ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringCustomerIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest {
	return ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringCustomerIdDeleteResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringCustomerIdDeleteExecute(r ApiV1ExtranetsB2bPeeringCustomerIdDeleteRequest) (*V1ExtranetsB2bPeeringCustomerIdDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringCustomerIdDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringCustomerIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/customer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringCustomerIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringCustomerIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringCustomerIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringCustomerIdGetRequest) Execute() (*V1ExtranetsB2bPeeringCustomerIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringCustomerIdGetExecute(r)
}

/*
V1ExtranetsB2bPeeringCustomerIdGet Method for V1ExtranetsB2bPeeringCustomerIdGet

Get a B2B extranet peering service customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the peering service customer
 @return ApiV1ExtranetsB2bPeeringCustomerIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringCustomerIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringCustomerIdGetRequest {
	return ApiV1ExtranetsB2bPeeringCustomerIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringCustomerIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringCustomerIdGetExecute(r ApiV1ExtranetsB2bPeeringCustomerIdGetRequest) (*V1ExtranetsB2bPeeringCustomerIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringCustomerIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringCustomerIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/customer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringCustomerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bPeeringCustomerPostRequest *V1ExtranetsB2bPeeringCustomerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringCustomerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringCustomerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringCustomerPostRequest) V1ExtranetsB2bPeeringCustomerPostRequest(v1ExtranetsB2bPeeringCustomerPostRequest V1ExtranetsB2bPeeringCustomerPostRequest) ApiV1ExtranetsB2bPeeringCustomerPostRequest {
	r.v1ExtranetsB2bPeeringCustomerPostRequest = &v1ExtranetsB2bPeeringCustomerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bPeeringCustomerPostRequest) Execute() (*V1ExtranetsB2bPeeringCustomerPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringCustomerPostExecute(r)
}

/*
V1ExtranetsB2bPeeringCustomerPost Method for V1ExtranetsB2bPeeringCustomerPost

Create a new B2B extranet peering service customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bPeeringCustomerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringCustomerPost(ctx context.Context) ApiV1ExtranetsB2bPeeringCustomerPostRequest {
	return ApiV1ExtranetsB2bPeeringCustomerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringCustomerPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringCustomerPostExecute(r ApiV1ExtranetsB2bPeeringCustomerPostRequest) (*V1ExtranetsB2bPeeringCustomerPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringCustomerPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringCustomerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/customer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bPeeringCustomerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bPeeringCustomerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bPeeringCustomerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest) Execute() (*V1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteExecute(r)
}

/*
V1ExtranetsB2bPeeringMatchServiceToCustomerIdDelete Method for V1ExtranetsB2bPeeringMatchServiceToCustomerIdDelete

Unsubscribe a customer from a service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID for the service to customer match to be deleted
 @return ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServiceToCustomerIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest {
	return ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteExecute(r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteRequest) (*V1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringMatchServiceToCustomerIdDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringMatchServiceToCustomerIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/match/service-to-customer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest) Execute() (*V1ExtranetsB2bPeeringMatchServiceToCustomerIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringMatchServiceToCustomerIdGetExecute(r)
}

/*
V1ExtranetsB2bPeeringMatchServiceToCustomerIdGet Method for V1ExtranetsB2bPeeringMatchServiceToCustomerIdGet

Get details for a service to customer subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Service id for which match details are requested
 @return ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServiceToCustomerIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest {
	return ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringMatchServiceToCustomerIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServiceToCustomerIdGetExecute(r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerIdGetRequest) (*V1ExtranetsB2bPeeringMatchServiceToCustomerIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringMatchServiceToCustomerIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringMatchServiceToCustomerIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/match/service-to-customer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest *V1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest) V1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest(v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest V1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest {
	r.v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest = &v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest) Execute() (*V1ExtranetsB2bPeeringMatchServiceToCustomerPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringMatchServiceToCustomerPostExecute(r)
}

/*
V1ExtranetsB2bPeeringMatchServiceToCustomerPost Method for V1ExtranetsB2bPeeringMatchServiceToCustomerPost

Create B2B extranet configuration for matching a service to a customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServiceToCustomerPost(ctx context.Context) ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest {
	return ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringMatchServiceToCustomerPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServiceToCustomerPostExecute(r ApiV1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest) (*V1ExtranetsB2bPeeringMatchServiceToCustomerPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringMatchServiceToCustomerPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringMatchServiceToCustomerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/match/service-to-customer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bPeeringMatchServiceToCustomerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest) Execute() (*V1ExtranetsB2bPeeringMatchServicesSummaryIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringMatchServicesSummaryIdGetExecute(r)
}

/*
V1ExtranetsB2bPeeringMatchServicesSummaryIdGet Method for V1ExtranetsB2bPeeringMatchServicesSummaryIdGet

Get B2B extranet services matching customers summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the customer
 @return ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServicesSummaryIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest {
	return ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringMatchServicesSummaryIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringMatchServicesSummaryIdGetExecute(r ApiV1ExtranetsB2bPeeringMatchServicesSummaryIdGetRequest) (*V1ExtranetsB2bPeeringMatchServicesSummaryIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringMatchServicesSummaryIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringMatchServicesSummaryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/match/services/summary/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringProducerIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringProducerIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringProducerIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringProducerIdGetRequest) Execute() (*V1ExtranetsB2bPeeringProducerIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringProducerIdGetExecute(r)
}

/*
V1ExtranetsB2bPeeringProducerIdGet Method for V1ExtranetsB2bPeeringProducerIdGet

Get B2B extranet peering service producer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the service
 @return ApiV1ExtranetsB2bPeeringProducerIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringProducerIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringProducerIdGetRequest {
	return ApiV1ExtranetsB2bPeeringProducerIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringProducerIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringProducerIdGetExecute(r ApiV1ExtranetsB2bPeeringProducerIdGetRequest) (*V1ExtranetsB2bPeeringProducerIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringProducerIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringProducerIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/producer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest) Execute() (*V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetExecute(r)
}

/*
V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGet Method for V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGet

Get B2B extranet customers summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the customer
 @return ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGet(ctx context.Context, id int64) ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest {
	return ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetExecute(r ApiV1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetRequest) (*V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringProducerIdMatchingCustomersSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/producer/{id}/matching-customers-summary"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPeeringProducerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bPeeringProducerPostRequest *V1ExtranetsB2bPeeringProducerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPeeringProducerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bPeeringProducerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPeeringProducerPostRequest) V1ExtranetsB2bPeeringProducerPostRequest(v1ExtranetsB2bPeeringProducerPostRequest V1ExtranetsB2bPeeringProducerPostRequest) ApiV1ExtranetsB2bPeeringProducerPostRequest {
	r.v1ExtranetsB2bPeeringProducerPostRequest = &v1ExtranetsB2bPeeringProducerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bPeeringProducerPostRequest) Execute() (*V1ExtranetsB2bPeeringProducerPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPeeringProducerPostExecute(r)
}

/*
V1ExtranetsB2bPeeringProducerPost Method for V1ExtranetsB2bPeeringProducerPost

Create a new B2B extranet peering service producer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bPeeringProducerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPeeringProducerPost(ctx context.Context) ApiV1ExtranetsB2bPeeringProducerPostRequest {
	return ApiV1ExtranetsB2bPeeringProducerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPeeringProducerPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bPeeringProducerPostExecute(r ApiV1ExtranetsB2bPeeringProducerPostRequest) (*V1ExtranetsB2bPeeringProducerPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPeeringProducerPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPeeringProducerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b-peering/producer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bPeeringProducerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bPeeringProducerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bPeeringProducerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bPostRequest *V1ExtranetsB2bPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPostRequest) V1ExtranetsB2bPostRequest(v1ExtranetsB2bPostRequest V1ExtranetsB2bPostRequest) ApiV1ExtranetsB2bPostRequest {
	r.v1ExtranetsB2bPostRequest = &v1ExtranetsB2bPostRequest
	return r
}

func (r ApiV1ExtranetsB2bPostRequest) Execute() (*V1ExtranetsB2bPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPostExecute(r)
}

/*
V1ExtranetsB2bPost Method for V1ExtranetsB2bPost

Create a new B2B extranet producer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPost(ctx context.Context) ApiV1ExtranetsB2bPostRequest {
	return ApiV1ExtranetsB2bPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPostResponse
func (a *DefaultAPIService) V1ExtranetsB2bPostExecute(r ApiV1ExtranetsB2bPostRequest) (*V1ExtranetsB2bPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest) Execute() (*V1ExtranetsB2bProducerDeviceStatusIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bProducerDeviceStatusIdGetExecute(r)
}

/*
V1ExtranetsB2bProducerDeviceStatusIdGet Method for V1ExtranetsB2bProducerDeviceStatusIdGet

Get B2B extranet producer status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bProducerDeviceStatusIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest {
	return ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bProducerDeviceStatusIdGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bProducerDeviceStatusIdGetExecute(r ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest) (*V1ExtranetsB2bProducerDeviceStatusIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bProducerDeviceStatusIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bProducerDeviceStatusIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/producer-device-status/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bProducersSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bProducersSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bProducersSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bProducersSummaryGetRequest) Execute() (*V1ExtranetsB2bProducersSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bProducersSummaryGetExecute(r)
}

/*
V1ExtranetsB2bProducersSummaryGet Method for V1ExtranetsB2bProducersSummaryGet

Get B2B extranet producers summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bProducersSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bProducersSummaryGet(ctx context.Context) ApiV1ExtranetsB2bProducersSummaryGetRequest {
	return ApiV1ExtranetsB2bProducersSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bProducersSummaryGetResponse
func (a *DefaultAPIService) V1ExtranetsB2bProducersSummaryGetExecute(r ApiV1ExtranetsB2bProducersSummaryGetRequest) (*V1ExtranetsB2bProducersSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bProducersSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bProducersSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/producers-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsGetRequest) Authorization(authorization string) ApiV1ExtranetsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsGetRequest) Execute() (*V1ExtranetsGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsGetExecute(r)
}

/*
V1ExtranetsGet Method for V1ExtranetsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsGet(ctx context.Context) ApiV1ExtranetsGetRequest {
	return ApiV1ExtranetsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsGetResponse
func (a *DefaultAPIService) V1ExtranetsGetExecute(r ApiV1ExtranetsGetRequest) (*V1ExtranetsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdApplyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsIdApplyPostRequest *V1ExtranetsIdApplyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdApplyPostRequest) Authorization(authorization string) ApiV1ExtranetsIdApplyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdApplyPostRequest) V1ExtranetsIdApplyPostRequest(v1ExtranetsIdApplyPostRequest V1ExtranetsIdApplyPostRequest) ApiV1ExtranetsIdApplyPostRequest {
	r.v1ExtranetsIdApplyPostRequest = &v1ExtranetsIdApplyPostRequest
	return r
}

func (r ApiV1ExtranetsIdApplyPostRequest) Execute() (*V1ExtranetsIdApplyPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdApplyPostExecute(r)
}

/*
V1ExtranetsIdApplyPost Method for V1ExtranetsIdApplyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdApplyPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdApplyPost(ctx context.Context, id int64) ApiV1ExtranetsIdApplyPostRequest {
	return ApiV1ExtranetsIdApplyPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdApplyPostResponse
func (a *DefaultAPIService) V1ExtranetsIdApplyPostExecute(r ApiV1ExtranetsIdApplyPostRequest) (*V1ExtranetsIdApplyPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdApplyPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdApplyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsIdApplyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsIdApplyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsIdApplyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdDeleteRequest) Execute() (*V1ExtranetsIdDeleteResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdDeleteExecute(r)
}

/*
V1ExtranetsIdDelete Method for V1ExtranetsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdDelete(ctx context.Context, id int64) ApiV1ExtranetsIdDeleteRequest {
	return ApiV1ExtranetsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdDeleteResponse
func (a *DefaultAPIService) V1ExtranetsIdDeleteExecute(r ApiV1ExtranetsIdDeleteRequest) (*V1ExtranetsIdDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdGetRequest) Authorization(authorization string) ApiV1ExtranetsIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdGetRequest) Execute() (*V1ExtranetsIdGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdGetExecute(r)
}

/*
V1ExtranetsIdGet Method for V1ExtranetsIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdGet(ctx context.Context, id int64) ApiV1ExtranetsIdGetRequest {
	return ApiV1ExtranetsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdGetResponse
func (a *DefaultAPIService) V1ExtranetsIdGetExecute(r ApiV1ExtranetsIdGetRequest) (*V1ExtranetsIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsIdPutRequest *V1ExtranetsIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdPutRequest) Authorization(authorization string) ApiV1ExtranetsIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdPutRequest) V1ExtranetsIdPutRequest(v1ExtranetsIdPutRequest V1ExtranetsIdPutRequest) ApiV1ExtranetsIdPutRequest {
	r.v1ExtranetsIdPutRequest = &v1ExtranetsIdPutRequest
	return r
}

func (r ApiV1ExtranetsIdPutRequest) Execute() (*V1ExtranetsIdPutResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdPutExecute(r)
}

/*
V1ExtranetsIdPut Method for V1ExtranetsIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdPutRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdPut(ctx context.Context, id int64) ApiV1ExtranetsIdPutRequest {
	return ApiV1ExtranetsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdPutResponse
func (a *DefaultAPIService) V1ExtranetsIdPutExecute(r ApiV1ExtranetsIdPutRequest) (*V1ExtranetsIdPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdStatusGetRequest) Authorization(authorization string) ApiV1ExtranetsIdStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdStatusGetRequest) Execute() (*V1ExtranetsIdStatusGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdStatusGetExecute(r)
}

/*
V1ExtranetsIdStatusGet Method for V1ExtranetsIdStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdStatusGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdStatusGet(ctx context.Context, id int64) ApiV1ExtranetsIdStatusGetRequest {
	return ApiV1ExtranetsIdStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdStatusGetResponse
func (a *DefaultAPIService) V1ExtranetsIdStatusGetExecute(r ApiV1ExtranetsIdStatusGetRequest) (*V1ExtranetsIdStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsMonitoringLanSegmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsMonitoringLanSegmentsGetRequest) Authorization(authorization string) ApiV1ExtranetsMonitoringLanSegmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsMonitoringLanSegmentsGetRequest) Execute() (*V1ExtranetsMonitoringLanSegmentsGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsMonitoringLanSegmentsGetExecute(r)
}

/*
V1ExtranetsMonitoringLanSegmentsGet Method for V1ExtranetsMonitoringLanSegmentsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsMonitoringLanSegmentsGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsMonitoringLanSegmentsGet(ctx context.Context) ApiV1ExtranetsMonitoringLanSegmentsGetRequest {
	return ApiV1ExtranetsMonitoringLanSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsMonitoringLanSegmentsGetResponse
func (a *DefaultAPIService) V1ExtranetsMonitoringLanSegmentsGetExecute(r ApiV1ExtranetsMonitoringLanSegmentsGetRequest) (*V1ExtranetsMonitoringLanSegmentsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsMonitoringLanSegmentsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsMonitoringLanSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-monitoring/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsMonitoringNatUsageGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsMonitoringNatUsageGetRequest) Authorization(authorization string) ApiV1ExtranetsMonitoringNatUsageGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsMonitoringNatUsageGetRequest) Execute() (*V1ExtranetsMonitoringNatUsageGetResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsMonitoringNatUsageGetExecute(r)
}

/*
V1ExtranetsMonitoringNatUsageGet Method for V1ExtranetsMonitoringNatUsageGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsMonitoringNatUsageGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsMonitoringNatUsageGet(ctx context.Context) ApiV1ExtranetsMonitoringNatUsageGetRequest {
	return ApiV1ExtranetsMonitoringNatUsageGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsMonitoringNatUsageGetResponse
func (a *DefaultAPIService) V1ExtranetsMonitoringNatUsageGetExecute(r ApiV1ExtranetsMonitoringNatUsageGetRequest) (*V1ExtranetsMonitoringNatUsageGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsMonitoringNatUsageGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsMonitoringNatUsageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-monitoring/nat-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest *V1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) Authorization(authorization string) ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) V1ExtranetsMonitoringTrafficSecurityPolicyPostRequest(v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest V1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest {
	r.v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest = &v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
	return r
}

func (r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) Execute() (*V1ExtranetsMonitoringTrafficSecurityPolicyPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsMonitoringTrafficSecurityPolicyPostExecute(r)
}

/*
V1ExtranetsMonitoringTrafficSecurityPolicyPost Method for V1ExtranetsMonitoringTrafficSecurityPolicyPost

Get lists of traffic and security policies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsMonitoringTrafficSecurityPolicyPost(ctx context.Context) ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest {
	return ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsMonitoringTrafficSecurityPolicyPostResponse
func (a *DefaultAPIService) V1ExtranetsMonitoringTrafficSecurityPolicyPostExecute(r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) (*V1ExtranetsMonitoringTrafficSecurityPolicyPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsMonitoringTrafficSecurityPolicyPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsMonitoringTrafficSecurityPolicyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-monitoring/traffic-security-policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsPostRequest *V1ExtranetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsPostRequest) Authorization(authorization string) ApiV1ExtranetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsPostRequest) V1ExtranetsPostRequest(v1ExtranetsPostRequest V1ExtranetsPostRequest) ApiV1ExtranetsPostRequest {
	r.v1ExtranetsPostRequest = &v1ExtranetsPostRequest
	return r
}

func (r ApiV1ExtranetsPostRequest) Execute() (*V1ExtranetsPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsPostExecute(r)
}

/*
V1ExtranetsPost Method for V1ExtranetsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsPost(ctx context.Context) ApiV1ExtranetsPostRequest {
	return ApiV1ExtranetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsPostResponse
func (a *DefaultAPIService) V1ExtranetsPostExecute(r ApiV1ExtranetsPostRequest) (*V1ExtranetsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsResolvePolicyTargetPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsResolvePolicyTargetPostRequest *V1ExtranetsResolvePolicyTargetPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsResolvePolicyTargetPostRequest) Authorization(authorization string) ApiV1ExtranetsResolvePolicyTargetPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsResolvePolicyTargetPostRequest) V1ExtranetsResolvePolicyTargetPostRequest(v1ExtranetsResolvePolicyTargetPostRequest V1ExtranetsResolvePolicyTargetPostRequest) ApiV1ExtranetsResolvePolicyTargetPostRequest {
	r.v1ExtranetsResolvePolicyTargetPostRequest = &v1ExtranetsResolvePolicyTargetPostRequest
	return r
}

func (r ApiV1ExtranetsResolvePolicyTargetPostRequest) Execute() (*V1ExtranetsResolvePolicyTargetPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsResolvePolicyTargetPostExecute(r)
}

/*
V1ExtranetsResolvePolicyTargetPost Method for V1ExtranetsResolvePolicyTargetPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsResolvePolicyTargetPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsResolvePolicyTargetPost(ctx context.Context) ApiV1ExtranetsResolvePolicyTargetPostRequest {
	return ApiV1ExtranetsResolvePolicyTargetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsResolvePolicyTargetPostResponse
func (a *DefaultAPIService) V1ExtranetsResolvePolicyTargetPostExecute(r ApiV1ExtranetsResolvePolicyTargetPostRequest) (*V1ExtranetsResolvePolicyTargetPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsResolvePolicyTargetPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsResolvePolicyTargetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/resolve-policy-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsResolvePolicyTargetPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsResolvePolicyTargetPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsResolvePolicyTargetPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsSourceSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsSourceSegmentsPostRequest *V1ExtranetsSourceSegmentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsSourceSegmentsPostRequest) Authorization(authorization string) ApiV1ExtranetsSourceSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsSourceSegmentsPostRequest) V1ExtranetsSourceSegmentsPostRequest(v1ExtranetsSourceSegmentsPostRequest V1ExtranetsSourceSegmentsPostRequest) ApiV1ExtranetsSourceSegmentsPostRequest {
	r.v1ExtranetsSourceSegmentsPostRequest = &v1ExtranetsSourceSegmentsPostRequest
	return r
}

func (r ApiV1ExtranetsSourceSegmentsPostRequest) Execute() (*V1ExtranetsSourceSegmentsPostResponse, *http.Response, error) {
	return r.ApiService.V1ExtranetsSourceSegmentsPostExecute(r)
}

/*
V1ExtranetsSourceSegmentsPost Method for V1ExtranetsSourceSegmentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsSourceSegmentsPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsSourceSegmentsPost(ctx context.Context) ApiV1ExtranetsSourceSegmentsPostRequest {
	return ApiV1ExtranetsSourceSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsSourceSegmentsPostResponse
func (a *DefaultAPIService) V1ExtranetsSourceSegmentsPostExecute(r ApiV1ExtranetsSourceSegmentsPostRequest) (*V1ExtranetsSourceSegmentsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsSourceSegmentsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsSourceSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/source-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsSourceSegmentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsSourceSegmentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsSourceSegmentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1FlowsFlowTablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1FlowsFlowTablePostRequest *V1FlowsFlowTablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1FlowsFlowTablePostRequest) Authorization(authorization string) ApiV1FlowsFlowTablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1FlowsFlowTablePostRequest) V1FlowsFlowTablePostRequest(v1FlowsFlowTablePostRequest V1FlowsFlowTablePostRequest) ApiV1FlowsFlowTablePostRequest {
	r.v1FlowsFlowTablePostRequest = &v1FlowsFlowTablePostRequest
	return r
}

func (r ApiV1FlowsFlowTablePostRequest) Execute() (*V1FlowsFlowTablePostResponse, *http.Response, error) {
	return r.ApiService.V1FlowsFlowTablePostExecute(r)
}

/*
V1FlowsFlowTablePost Method for V1FlowsFlowTablePost

Get flow table for the app on the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1FlowsFlowTablePostRequest
*/
func (a *DefaultAPIService) V1FlowsFlowTablePost(ctx context.Context) ApiV1FlowsFlowTablePostRequest {
	return ApiV1FlowsFlowTablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1FlowsFlowTablePostResponse
func (a *DefaultAPIService) V1FlowsFlowTablePostExecute(r ApiV1FlowsFlowTablePostRequest) (*V1FlowsFlowTablePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1FlowsFlowTablePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1FlowsFlowTablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/flows/flow-table"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1FlowsFlowTablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1FlowsFlowTablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1FlowsFlowTablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1FlowsTopologyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1FlowsTopologyPostRequest *V1FlowsTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1FlowsTopologyPostRequest) Authorization(authorization string) ApiV1FlowsTopologyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1FlowsTopologyPostRequest) V1FlowsTopologyPostRequest(v1FlowsTopologyPostRequest V1FlowsTopologyPostRequest) ApiV1FlowsTopologyPostRequest {
	r.v1FlowsTopologyPostRequest = &v1FlowsTopologyPostRequest
	return r
}

func (r ApiV1FlowsTopologyPostRequest) Execute() (*V1FlowsTopologyPostResponse, *http.Response, error) {
	return r.ApiService.V1FlowsTopologyPostExecute(r)
}

/*
V1FlowsTopologyPost Method for V1FlowsTopologyPost

Get flow based node and circuit topology for the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1FlowsTopologyPostRequest
*/
func (a *DefaultAPIService) V1FlowsTopologyPost(ctx context.Context) ApiV1FlowsTopologyPostRequest {
	return ApiV1FlowsTopologyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1FlowsTopologyPostResponse
func (a *DefaultAPIService) V1FlowsTopologyPostExecute(r ApiV1FlowsTopologyPostRequest) (*V1FlowsTopologyPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1FlowsTopologyPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1FlowsTopologyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/flows/topology"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1FlowsTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1FlowsTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1FlowsTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysDeleteRequest) Authorization(authorization string) ApiV1GatewaysDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1GatewaysDeleteRequest) Id(id int64) ApiV1GatewaysDeleteRequest {
	r.id = &id
	return r
}

func (r ApiV1GatewaysDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GatewaysDeleteExecute(r)
}

/*
V1GatewaysDelete Method for V1GatewaysDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysDeleteRequest
*/
func (a *DefaultAPIService) V1GatewaysDelete(ctx context.Context) ApiV1GatewaysDeleteRequest {
	return ApiV1GatewaysDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GatewaysDeleteExecute(r ApiV1GatewaysDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysGuestConsumerMatchIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	matchId int64
	email *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysGuestConsumerMatchIdGetRequest) Authorization(authorization string) ApiV1GatewaysGuestConsumerMatchIdGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1GatewaysGuestConsumerMatchIdGetRequest) Email(email string) ApiV1GatewaysGuestConsumerMatchIdGetRequest {
	r.email = &email
	return r
}

func (r ApiV1GatewaysGuestConsumerMatchIdGetRequest) Execute() (*V1GatewaysGuestConsumerMatchIdGetResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysGuestConsumerMatchIdGetExecute(r)
}

/*
V1GatewaysGuestConsumerMatchIdGet Method for V1GatewaysGuestConsumerMatchIdGet

Get Site to Site VPN information for a non-Graphiant guest consumer by their email

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId 
 @return ApiV1GatewaysGuestConsumerMatchIdGetRequest
*/
func (a *DefaultAPIService) V1GatewaysGuestConsumerMatchIdGet(ctx context.Context, matchId int64) ApiV1GatewaysGuestConsumerMatchIdGetRequest {
	return ApiV1GatewaysGuestConsumerMatchIdGetRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
//  @return V1GatewaysGuestConsumerMatchIdGetResponse
func (a *DefaultAPIService) V1GatewaysGuestConsumerMatchIdGetExecute(r ApiV1GatewaysGuestConsumerMatchIdGetRequest) (*V1GatewaysGuestConsumerMatchIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysGuestConsumerMatchIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysGuestConsumerMatchIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/guest-consumer/{matchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"matchId"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysIdDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysIdDetailsGetRequest) Authorization(authorization string) ApiV1GatewaysIdDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysIdDetailsGetRequest) Execute() (*V1GatewaysIdDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysIdDetailsGetExecute(r)
}

/*
V1GatewaysIdDetailsGet Method for V1GatewaysIdDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GatewaysIdDetailsGetRequest
*/
func (a *DefaultAPIService) V1GatewaysIdDetailsGet(ctx context.Context, id int64) ApiV1GatewaysIdDetailsGetRequest {
	return ApiV1GatewaysIdDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GatewaysIdDetailsGetResponse
func (a *DefaultAPIService) V1GatewaysIdDetailsGetExecute(r ApiV1GatewaysIdDetailsGetRequest) (*V1GatewaysIdDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysIdDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysIdDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/{id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	regionId int32
	vrfId int64
	addressFamily *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) Authorization(authorization string) ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) AddressFamily(addressFamily string) ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest {
	r.addressFamily = &addressFamily
	return r
}

func (r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) Execute() (*V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetExecute(r)
}

/*
V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet Method for V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet

Get the IPv4/Ipv6 Overlay Subnet for an ipsec gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId 
 @param vrfId 
 @return ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest
*/
func (a *DefaultAPIService) V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet(ctx context.Context, regionId int32, vrfId int64) ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest {
	return ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
		vrfId: vrfId,
	}
}

// Execute executes the request
//  @return V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetResponse
func (a *DefaultAPIService) V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetExecute(r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) (*V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/ipsec/regions/{regionId}/vrfs/{vrfId}/inside-subnet"
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vrfId"+"}", url.PathEscape(parameterValueToString(r.vrfId, "vrfId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.addressFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressFamily", r.addressFamily, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GatewaysPostRequest *V1GatewaysPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysPostRequest) Authorization(authorization string) ApiV1GatewaysPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysPostRequest) V1GatewaysPostRequest(v1GatewaysPostRequest V1GatewaysPostRequest) ApiV1GatewaysPostRequest {
	r.v1GatewaysPostRequest = &v1GatewaysPostRequest
	return r
}

func (r ApiV1GatewaysPostRequest) Execute() (*V1GatewaysPostResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysPostExecute(r)
}

/*
V1GatewaysPost Method for V1GatewaysPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysPostRequest
*/
func (a *DefaultAPIService) V1GatewaysPost(ctx context.Context) ApiV1GatewaysPostRequest {
	return ApiV1GatewaysPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysPostResponse
func (a *DefaultAPIService) V1GatewaysPostExecute(r ApiV1GatewaysPostRequest) (*V1GatewaysPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GatewaysPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GatewaysPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GatewaysPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GatewaysPutRequest *V1GatewaysPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysPutRequest) Authorization(authorization string) ApiV1GatewaysPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysPutRequest) V1GatewaysPutRequest(v1GatewaysPutRequest V1GatewaysPutRequest) ApiV1GatewaysPutRequest {
	r.v1GatewaysPutRequest = &v1GatewaysPutRequest
	return r
}

func (r ApiV1GatewaysPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GatewaysPutExecute(r)
}

/*
V1GatewaysPut Method for V1GatewaysPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysPutRequest
*/
func (a *DefaultAPIService) V1GatewaysPut(ctx context.Context) ApiV1GatewaysPutRequest {
	return ApiV1GatewaysPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GatewaysPutExecute(r ApiV1GatewaysPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GatewaysPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1GatewaysPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GatewaysPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysReferenceConsumerGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysReferenceConsumerGetRequest) Authorization(authorization string) ApiV1GatewaysReferenceConsumerGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysReferenceConsumerGetRequest) Execute() (*V1GatewaysReferenceConsumerGetResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysReferenceConsumerGetExecute(r)
}

/*
V1GatewaysReferenceConsumerGet Method for V1GatewaysReferenceConsumerGet

Get the priorly-configured IPSec gateway details for a customer, lan segment, region combination to be re-used for any new service matches for that customer with the given lan segment and region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysReferenceConsumerGetRequest
*/
func (a *DefaultAPIService) V1GatewaysReferenceConsumerGet(ctx context.Context) ApiV1GatewaysReferenceConsumerGetRequest {
	return ApiV1GatewaysReferenceConsumerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysReferenceConsumerGetResponse
func (a *DefaultAPIService) V1GatewaysReferenceConsumerGetExecute(r ApiV1GatewaysReferenceConsumerGetRequest) (*V1GatewaysReferenceConsumerGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysReferenceConsumerGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysReferenceConsumerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/reference-consumer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysRegionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysRegionsGetRequest) Authorization(authorization string) ApiV1GatewaysRegionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysRegionsGetRequest) Execute() (*V1GatewaysRegionsGetResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysRegionsGetExecute(r)
}

/*
V1GatewaysRegionsGet Method for V1GatewaysRegionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysRegionsGetRequest
*/
func (a *DefaultAPIService) V1GatewaysRegionsGet(ctx context.Context) ApiV1GatewaysRegionsGetRequest {
	return ApiV1GatewaysRegionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysRegionsGetResponse
func (a *DefaultAPIService) V1GatewaysRegionsGetExecute(r ApiV1GatewaysRegionsGetRequest) (*V1GatewaysRegionsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysRegionsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysRegionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysStatusPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GatewaysStatusPostRequest *V1GatewaysStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysStatusPostRequest) Authorization(authorization string) ApiV1GatewaysStatusPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysStatusPostRequest) V1GatewaysStatusPostRequest(v1GatewaysStatusPostRequest V1GatewaysStatusPostRequest) ApiV1GatewaysStatusPostRequest {
	r.v1GatewaysStatusPostRequest = &v1GatewaysStatusPostRequest
	return r
}

func (r ApiV1GatewaysStatusPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GatewaysStatusPostExecute(r)
}

/*
V1GatewaysStatusPost Method for V1GatewaysStatusPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysStatusPostRequest
*/
func (a *DefaultAPIService) V1GatewaysStatusPost(ctx context.Context) ApiV1GatewaysStatusPostRequest {
	return ApiV1GatewaysStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GatewaysStatusPostExecute(r ApiV1GatewaysStatusPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GatewaysStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GatewaysStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GatewaysStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysSummaryGetRequest) Authorization(authorization string) ApiV1GatewaysSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysSummaryGetRequest) Execute() (*V1GatewaysSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1GatewaysSummaryGetExecute(r)
}

/*
V1GatewaysSummaryGet Method for V1GatewaysSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysSummaryGetRequest
*/
func (a *DefaultAPIService) V1GatewaysSummaryGet(ctx context.Context) ApiV1GatewaysSummaryGetRequest {
	return ApiV1GatewaysSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysSummaryGetResponse
func (a *DefaultAPIService) V1GatewaysSummaryGetExecute(r ApiV1GatewaysSummaryGetRequest) (*V1GatewaysSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListOptionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListOptionsGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListOptionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListOptionsGetRequest) Execute() (*V1GlobalAppsAppListOptionsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListOptionsGetExecute(r)
}

/*
V1GlobalAppsAppListOptionsGet Method for V1GlobalAppsAppListOptionsGet

Gets all apps and categories assignable to an app list for the the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsAppListOptionsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListOptionsGet(ctx context.Context) ApiV1GlobalAppsAppListOptionsGetRequest {
	return ApiV1GlobalAppsAppListOptionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListOptionsGetResponse
func (a *DefaultAPIService) V1GlobalAppsAppListOptionsGetExecute(r ApiV1GlobalAppsAppListOptionsGetRequest) (*V1GlobalAppsAppListOptionsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListOptionsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListOptionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-list-options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdDeleteRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdDeleteExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdDelete Method for V1GlobalAppsAppListsAppListIdDelete

Delete an app list under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDelete(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdDeleteRequest {
	return ApiV1GlobalAppsAppListsAppListIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDeleteExecute(r ApiV1GlobalAppsAppListsAppListIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest) Execute() (*V1GlobalAppsAppListsAppListIdDetailsAppsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdDetailsAppsGetExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdDetailsAppsGet Method for V1GlobalAppsAppListsAppListIdDetailsAppsGet

Get all apps that are members of the provided app list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDetailsAppsGet(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest {
	return ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsAppListIdDetailsAppsGetResponse
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDetailsAppsGetExecute(r ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest) (*V1GlobalAppsAppListsAppListIdDetailsAppsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsAppListIdDetailsAppsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdDetailsAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}/details/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdGetRequest) Execute() (*V1GlobalAppsAppListsAppListIdGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdGetExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdGet Method for V1GlobalAppsAppListsAppListIdGet

Get the configuration for an app list under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdGet(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdGetRequest {
	return ApiV1GlobalAppsAppListsAppListIdGetRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsAppListIdGetResponse
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdGetExecute(r ApiV1GlobalAppsAppListsAppListIdGetRequest) (*V1GlobalAppsAppListsAppListIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsAppListIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
	v1GlobalAppsAppListsAppListIdPutRequest *V1GlobalAppsAppListsAppListIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdPutRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdPutRequest) V1GlobalAppsAppListsAppListIdPutRequest(v1GlobalAppsAppListsAppListIdPutRequest V1GlobalAppsAppListsAppListIdPutRequest) ApiV1GlobalAppsAppListsAppListIdPutRequest {
	r.v1GlobalAppsAppListsAppListIdPutRequest = &v1GlobalAppsAppListsAppListIdPutRequest
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdPutExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdPut Method for V1GlobalAppsAppListsAppListIdPut

Overwrite the configuration for an app list under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdPutRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdPut(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdPutRequest {
	return ApiV1GlobalAppsAppListsAppListIdPutRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdPutExecute(r ApiV1GlobalAppsAppListsAppListIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsAppListsAppListIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsAppListsAppListIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsAppListsAppListIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsGetRequest) Execute() (*V1GlobalAppsAppListsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsGetExecute(r)
}

/*
V1GlobalAppsAppListsGet Method for V1GlobalAppsAppListsGet

Get all app lists for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsAppListsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsGet(ctx context.Context) ApiV1GlobalAppsAppListsGetRequest {
	return ApiV1GlobalAppsAppListsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsGetResponse
func (a *DefaultAPIService) V1GlobalAppsAppListsGetExecute(r ApiV1GlobalAppsAppListsGetRequest) (*V1GlobalAppsAppListsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalAppsAppListsPostRequest *V1GlobalAppsAppListsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsPostRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsPostRequest) V1GlobalAppsAppListsPostRequest(v1GlobalAppsAppListsPostRequest V1GlobalAppsAppListsPostRequest) ApiV1GlobalAppsAppListsPostRequest {
	r.v1GlobalAppsAppListsPostRequest = &v1GlobalAppsAppListsPostRequest
	return r
}

func (r ApiV1GlobalAppsAppListsPostRequest) Execute() (*V1GlobalAppsAppListsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsPostExecute(r)
}

/*
V1GlobalAppsAppListsPost Method for V1GlobalAppsAppListsPost

Create an app list under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsAppListsPostRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsPost(ctx context.Context) ApiV1GlobalAppsAppListsPostRequest {
	return ApiV1GlobalAppsAppListsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsPostResponse
func (a *DefaultAPIService) V1GlobalAppsAppListsPostExecute(r ApiV1GlobalAppsAppListsPostRequest) (*V1GlobalAppsAppListsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsAppListsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsAppListsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsAppListsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	categoryId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest) Authorization(authorization string) ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest) Execute() (*V1GlobalAppsCategoriesCategoryIdAppsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCategoriesCategoryIdAppsGetExecute(r)
}

/*
V1GlobalAppsCategoriesCategoryIdAppsGet Method for V1GlobalAppsCategoriesCategoryIdAppsGet

Get all Graphiant apps in an app category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryId 
 @return ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCategoriesCategoryIdAppsGet(ctx context.Context, categoryId int64) ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest {
	return ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest{
		ApiService: a,
		ctx: ctx,
		categoryId: categoryId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCategoriesCategoryIdAppsGetResponse
func (a *DefaultAPIService) V1GlobalAppsCategoriesCategoryIdAppsGetExecute(r ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest) (*V1GlobalAppsCategoriesCategoryIdAppsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCategoriesCategoryIdAppsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCategoriesCategoryIdAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/categories/{categoryId}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryId"+"}", url.PathEscape(parameterValueToString(r.categoryId, "categoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCategoriesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCategoriesGetRequest) Authorization(authorization string) ApiV1GlobalAppsCategoriesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCategoriesGetRequest) Execute() (*V1GlobalAppsCategoriesGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCategoriesGetExecute(r)
}

/*
V1GlobalAppsCategoriesGet Method for V1GlobalAppsCategoriesGet

Get all app categories holding Graphiant apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsCategoriesGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCategoriesGet(ctx context.Context) ApiV1GlobalAppsCategoriesGetRequest {
	return ApiV1GlobalAppsCategoriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCategoriesGetResponse
func (a *DefaultAPIService) V1GlobalAppsCategoriesGetExecute(r ApiV1GlobalAppsCategoriesGetRequest) (*V1GlobalAppsCategoriesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCategoriesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCategoriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdDeleteRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdDeleteExecute(r)
}

/*
V1GlobalAppsCustomAppIdDelete Method for V1GlobalAppsCustomAppIdDelete

Delete a global app under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDelete(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdDeleteRequest {
	return ApiV1GlobalAppsCustomAppIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDeleteExecute(r ApiV1GlobalAppsCustomAppIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest) Execute() (*V1GlobalAppsCustomAppIdDetailsAppListsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdDetailsAppListsGetExecute(r)
}

/*
V1GlobalAppsCustomAppIdDetailsAppListsGet Method for V1GlobalAppsCustomAppIdDetailsAppListsGet

Get all app lists that contain the relevant global app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDetailsAppListsGet(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest {
	return ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomAppIdDetailsAppListsGetResponse
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDetailsAppListsGetExecute(r ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest) (*V1GlobalAppsCustomAppIdDetailsAppListsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomAppIdDetailsAppListsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdDetailsAppListsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}/details/app-lists"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdGetRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdGetRequest) Execute() (*V1GlobalAppsCustomAppIdGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdGetExecute(r)
}

/*
V1GlobalAppsCustomAppIdGet Method for V1GlobalAppsCustomAppIdGet

Get the configuration for a global app under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdGet(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdGetRequest {
	return ApiV1GlobalAppsCustomAppIdGetRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomAppIdGetResponse
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdGetExecute(r ApiV1GlobalAppsCustomAppIdGetRequest) (*V1GlobalAppsCustomAppIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomAppIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
	v1GlobalAppsCustomAppIdPutRequest *V1GlobalAppsCustomAppIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdPutRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdPutRequest) V1GlobalAppsCustomAppIdPutRequest(v1GlobalAppsCustomAppIdPutRequest V1GlobalAppsCustomAppIdPutRequest) ApiV1GlobalAppsCustomAppIdPutRequest {
	r.v1GlobalAppsCustomAppIdPutRequest = &v1GlobalAppsCustomAppIdPutRequest
	return r
}

func (r ApiV1GlobalAppsCustomAppIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdPutExecute(r)
}

/*
V1GlobalAppsCustomAppIdPut Method for V1GlobalAppsCustomAppIdPut

Overwrite the configuration for a global app under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdPutRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdPut(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdPutRequest {
	return ApiV1GlobalAppsCustomAppIdPutRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdPutExecute(r ApiV1GlobalAppsCustomAppIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsCustomAppIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsCustomAppIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsCustomAppIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomGetRequest) Authorization(authorization string) ApiV1GlobalAppsCustomGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomGetRequest) Execute() (*V1GlobalAppsCustomGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomGetExecute(r)
}

/*
V1GlobalAppsCustomGet Method for V1GlobalAppsCustomGet

Get all global apps mapped by the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsCustomGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomGet(ctx context.Context) ApiV1GlobalAppsCustomGetRequest {
	return ApiV1GlobalAppsCustomGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomGetResponse
func (a *DefaultAPIService) V1GlobalAppsCustomGetExecute(r ApiV1GlobalAppsCustomGetRequest) (*V1GlobalAppsCustomGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalAppsCustomPostRequest *V1GlobalAppsCustomPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomPostRequest) Authorization(authorization string) ApiV1GlobalAppsCustomPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomPostRequest) V1GlobalAppsCustomPostRequest(v1GlobalAppsCustomPostRequest V1GlobalAppsCustomPostRequest) ApiV1GlobalAppsCustomPostRequest {
	r.v1GlobalAppsCustomPostRequest = &v1GlobalAppsCustomPostRequest
	return r
}

func (r ApiV1GlobalAppsCustomPostRequest) Execute() (*V1GlobalAppsCustomPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomPostExecute(r)
}

/*
V1GlobalAppsCustomPost Method for V1GlobalAppsCustomPost

Create a new global app under the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsCustomPostRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomPost(ctx context.Context) ApiV1GlobalAppsCustomPostRequest {
	return ApiV1GlobalAppsCustomPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomPostResponse
func (a *DefaultAPIService) V1GlobalAppsCustomPostExecute(r ApiV1GlobalAppsCustomPostRequest) (*V1GlobalAppsCustomPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsCustomPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsCustomPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsCustomPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsGraphiantGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsGraphiantGetRequest) Authorization(authorization string) ApiV1GlobalAppsGraphiantGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsGraphiantGetRequest) Execute() (*V1GlobalAppsGraphiantGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAppsGraphiantGetExecute(r)
}

/*
V1GlobalAppsGraphiantGet Method for V1GlobalAppsGraphiantGet

Get all apps mapped by Graphiant

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsGraphiantGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsGraphiantGet(ctx context.Context) ApiV1GlobalAppsGraphiantGetRequest {
	return ApiV1GlobalAppsGraphiantGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsGraphiantGetResponse
func (a *DefaultAPIService) V1GlobalAppsGraphiantGetExecute(r ApiV1GlobalAppsGraphiantGetRequest) (*V1GlobalAppsGraphiantGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsGraphiantGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsGraphiantGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/graphiant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAttachedEdgesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalAttachedEdgesPostRequest *V1GlobalAttachedEdgesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAttachedEdgesPostRequest) Authorization(authorization string) ApiV1GlobalAttachedEdgesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAttachedEdgesPostRequest) V1GlobalAttachedEdgesPostRequest(v1GlobalAttachedEdgesPostRequest V1GlobalAttachedEdgesPostRequest) ApiV1GlobalAttachedEdgesPostRequest {
	r.v1GlobalAttachedEdgesPostRequest = &v1GlobalAttachedEdgesPostRequest
	return r
}

func (r ApiV1GlobalAttachedEdgesPostRequest) Execute() (*V1GlobalAttachedEdgesPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalAttachedEdgesPostExecute(r)
}

/*
V1GlobalAttachedEdgesPost Method for V1GlobalAttachedEdgesPost

Returns attached edges for global object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAttachedEdgesPostRequest
*/
func (a *DefaultAPIService) V1GlobalAttachedEdgesPost(ctx context.Context) ApiV1GlobalAttachedEdgesPostRequest {
	return ApiV1GlobalAttachedEdgesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAttachedEdgesPostResponse
func (a *DefaultAPIService) V1GlobalAttachedEdgesPostExecute(r ApiV1GlobalAttachedEdgesPostRequest) (*V1GlobalAttachedEdgesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAttachedEdgesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAttachedEdgesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/attached-edges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAttachedEdgesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAttachedEdgesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAttachedEdgesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalConfigPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalConfigPatchRequest *V1GlobalConfigPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalConfigPatchRequest) Authorization(authorization string) ApiV1GlobalConfigPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalConfigPatchRequest) V1GlobalConfigPatchRequest(v1GlobalConfigPatchRequest V1GlobalConfigPatchRequest) ApiV1GlobalConfigPatchRequest {
	r.v1GlobalConfigPatchRequest = &v1GlobalConfigPatchRequest
	return r
}

func (r ApiV1GlobalConfigPatchRequest) Execute() (*V1GlobalConfigPatchResponse, *http.Response, error) {
	return r.ApiService.V1GlobalConfigPatchExecute(r)
}

/*
V1GlobalConfigPatch Method for V1GlobalConfigPatch

Update global objects for an enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalConfigPatchRequest
*/
func (a *DefaultAPIService) V1GlobalConfigPatch(ctx context.Context) ApiV1GlobalConfigPatchRequest {
	return ApiV1GlobalConfigPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalConfigPatchResponse
func (a *DefaultAPIService) V1GlobalConfigPatchExecute(r ApiV1GlobalConfigPatchRequest) (*V1GlobalConfigPatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalConfigPatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalConfigPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalConfigPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalConfigPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalConfigPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalConfigSitePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalConfigSitePostRequest *V1GlobalConfigSitePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalConfigSitePostRequest) Authorization(authorization string) ApiV1GlobalConfigSitePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalConfigSitePostRequest) V1GlobalConfigSitePostRequest(v1GlobalConfigSitePostRequest V1GlobalConfigSitePostRequest) ApiV1GlobalConfigSitePostRequest {
	r.v1GlobalConfigSitePostRequest = &v1GlobalConfigSitePostRequest
	return r
}

func (r ApiV1GlobalConfigSitePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalConfigSitePostExecute(r)
}

/*
V1GlobalConfigSitePost Method for V1GlobalConfigSitePost

Attach or detach global objects from a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalConfigSitePostRequest
*/
func (a *DefaultAPIService) V1GlobalConfigSitePost(ctx context.Context) ApiV1GlobalConfigSitePostRequest {
	return ApiV1GlobalConfigSitePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalConfigSitePostExecute(r ApiV1GlobalConfigSitePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalConfigSitePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/config/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalConfigSitePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalConfigSitePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalConfigSitePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalDeviceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalDeviceStatusGetRequest) Authorization(authorization string) ApiV1GlobalDeviceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalDeviceStatusGetRequest) Execute() (*V1GlobalDeviceStatusGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalDeviceStatusGetExecute(r)
}

/*
V1GlobalDeviceStatusGet Method for V1GlobalDeviceStatusGet

Get status on global collector attached to devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalDeviceStatusGetRequest
*/
func (a *DefaultAPIService) V1GlobalDeviceStatusGet(ctx context.Context) ApiV1GlobalDeviceStatusGetRequest {
	return ApiV1GlobalDeviceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalDeviceStatusGetResponse
func (a *DefaultAPIService) V1GlobalDeviceStatusGetExecute(r ApiV1GlobalDeviceStatusGetRequest) (*V1GlobalDeviceStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalDeviceStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalDeviceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/device-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpfixDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpfixDeviceGetRequest) Authorization(authorization string) ApiV1GlobalIpfixDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpfixDeviceGetRequest) Execute() (*V1GlobalIpfixDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalIpfixDeviceGetExecute(r)
}

/*
V1GlobalIpfixDeviceGet Method for V1GlobalIpfixDeviceGet

Get global ipfix exporters objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpfixDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpfixDeviceGet(ctx context.Context) ApiV1GlobalIpfixDeviceGetRequest {
	return ApiV1GlobalIpfixDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpfixDeviceGetResponse
func (a *DefaultAPIService) V1GlobalIpfixDeviceGetExecute(r ApiV1GlobalIpfixDeviceGetRequest) (*V1GlobalIpfixDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpfixDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpfixDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipfix/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpfixPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpfixPostRequest) Authorization(authorization string) ApiV1GlobalIpfixPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpfixPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalIpfixPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalIpfixPostRequest) Execute() (*V1GlobalIpfixPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalIpfixPostExecute(r)
}

/*
V1GlobalIpfixPost Method for V1GlobalIpfixPost

Get configured global ipfix exporters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpfixPostRequest
*/
func (a *DefaultAPIService) V1GlobalIpfixPost(ctx context.Context) ApiV1GlobalIpfixPostRequest {
	return ApiV1GlobalIpfixPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpfixPostResponse
func (a *DefaultAPIService) V1GlobalIpfixPostExecute(r ApiV1GlobalIpfixPostRequest) (*V1GlobalIpfixPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpfixPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpfixPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipfix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpfixSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpfixSiteGetRequest) Authorization(authorization string) ApiV1GlobalIpfixSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpfixSiteGetRequest) Execute() (*V1GlobalIpfixSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalIpfixSiteGetExecute(r)
}

/*
V1GlobalIpfixSiteGet Method for V1GlobalIpfixSiteGet

Get configured global ipfix exporters for a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpfixSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpfixSiteGet(ctx context.Context) ApiV1GlobalIpfixSiteGetRequest {
	return ApiV1GlobalIpfixSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpfixSiteGetResponse
func (a *DefaultAPIService) V1GlobalIpfixSiteGetExecute(r ApiV1GlobalIpfixSiteGetRequest) (*V1GlobalIpfixSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpfixSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpfixSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipfix/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpsecProfileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpsecProfileGetRequest) Authorization(authorization string) ApiV1GlobalIpsecProfileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpsecProfileGetRequest) Execute() (*V1GlobalIpsecProfileGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalIpsecProfileGetExecute(r)
}

/*
V1GlobalIpsecProfileGet Method for V1GlobalIpsecProfileGet

Get all the configured global IPsec Profiles for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpsecProfileGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpsecProfileGet(ctx context.Context) ApiV1GlobalIpsecProfileGetRequest {
	return ApiV1GlobalIpsecProfileGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpsecProfileGetResponse
func (a *DefaultAPIService) V1GlobalIpsecProfileGetExecute(r ApiV1GlobalIpsecProfileGetRequest) (*V1GlobalIpsecProfileGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpsecProfileGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpsecProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipsec-profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpsecProfileIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpsecProfileIdGetRequest) Authorization(authorization string) ApiV1GlobalIpsecProfileIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpsecProfileIdGetRequest) Execute() (*V1GlobalIpsecProfileIdGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalIpsecProfileIdGetExecute(r)
}

/*
V1GlobalIpsecProfileIdGet Method for V1GlobalIpsecProfileIdGet

Get details of the configured global IPsec Profiles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalIpsecProfileIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpsecProfileIdGet(ctx context.Context, id int64) ApiV1GlobalIpsecProfileIdGetRequest {
	return ApiV1GlobalIpsecProfileIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalIpsecProfileIdGetResponse
func (a *DefaultAPIService) V1GlobalIpsecProfileIdGetExecute(r ApiV1GlobalIpsecProfileIdGetRequest) (*V1GlobalIpsecProfileIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpsecProfileIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpsecProfileIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipsec-profile/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	vpnProfileId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest) Authorization(authorization string) ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest) Execute() (*V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetExecute(r)
}

/*
V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet Method for V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet

Get Site-to-site VPNs that are using the given global IPsec Profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpnProfileId 
 @return ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet(ctx context.Context, vpnProfileId int64) ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest {
	return ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest{
		ApiService: a,
		ctx: ctx,
		vpnProfileId: vpnProfileId,
	}
}

// Execute executes the request
//  @return V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetResponse
func (a *DefaultAPIService) V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetExecute(r ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest) (*V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipsec-profile/{vpnProfileId}/site-to-site"
	localVarPath = strings.Replace(localVarPath, "{"+"vpnProfileId"+"}", url.PathEscape(parameterValueToString(r.vpnProfileId, "vpnProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsGetRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsGetRequest) Execute() (*V1GlobalLanSegmentsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsGetExecute(r)
}

/*
V1GlobalLanSegmentsGet Method for V1GlobalLanSegmentsGet

Get a list of lan-segments under the currently logged in enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalLanSegmentsGetRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsGet(ctx context.Context) ApiV1GlobalLanSegmentsGetRequest {
	return ApiV1GlobalLanSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsGetResponse
func (a *DefaultAPIService) V1GlobalLanSegmentsGetExecute(r ApiV1GlobalLanSegmentsGetRequest) (*V1GlobalLanSegmentsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsIdDeleteRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsIdDeleteExecute(r)
}

/*
V1GlobalLanSegmentsIdDelete Method for V1GlobalLanSegmentsIdDelete

Delete a lan-segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalLanSegmentsIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsIdDelete(ctx context.Context, id int64) ApiV1GlobalLanSegmentsIdDeleteRequest {
	return ApiV1GlobalLanSegmentsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GlobalLanSegmentsIdDeleteExecute(r ApiV1GlobalLanSegmentsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalLanSegmentsPostRequest *V1GlobalLanSegmentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsPostRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsPostRequest) V1GlobalLanSegmentsPostRequest(v1GlobalLanSegmentsPostRequest V1GlobalLanSegmentsPostRequest) ApiV1GlobalLanSegmentsPostRequest {
	r.v1GlobalLanSegmentsPostRequest = &v1GlobalLanSegmentsPostRequest
	return r
}

func (r ApiV1GlobalLanSegmentsPostRequest) Execute() (*V1GlobalLanSegmentsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsPostExecute(r)
}

/*
V1GlobalLanSegmentsPost Method for V1GlobalLanSegmentsPost

Create a new lan-segment scoped to the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalLanSegmentsPostRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsPost(ctx context.Context) ApiV1GlobalLanSegmentsPostRequest {
	return ApiV1GlobalLanSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsPostResponse
func (a *DefaultAPIService) V1GlobalLanSegmentsPostExecute(r ApiV1GlobalLanSegmentsPostRequest) (*V1GlobalLanSegmentsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalLanSegmentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalLanSegmentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalLanSegmentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	vrfId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest) Execute() (*V1GlobalLanSegmentsVrfIdDevicesGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsVrfIdDevicesGetExecute(r)
}

/*
V1GlobalLanSegmentsVrfIdDevicesGet Method for V1GlobalLanSegmentsVrfIdDevicesGet

Get a list of lan-segment devices under the currently logged in enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vrfId 
 @return ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsVrfIdDevicesGet(ctx context.Context, vrfId int64) ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest {
	return ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest{
		ApiService: a,
		ctx: ctx,
		vrfId: vrfId,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsVrfIdDevicesGetResponse
func (a *DefaultAPIService) V1GlobalLanSegmentsVrfIdDevicesGetExecute(r ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest) (*V1GlobalLanSegmentsVrfIdDevicesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsVrfIdDevicesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsVrfIdDevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments/{vrfId}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"vrfId"+"}", url.PathEscape(parameterValueToString(r.vrfId, "vrfId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalNtpsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalNtpsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalNtpsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalNtpsDeviceGetRequest) Execute() (*V1GlobalNtpsDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalNtpsDeviceGetExecute(r)
}

/*
V1GlobalNtpsDeviceGet Method for V1GlobalNtpsDeviceGet

Get global ntp objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalNtpsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalNtpsDeviceGet(ctx context.Context) ApiV1GlobalNtpsDeviceGetRequest {
	return ApiV1GlobalNtpsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalNtpsDeviceGetResponse
func (a *DefaultAPIService) V1GlobalNtpsDeviceGetExecute(r ApiV1GlobalNtpsDeviceGetRequest) (*V1GlobalNtpsDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalNtpsDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalNtpsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ntps/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalNtpsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalNtpsPostRequest *V1GlobalNtpsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalNtpsPostRequest) Authorization(authorization string) ApiV1GlobalNtpsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalNtpsPostRequest) V1GlobalNtpsPostRequest(v1GlobalNtpsPostRequest V1GlobalNtpsPostRequest) ApiV1GlobalNtpsPostRequest {
	r.v1GlobalNtpsPostRequest = &v1GlobalNtpsPostRequest
	return r
}

func (r ApiV1GlobalNtpsPostRequest) Execute() (*V1GlobalNtpsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalNtpsPostExecute(r)
}

/*
V1GlobalNtpsPost Method for V1GlobalNtpsPost

Get configured global ntps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalNtpsPostRequest
*/
func (a *DefaultAPIService) V1GlobalNtpsPost(ctx context.Context) ApiV1GlobalNtpsPostRequest {
	return ApiV1GlobalNtpsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalNtpsPostResponse
func (a *DefaultAPIService) V1GlobalNtpsPostExecute(r ApiV1GlobalNtpsPostRequest) (*V1GlobalNtpsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalNtpsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalNtpsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ntps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalNtpsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalNtpsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalNtpsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalNtpsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalNtpsSiteGetRequest) Authorization(authorization string) ApiV1GlobalNtpsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalNtpsSiteGetRequest) Execute() (*V1GlobalNtpsSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalNtpsSiteGetExecute(r)
}

/*
V1GlobalNtpsSiteGet Method for V1GlobalNtpsSiteGet

Get configured global ntps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalNtpsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalNtpsSiteGet(ctx context.Context) ApiV1GlobalNtpsSiteGetRequest {
	return ApiV1GlobalNtpsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalNtpsSiteGetResponse
func (a *DefaultAPIService) V1GlobalNtpsSiteGetExecute(r ApiV1GlobalNtpsSiteGetRequest) (*V1GlobalNtpsSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalNtpsSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalNtpsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ntps/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalPrefixSetsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalPrefixSetsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalPrefixSetsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalPrefixSetsDeviceGetRequest) Execute() (*V1GlobalPrefixSetsDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalPrefixSetsDeviceGetExecute(r)
}

/*
V1GlobalPrefixSetsDeviceGet Method for V1GlobalPrefixSetsDeviceGet

Get global prefix-set objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalPrefixSetsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalPrefixSetsDeviceGet(ctx context.Context) ApiV1GlobalPrefixSetsDeviceGetRequest {
	return ApiV1GlobalPrefixSetsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalPrefixSetsDeviceGetResponse
func (a *DefaultAPIService) V1GlobalPrefixSetsDeviceGetExecute(r ApiV1GlobalPrefixSetsDeviceGetRequest) (*V1GlobalPrefixSetsDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalPrefixSetsDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalPrefixSetsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/prefix-sets/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalPrefixSetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalPrefixSetsPostRequest *V1GlobalPrefixSetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalPrefixSetsPostRequest) Authorization(authorization string) ApiV1GlobalPrefixSetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalPrefixSetsPostRequest) V1GlobalPrefixSetsPostRequest(v1GlobalPrefixSetsPostRequest V1GlobalPrefixSetsPostRequest) ApiV1GlobalPrefixSetsPostRequest {
	r.v1GlobalPrefixSetsPostRequest = &v1GlobalPrefixSetsPostRequest
	return r
}

func (r ApiV1GlobalPrefixSetsPostRequest) Execute() (*V1GlobalPrefixSetsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalPrefixSetsPostExecute(r)
}

/*
V1GlobalPrefixSetsPost Method for V1GlobalPrefixSetsPost

Get configured global prefix-sets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalPrefixSetsPostRequest
*/
func (a *DefaultAPIService) V1GlobalPrefixSetsPost(ctx context.Context) ApiV1GlobalPrefixSetsPostRequest {
	return ApiV1GlobalPrefixSetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalPrefixSetsPostResponse
func (a *DefaultAPIService) V1GlobalPrefixSetsPostExecute(r ApiV1GlobalPrefixSetsPostRequest) (*V1GlobalPrefixSetsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalPrefixSetsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalPrefixSetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/prefix-sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalPrefixSetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalPrefixSetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalPrefixSetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalPrefixSetsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalPrefixSetsSiteGetRequest) Authorization(authorization string) ApiV1GlobalPrefixSetsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalPrefixSetsSiteGetRequest) Execute() (*V1GlobalPrefixSetsSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalPrefixSetsSiteGetExecute(r)
}

/*
V1GlobalPrefixSetsSiteGet Method for V1GlobalPrefixSetsSiteGet

Get configured global prefix-sets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalPrefixSetsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalPrefixSetsSiteGet(ctx context.Context) ApiV1GlobalPrefixSetsSiteGetRequest {
	return ApiV1GlobalPrefixSetsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalPrefixSetsSiteGetResponse
func (a *DefaultAPIService) V1GlobalPrefixSetsSiteGetExecute(r ApiV1GlobalPrefixSetsSiteGetRequest) (*V1GlobalPrefixSetsSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalPrefixSetsSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalPrefixSetsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/prefix-sets/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalRoutingPoliciesDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalRoutingPoliciesDeviceGetRequest) Authorization(authorization string) ApiV1GlobalRoutingPoliciesDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalRoutingPoliciesDeviceGetRequest) Execute() (*V1GlobalRoutingPoliciesDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalRoutingPoliciesDeviceGetExecute(r)
}

/*
V1GlobalRoutingPoliciesDeviceGet Method for V1GlobalRoutingPoliciesDeviceGet

Get global routing-policy objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalRoutingPoliciesDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalRoutingPoliciesDeviceGet(ctx context.Context) ApiV1GlobalRoutingPoliciesDeviceGetRequest {
	return ApiV1GlobalRoutingPoliciesDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalRoutingPoliciesDeviceGetResponse
func (a *DefaultAPIService) V1GlobalRoutingPoliciesDeviceGetExecute(r ApiV1GlobalRoutingPoliciesDeviceGetRequest) (*V1GlobalRoutingPoliciesDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalRoutingPoliciesDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalRoutingPoliciesDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/routing-policies/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalRoutingPoliciesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalRoutingPoliciesPostRequest *V1GlobalRoutingPoliciesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalRoutingPoliciesPostRequest) Authorization(authorization string) ApiV1GlobalRoutingPoliciesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalRoutingPoliciesPostRequest) V1GlobalRoutingPoliciesPostRequest(v1GlobalRoutingPoliciesPostRequest V1GlobalRoutingPoliciesPostRequest) ApiV1GlobalRoutingPoliciesPostRequest {
	r.v1GlobalRoutingPoliciesPostRequest = &v1GlobalRoutingPoliciesPostRequest
	return r
}

func (r ApiV1GlobalRoutingPoliciesPostRequest) Execute() (*V1GlobalRoutingPoliciesPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalRoutingPoliciesPostExecute(r)
}

/*
V1GlobalRoutingPoliciesPost Method for V1GlobalRoutingPoliciesPost

Get configured global routing-policies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalRoutingPoliciesPostRequest
*/
func (a *DefaultAPIService) V1GlobalRoutingPoliciesPost(ctx context.Context) ApiV1GlobalRoutingPoliciesPostRequest {
	return ApiV1GlobalRoutingPoliciesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalRoutingPoliciesPostResponse
func (a *DefaultAPIService) V1GlobalRoutingPoliciesPostExecute(r ApiV1GlobalRoutingPoliciesPostRequest) (*V1GlobalRoutingPoliciesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalRoutingPoliciesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalRoutingPoliciesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/routing-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalRoutingPoliciesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalRoutingPoliciesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalRoutingPoliciesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalRoutingPoliciesSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalRoutingPoliciesSiteGetRequest) Authorization(authorization string) ApiV1GlobalRoutingPoliciesSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalRoutingPoliciesSiteGetRequest) Execute() (*V1GlobalRoutingPoliciesSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalRoutingPoliciesSiteGetExecute(r)
}

/*
V1GlobalRoutingPoliciesSiteGet Method for V1GlobalRoutingPoliciesSiteGet

Get configured global routing-policies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalRoutingPoliciesSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalRoutingPoliciesSiteGet(ctx context.Context) ApiV1GlobalRoutingPoliciesSiteGetRequest {
	return ApiV1GlobalRoutingPoliciesSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalRoutingPoliciesSiteGetResponse
func (a *DefaultAPIService) V1GlobalRoutingPoliciesSiteGetExecute(r ApiV1GlobalRoutingPoliciesSiteGetRequest) (*V1GlobalRoutingPoliciesSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalRoutingPoliciesSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalRoutingPoliciesSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/routing-policies/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsGetRequest) Authorization(authorization string) ApiV1GlobalSiteListsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsGetRequest) Execute() (*V1GlobalSiteListsGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSiteListsGetExecute(r)
}

/*
V1GlobalSiteListsGet Method for V1GlobalSiteListsGet

Get a list of site lists under the currently logged in enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSiteListsGetRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsGet(ctx context.Context) ApiV1GlobalSiteListsGetRequest {
	return ApiV1GlobalSiteListsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSiteListsGetResponse
func (a *DefaultAPIService) V1GlobalSiteListsGetExecute(r ApiV1GlobalSiteListsGetRequest) (*V1GlobalSiteListsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteListsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsIdDeleteRequest) Authorization(authorization string) ApiV1GlobalSiteListsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GlobalSiteListsIdDeleteExecute(r)
}

/*
V1GlobalSiteListsIdDelete Method for V1GlobalSiteListsIdDelete

Delete a site list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalSiteListsIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsIdDelete(ctx context.Context, id int64) ApiV1GlobalSiteListsIdDeleteRequest {
	return ApiV1GlobalSiteListsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GlobalSiteListsIdDeleteExecute(r ApiV1GlobalSiteListsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsIdGetRequest) Authorization(authorization string) ApiV1GlobalSiteListsIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsIdGetRequest) Execute() (*V1GlobalSiteListsIdGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSiteListsIdGetExecute(r)
}

/*
V1GlobalSiteListsIdGet Method for V1GlobalSiteListsIdGet

Get a details of a site list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalSiteListsIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsIdGet(ctx context.Context, id int64) ApiV1GlobalSiteListsIdGetRequest {
	return ApiV1GlobalSiteListsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalSiteListsIdGetResponse
func (a *DefaultAPIService) V1GlobalSiteListsIdGetExecute(r ApiV1GlobalSiteListsIdGetRequest) (*V1GlobalSiteListsIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteListsIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1GlobalSiteListsIdPutRequest *V1GlobalSiteListsIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsIdPutRequest) Authorization(authorization string) ApiV1GlobalSiteListsIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsIdPutRequest) V1GlobalSiteListsIdPutRequest(v1GlobalSiteListsIdPutRequest V1GlobalSiteListsIdPutRequest) ApiV1GlobalSiteListsIdPutRequest {
	r.v1GlobalSiteListsIdPutRequest = &v1GlobalSiteListsIdPutRequest
	return r
}

func (r ApiV1GlobalSiteListsIdPutRequest) Execute() (*V1GlobalSiteListsIdPutResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSiteListsIdPutExecute(r)
}

/*
V1GlobalSiteListsIdPut Method for V1GlobalSiteListsIdPut

Update a new site list scoped to the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalSiteListsIdPutRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsIdPut(ctx context.Context, id int64) ApiV1GlobalSiteListsIdPutRequest {
	return ApiV1GlobalSiteListsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalSiteListsIdPutResponse
func (a *DefaultAPIService) V1GlobalSiteListsIdPutExecute(r ApiV1GlobalSiteListsIdPutRequest) (*V1GlobalSiteListsIdPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteListsIdPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSiteListsIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSiteListsIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSiteListsIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsIdSitesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsIdSitesGetRequest) Authorization(authorization string) ApiV1GlobalSiteListsIdSitesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsIdSitesGetRequest) Execute() (*V1GlobalSiteListsIdSitesGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSiteListsIdSitesGetExecute(r)
}

/*
V1GlobalSiteListsIdSitesGet Method for V1GlobalSiteListsIdSitesGet

Get a details of a site list sites

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalSiteListsIdSitesGetRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsIdSitesGet(ctx context.Context, id int64) ApiV1GlobalSiteListsIdSitesGetRequest {
	return ApiV1GlobalSiteListsIdSitesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalSiteListsIdSitesGetResponse
func (a *DefaultAPIService) V1GlobalSiteListsIdSitesGetExecute(r ApiV1GlobalSiteListsIdSitesGetRequest) (*V1GlobalSiteListsIdSitesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteListsIdSitesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsIdSitesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists/{id}/sites"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSiteListsPostRequest *V1GlobalSiteListsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsPostRequest) Authorization(authorization string) ApiV1GlobalSiteListsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsPostRequest) V1GlobalSiteListsPostRequest(v1GlobalSiteListsPostRequest V1GlobalSiteListsPostRequest) ApiV1GlobalSiteListsPostRequest {
	r.v1GlobalSiteListsPostRequest = &v1GlobalSiteListsPostRequest
	return r
}

func (r ApiV1GlobalSiteListsPostRequest) Execute() (*V1GlobalSiteListsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSiteListsPostExecute(r)
}

/*
V1GlobalSiteListsPost Method for V1GlobalSiteListsPost

Create a new site list scoped to the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSiteListsPostRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsPost(ctx context.Context) ApiV1GlobalSiteListsPostRequest {
	return ApiV1GlobalSiteListsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSiteListsPostResponse
func (a *DefaultAPIService) V1GlobalSiteListsPostExecute(r ApiV1GlobalSiteListsPostRequest) (*V1GlobalSiteListsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteListsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSiteListsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSiteListsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSiteListsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteStatusGetRequest) Authorization(authorization string) ApiV1GlobalSiteStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteStatusGetRequest) Execute() (*V1GlobalSiteStatusGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSiteStatusGetExecute(r)
}

/*
V1GlobalSiteStatusGet Method for V1GlobalSiteStatusGet

Get status on global objects attached to a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSiteStatusGetRequest
*/
func (a *DefaultAPIService) V1GlobalSiteStatusGet(ctx context.Context) ApiV1GlobalSiteStatusGetRequest {
	return ApiV1GlobalSiteStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSiteStatusGetResponse
func (a *DefaultAPIService) V1GlobalSiteStatusGetExecute(r ApiV1GlobalSiteStatusGetRequest) (*V1GlobalSiteStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSnmpsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSnmpsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalSnmpsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSnmpsDeviceGetRequest) Execute() (*V1GlobalSnmpsDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSnmpsDeviceGetExecute(r)
}

/*
V1GlobalSnmpsDeviceGet Method for V1GlobalSnmpsDeviceGet

Get global snmp objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSnmpsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalSnmpsDeviceGet(ctx context.Context) ApiV1GlobalSnmpsDeviceGetRequest {
	return ApiV1GlobalSnmpsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSnmpsDeviceGetResponse
func (a *DefaultAPIService) V1GlobalSnmpsDeviceGetExecute(r ApiV1GlobalSnmpsDeviceGetRequest) (*V1GlobalSnmpsDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSnmpsDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSnmpsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/snmps/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSnmpsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSnmpsPostRequest *V1GlobalSnmpsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSnmpsPostRequest) Authorization(authorization string) ApiV1GlobalSnmpsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSnmpsPostRequest) V1GlobalSnmpsPostRequest(v1GlobalSnmpsPostRequest V1GlobalSnmpsPostRequest) ApiV1GlobalSnmpsPostRequest {
	r.v1GlobalSnmpsPostRequest = &v1GlobalSnmpsPostRequest
	return r
}

func (r ApiV1GlobalSnmpsPostRequest) Execute() (*V1GlobalSnmpsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSnmpsPostExecute(r)
}

/*
V1GlobalSnmpsPost Method for V1GlobalSnmpsPost

Get configured global snmps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSnmpsPostRequest
*/
func (a *DefaultAPIService) V1GlobalSnmpsPost(ctx context.Context) ApiV1GlobalSnmpsPostRequest {
	return ApiV1GlobalSnmpsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSnmpsPostResponse
func (a *DefaultAPIService) V1GlobalSnmpsPostExecute(r ApiV1GlobalSnmpsPostRequest) (*V1GlobalSnmpsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSnmpsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSnmpsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/snmps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSnmpsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSnmpsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSnmpsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSnmpsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSnmpsSiteGetRequest) Authorization(authorization string) ApiV1GlobalSnmpsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSnmpsSiteGetRequest) Execute() (*V1GlobalSnmpsSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSnmpsSiteGetExecute(r)
}

/*
V1GlobalSnmpsSiteGet Method for V1GlobalSnmpsSiteGet

Get configured global snmps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSnmpsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalSnmpsSiteGet(ctx context.Context) ApiV1GlobalSnmpsSiteGetRequest {
	return ApiV1GlobalSnmpsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSnmpsSiteGetResponse
func (a *DefaultAPIService) V1GlobalSnmpsSiteGetExecute(r ApiV1GlobalSnmpsSiteGetRequest) (*V1GlobalSnmpsSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSnmpsSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSnmpsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/snmps/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSummaryPostRequest *V1GlobalSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSummaryPostRequest) Authorization(authorization string) ApiV1GlobalSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSummaryPostRequest) V1GlobalSummaryPostRequest(v1GlobalSummaryPostRequest V1GlobalSummaryPostRequest) ApiV1GlobalSummaryPostRequest {
	r.v1GlobalSummaryPostRequest = &v1GlobalSummaryPostRequest
	return r
}

func (r ApiV1GlobalSummaryPostRequest) Execute() (*V1GlobalSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSummaryPostExecute(r)
}

/*
V1GlobalSummaryPost Method for V1GlobalSummaryPost

Get summary on global objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSummaryPostRequest
*/
func (a *DefaultAPIService) V1GlobalSummaryPost(ctx context.Context) ApiV1GlobalSummaryPostRequest {
	return ApiV1GlobalSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSummaryPostResponse
func (a *DefaultAPIService) V1GlobalSummaryPostExecute(r ApiV1GlobalSummaryPostRequest) (*V1GlobalSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyncPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSyncPostRequest *V1GlobalSyncPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyncPostRequest) Authorization(authorization string) ApiV1GlobalSyncPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyncPostRequest) V1GlobalSyncPostRequest(v1GlobalSyncPostRequest V1GlobalSyncPostRequest) ApiV1GlobalSyncPostRequest {
	r.v1GlobalSyncPostRequest = &v1GlobalSyncPostRequest
	return r
}

func (r ApiV1GlobalSyncPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalSyncPostExecute(r)
}

/*
V1GlobalSyncPost Method for V1GlobalSyncPost

Tries synching device with the global objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyncPostRequest
*/
func (a *DefaultAPIService) V1GlobalSyncPost(ctx context.Context) ApiV1GlobalSyncPostRequest {
	return ApiV1GlobalSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalSyncPostExecute(r ApiV1GlobalSyncPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyncPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSyncPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSyncPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSyncPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyslogsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyslogsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalSyslogsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyslogsDeviceGetRequest) Execute() (*V1GlobalSyslogsDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSyslogsDeviceGetExecute(r)
}

/*
V1GlobalSyslogsDeviceGet Method for V1GlobalSyslogsDeviceGet

Get global syslog objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyslogsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalSyslogsDeviceGet(ctx context.Context) ApiV1GlobalSyslogsDeviceGetRequest {
	return ApiV1GlobalSyslogsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSyslogsDeviceGetResponse
func (a *DefaultAPIService) V1GlobalSyslogsDeviceGetExecute(r ApiV1GlobalSyslogsDeviceGetRequest) (*V1GlobalSyslogsDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSyslogsDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyslogsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/syslogs/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyslogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSyslogsPostRequest *V1GlobalSyslogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyslogsPostRequest) Authorization(authorization string) ApiV1GlobalSyslogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyslogsPostRequest) V1GlobalSyslogsPostRequest(v1GlobalSyslogsPostRequest V1GlobalSyslogsPostRequest) ApiV1GlobalSyslogsPostRequest {
	r.v1GlobalSyslogsPostRequest = &v1GlobalSyslogsPostRequest
	return r
}

func (r ApiV1GlobalSyslogsPostRequest) Execute() (*V1GlobalSyslogsPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSyslogsPostExecute(r)
}

/*
V1GlobalSyslogsPost Method for V1GlobalSyslogsPost

Get configured global syslog collectors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyslogsPostRequest
*/
func (a *DefaultAPIService) V1GlobalSyslogsPost(ctx context.Context) ApiV1GlobalSyslogsPostRequest {
	return ApiV1GlobalSyslogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSyslogsPostResponse
func (a *DefaultAPIService) V1GlobalSyslogsPostExecute(r ApiV1GlobalSyslogsPostRequest) (*V1GlobalSyslogsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSyslogsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyslogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/syslogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSyslogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSyslogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSyslogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyslogsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyslogsSiteGetRequest) Authorization(authorization string) ApiV1GlobalSyslogsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyslogsSiteGetRequest) Execute() (*V1GlobalSyslogsSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalSyslogsSiteGetExecute(r)
}

/*
V1GlobalSyslogsSiteGet Method for V1GlobalSyslogsSiteGet

Get configured global syslog collectors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyslogsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalSyslogsSiteGet(ctx context.Context) ApiV1GlobalSyslogsSiteGetRequest {
	return ApiV1GlobalSyslogsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSyslogsSiteGetResponse
func (a *DefaultAPIService) V1GlobalSyslogsSiteGetExecute(r ApiV1GlobalSyslogsSiteGetRequest) (*V1GlobalSyslogsSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSyslogsSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyslogsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/syslogs/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalTrafficPoliciesDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalTrafficPoliciesDeviceGetRequest) Authorization(authorization string) ApiV1GlobalTrafficPoliciesDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalTrafficPoliciesDeviceGetRequest) Execute() (*V1GlobalTrafficPoliciesDeviceGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalTrafficPoliciesDeviceGetExecute(r)
}

/*
V1GlobalTrafficPoliciesDeviceGet Method for V1GlobalTrafficPoliciesDeviceGet

Get global traffic-policy objects that failed to attach for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalTrafficPoliciesDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalTrafficPoliciesDeviceGet(ctx context.Context) ApiV1GlobalTrafficPoliciesDeviceGetRequest {
	return ApiV1GlobalTrafficPoliciesDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalTrafficPoliciesDeviceGetResponse
func (a *DefaultAPIService) V1GlobalTrafficPoliciesDeviceGetExecute(r ApiV1GlobalTrafficPoliciesDeviceGetRequest) (*V1GlobalTrafficPoliciesDeviceGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalTrafficPoliciesDeviceGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalTrafficPoliciesDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/traffic-policies/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalTrafficPoliciesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalTrafficPoliciesPostRequest *V1GlobalTrafficPoliciesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalTrafficPoliciesPostRequest) Authorization(authorization string) ApiV1GlobalTrafficPoliciesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalTrafficPoliciesPostRequest) V1GlobalTrafficPoliciesPostRequest(v1GlobalTrafficPoliciesPostRequest V1GlobalTrafficPoliciesPostRequest) ApiV1GlobalTrafficPoliciesPostRequest {
	r.v1GlobalTrafficPoliciesPostRequest = &v1GlobalTrafficPoliciesPostRequest
	return r
}

func (r ApiV1GlobalTrafficPoliciesPostRequest) Execute() (*V1GlobalTrafficPoliciesPostResponse, *http.Response, error) {
	return r.ApiService.V1GlobalTrafficPoliciesPostExecute(r)
}

/*
V1GlobalTrafficPoliciesPost Method for V1GlobalTrafficPoliciesPost

Get configured global traffic-policies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalTrafficPoliciesPostRequest
*/
func (a *DefaultAPIService) V1GlobalTrafficPoliciesPost(ctx context.Context) ApiV1GlobalTrafficPoliciesPostRequest {
	return ApiV1GlobalTrafficPoliciesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalTrafficPoliciesPostResponse
func (a *DefaultAPIService) V1GlobalTrafficPoliciesPostExecute(r ApiV1GlobalTrafficPoliciesPostRequest) (*V1GlobalTrafficPoliciesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalTrafficPoliciesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalTrafficPoliciesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/traffic-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalTrafficPoliciesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalTrafficPoliciesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalTrafficPoliciesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalTrafficPoliciesSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalTrafficPoliciesSiteGetRequest) Authorization(authorization string) ApiV1GlobalTrafficPoliciesSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalTrafficPoliciesSiteGetRequest) Execute() (*V1GlobalTrafficPoliciesSiteGetResponse, *http.Response, error) {
	return r.ApiService.V1GlobalTrafficPoliciesSiteGetExecute(r)
}

/*
V1GlobalTrafficPoliciesSiteGet Method for V1GlobalTrafficPoliciesSiteGet

Get configured global traffic-policies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalTrafficPoliciesSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalTrafficPoliciesSiteGet(ctx context.Context) ApiV1GlobalTrafficPoliciesSiteGetRequest {
	return ApiV1GlobalTrafficPoliciesSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalTrafficPoliciesSiteGetResponse
func (a *DefaultAPIService) V1GlobalTrafficPoliciesSiteGetExecute(r ApiV1GlobalTrafficPoliciesSiteGetRequest) (*V1GlobalTrafficPoliciesSiteGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalTrafficPoliciesSiteGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalTrafficPoliciesSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/traffic-policies/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsEnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsEnterprisesGetRequest) Authorization(authorization string) ApiV1GroupsEnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsEnterprisesGetRequest) Execute() (*V1GroupsEnterprisesGetResponse, *http.Response, error) {
	return r.ApiService.V1GroupsEnterprisesGetExecute(r)
}

/*
V1GroupsEnterprisesGet Method for V1GroupsEnterprisesGet

Get all enterprise-level groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsEnterprisesGetRequest
*/
func (a *DefaultAPIService) V1GroupsEnterprisesGet(ctx context.Context) ApiV1GroupsEnterprisesGetRequest {
	return ApiV1GroupsEnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsEnterprisesGetResponse
func (a *DefaultAPIService) V1GroupsEnterprisesGetExecute(r ApiV1GroupsEnterprisesGetRequest) (*V1GroupsEnterprisesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsEnterprisesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsEnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsGetRequest) Authorization(authorization string) ApiV1GroupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsGetRequest) Execute() (*V1GroupsGetResponse, *http.Response, error) {
	return r.ApiService.V1GroupsGetExecute(r)
}

/*
V1GroupsGet Method for V1GroupsGet

Get all groups in the enterprise.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsGetRequest
*/
func (a *DefaultAPIService) V1GroupsGet(ctx context.Context) ApiV1GroupsGetRequest {
	return ApiV1GroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsGetResponse
func (a *DefaultAPIService) V1GroupsGetExecute(r ApiV1GroupsGetRequest) (*V1GroupsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdDeleteRequest) Authorization(authorization string) ApiV1GroupsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdDeleteExecute(r)
}

/*
V1GroupsIdDelete Method for V1GroupsIdDelete

Delete a group and remove all member associations and enterprise relationships. Replace with a different group if specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdDeleteRequest
*/
func (a *DefaultAPIService) V1GroupsIdDelete(ctx context.Context, id string) ApiV1GroupsIdDeleteRequest {
	return ApiV1GroupsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdDeleteExecute(r ApiV1GroupsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest) Authorization(authorization string) ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdEnterprisesEnterpriseIdDeleteExecute(r)
}

/*
V1GroupsIdEnterprisesEnterpriseIdDelete Method for V1GroupsIdEnterprisesEnterpriseIdDelete

Remove group's association with a specific enterprise, revoking cross-enterprise access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @param id 
 @return ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest
*/
func (a *DefaultAPIService) V1GroupsIdEnterprisesEnterpriseIdDelete(ctx context.Context, enterpriseId int64, id string) ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest {
	return ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdEnterprisesEnterpriseIdDeleteExecute(r ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdEnterprisesEnterpriseIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/enterprises/{enterpriseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsIdEnterprisesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdEnterprisesPostRequest *V1GroupsIdEnterprisesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdEnterprisesPostRequest) Authorization(authorization string) ApiV1GroupsIdEnterprisesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdEnterprisesPostRequest) V1GroupsIdEnterprisesPostRequest(v1GroupsIdEnterprisesPostRequest V1GroupsIdEnterprisesPostRequest) ApiV1GroupsIdEnterprisesPostRequest {
	r.v1GroupsIdEnterprisesPostRequest = &v1GroupsIdEnterprisesPostRequest
	return r
}

func (r ApiV1GroupsIdEnterprisesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdEnterprisesPostExecute(r)
}

/*
V1GroupsIdEnterprisesPost Method for V1GroupsIdEnterprisesPost

Associate group with additional enterprises to enable cross-enterprise access and management.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdEnterprisesPostRequest
*/
func (a *DefaultAPIService) V1GroupsIdEnterprisesPost(ctx context.Context, id string) ApiV1GroupsIdEnterprisesPostRequest {
	return ApiV1GroupsIdEnterprisesPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdEnterprisesPostExecute(r ApiV1GroupsIdEnterprisesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdEnterprisesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/enterprises"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdEnterprisesPostRequest == nil {
		return nil, reportError("v1GroupsIdEnterprisesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdEnterprisesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdGetRequest) Authorization(authorization string) ApiV1GroupsIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdGetRequest) Execute() (*V1GroupsIdGetResponse, *http.Response, error) {
	return r.ApiService.V1GroupsIdGetExecute(r)
}

/*
V1GroupsIdGet Method for V1GroupsIdGet

Get group information including permissions and members.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdGetRequest
*/
func (a *DefaultAPIService) V1GroupsIdGet(ctx context.Context, id string) ApiV1GroupsIdGetRequest {
	return ApiV1GroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdGetResponse
func (a *DefaultAPIService) V1GroupsIdGetExecute(r ApiV1GroupsIdGetRequest) (*V1GroupsIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersDeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdMembersDeletePostRequest *V1GroupsIdMembersDeletePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersDeletePostRequest) Authorization(authorization string) ApiV1GroupsIdMembersDeletePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersDeletePostRequest) V1GroupsIdMembersDeletePostRequest(v1GroupsIdMembersDeletePostRequest V1GroupsIdMembersDeletePostRequest) ApiV1GroupsIdMembersDeletePostRequest {
	r.v1GroupsIdMembersDeletePostRequest = &v1GroupsIdMembersDeletePostRequest
	return r
}

func (r ApiV1GroupsIdMembersDeletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdMembersDeletePostExecute(r)
}

/*
V1GroupsIdMembersDeletePost Method for V1GroupsIdMembersDeletePost

Remove multiple users from a group by their member IDs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdMembersDeletePostRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersDeletePost(ctx context.Context, id string) ApiV1GroupsIdMembersDeletePostRequest {
	return ApiV1GroupsIdMembersDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdMembersDeletePostExecute(r ApiV1GroupsIdMembersDeletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersDeletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdMembersDeletePostRequest == nil {
		return nil, reportError("v1GroupsIdMembersDeletePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdMembersDeletePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersGetRequest) Authorization(authorization string) ApiV1GroupsIdMembersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersGetRequest) Execute() (*V1GroupsIdMembersGetResponse, *http.Response, error) {
	return r.ApiService.V1GroupsIdMembersGetExecute(r)
}

/*
V1GroupsIdMembersGet Method for V1GroupsIdMembersGet

Get all members of a specific group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdMembersGetRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersGet(ctx context.Context, id string) ApiV1GroupsIdMembersGetRequest {
	return ApiV1GroupsIdMembersGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersGetResponse
func (a *DefaultAPIService) V1GroupsIdMembersGetExecute(r ApiV1GroupsIdMembersGetRequest) (*V1GroupsIdMembersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersMemberIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	memberId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersMemberIdDeleteRequest) Authorization(authorization string) ApiV1GroupsIdMembersMemberIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersMemberIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdMembersMemberIdDeleteExecute(r)
}

/*
V1GroupsIdMembersMemberIdDelete Method for V1GroupsIdMembersMemberIdDelete

Remove a specific user from a group by member ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @param memberId 
 @return ApiV1GroupsIdMembersMemberIdDeleteRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersMemberIdDelete(ctx context.Context, id string, memberId string) ApiV1GroupsIdMembersMemberIdDeleteRequest {
	return ApiV1GroupsIdMembersMemberIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		memberId: memberId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdMembersMemberIdDeleteExecute(r ApiV1GroupsIdMembersMemberIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersMemberIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members/{memberId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"memberId"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdMembersPostRequest *V1GroupsIdMembersPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersPostRequest) Authorization(authorization string) ApiV1GroupsIdMembersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersPostRequest) V1GroupsIdMembersPostRequest(v1GroupsIdMembersPostRequest V1GroupsIdMembersPostRequest) ApiV1GroupsIdMembersPostRequest {
	r.v1GroupsIdMembersPostRequest = &v1GroupsIdMembersPostRequest
	return r
}

func (r ApiV1GroupsIdMembersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdMembersPostExecute(r)
}

/*
V1GroupsIdMembersPost Method for V1GroupsIdMembersPost

Add multiple users to a group by their global IDs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdMembersPostRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersPost(ctx context.Context, id string) ApiV1GroupsIdMembersPostRequest {
	return ApiV1GroupsIdMembersPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdMembersPostExecute(r ApiV1GroupsIdMembersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdMembersPostRequest == nil {
		return nil, reportError("v1GroupsIdMembersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdMembersPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsIdPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdPatchRequest *V1GroupsIdPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdPatchRequest) Authorization(authorization string) ApiV1GroupsIdPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdPatchRequest) V1GroupsIdPatchRequest(v1GroupsIdPatchRequest V1GroupsIdPatchRequest) ApiV1GroupsIdPatchRequest {
	r.v1GroupsIdPatchRequest = &v1GroupsIdPatchRequest
	return r
}

func (r ApiV1GroupsIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsIdPatchExecute(r)
}

/*
V1GroupsIdPatch Method for V1GroupsIdPatch

Update group information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdPatchRequest
*/
func (a *DefaultAPIService) V1GroupsIdPatch(ctx context.Context, id string) ApiV1GroupsIdPatchRequest {
	return ApiV1GroupsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsIdPatchExecute(r ApiV1GroupsIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdPatchRequest == nil {
		return nil, reportError("v1GroupsIdPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GroupsPutRequest *V1GroupsPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsPutRequest) Authorization(authorization string) ApiV1GroupsPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsPutRequest) V1GroupsPutRequest(v1GroupsPutRequest V1GroupsPutRequest) ApiV1GroupsPutRequest {
	r.v1GroupsPutRequest = &v1GroupsPutRequest
	return r
}

func (r ApiV1GroupsPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1GroupsPutExecute(r)
}

/*
V1GroupsPut Method for V1GroupsPut

Create a new group with and set permissions. Set group's enterprise management capabilities (msp only).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsPutRequest
*/
func (a *DefaultAPIService) V1GroupsPut(ctx context.Context) ApiV1GroupsPutRequest {
	return ApiV1GroupsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1GroupsPutExecute(r ApiV1GroupsPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsPutRequest == nil {
		return nil, reportError("v1GroupsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1GroupsRootGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsRootGetRequest) Authorization(authorization string) ApiV1GroupsRootGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsRootGetRequest) Execute() (*V1GroupsRootGetResponse, *http.Response, error) {
	return r.ApiService.V1GroupsRootGetExecute(r)
}

/*
V1GroupsRootGet Method for V1GroupsRootGet

Get all root-level groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsRootGetRequest
*/
func (a *DefaultAPIService) V1GroupsRootGet(ctx context.Context) ApiV1GroupsRootGetRequest {
	return ApiV1GroupsRootGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsRootGetResponse
func (a *DefaultAPIService) V1GroupsRootGetExecute(r ApiV1GroupsRootGetRequest) (*V1GroupsRootGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsRootGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsRootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/root"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IdPasswordRecoverPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1IdPasswordRecoverPatchRequest) Authorization(authorization string) ApiV1IdPasswordRecoverPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1IdPasswordRecoverPatchRequest) Body(body map[string]interface{}) ApiV1IdPasswordRecoverPatchRequest {
	r.body = &body
	return r
}

func (r ApiV1IdPasswordRecoverPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1IdPasswordRecoverPatchExecute(r)
}

/*
V1IdPasswordRecoverPatch Method for V1IdPasswordRecoverPatch

Initiate password recovery for specific user (Graphiant cloud only).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1IdPasswordRecoverPatchRequest
*/
func (a *DefaultAPIService) V1IdPasswordRecoverPatch(ctx context.Context, id string) ApiV1IdPasswordRecoverPatchRequest {
	return ApiV1IdPasswordRecoverPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1IdPasswordRecoverPatchExecute(r ApiV1IdPasswordRecoverPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1IdPasswordRecoverPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{id}/password/recover"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1InvitationEmailPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1InvitationEmailPostRequest *V1InvitationEmailPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1InvitationEmailPostRequest) Authorization(authorization string) ApiV1InvitationEmailPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1InvitationEmailPostRequest) V1InvitationEmailPostRequest(v1InvitationEmailPostRequest V1InvitationEmailPostRequest) ApiV1InvitationEmailPostRequest {
	r.v1InvitationEmailPostRequest = &v1InvitationEmailPostRequest
	return r
}

func (r ApiV1InvitationEmailPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1InvitationEmailPostExecute(r)
}

/*
V1InvitationEmailPost Method for V1InvitationEmailPost

Send invitation emails for B2B data exchange service connections. For non-Graphiant enterprises, sends invite to all admin users in the proxy tenant desiganted by your msp. For Graphiant, sends to specified admin email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1InvitationEmailPostRequest
*/
func (a *DefaultAPIService) V1InvitationEmailPost(ctx context.Context) ApiV1InvitationEmailPostRequest {
	return ApiV1InvitationEmailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1InvitationEmailPostExecute(r ApiV1InvitationEmailPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1InvitationEmailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/invitation/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1InvitationEmailPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1InvitationEmailPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1InvitationEmailPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LanSegmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LanSegmentsGetRequest) Authorization(authorization string) ApiV1LanSegmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LanSegmentsGetRequest) Execute() (*V1LanSegmentsGetResponse, *http.Response, error) {
	return r.ApiService.V1LanSegmentsGetExecute(r)
}

/*
V1LanSegmentsGet Method for V1LanSegmentsGet

Get LAN Segments for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1LanSegmentsGetRequest
*/
func (a *DefaultAPIService) V1LanSegmentsGet(ctx context.Context) ApiV1LanSegmentsGetRequest {
	return ApiV1LanSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1LanSegmentsGetResponse
func (a *DefaultAPIService) V1LanSegmentsGetExecute(r ApiV1LanSegmentsGetRequest) (*V1LanSegmentsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LanSegmentsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LanSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LldpInterfaceIdNeighborsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	interfaceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LldpInterfaceIdNeighborsGetRequest) Authorization(authorization string) ApiV1LldpInterfaceIdNeighborsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LldpInterfaceIdNeighborsGetRequest) Execute() (*V1LldpInterfaceIdNeighborsGetResponse, *http.Response, error) {
	return r.ApiService.V1LldpInterfaceIdNeighborsGetExecute(r)
}

/*
V1LldpInterfaceIdNeighborsGet Method for V1LldpInterfaceIdNeighborsGet

Get the LLDP neighbors for an interface and optionally for a specific vendor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId 
 @return ApiV1LldpInterfaceIdNeighborsGetRequest
*/
func (a *DefaultAPIService) V1LldpInterfaceIdNeighborsGet(ctx context.Context, interfaceId int64) ApiV1LldpInterfaceIdNeighborsGetRequest {
	return ApiV1LldpInterfaceIdNeighborsGetRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return V1LldpInterfaceIdNeighborsGetResponse
func (a *DefaultAPIService) V1LldpInterfaceIdNeighborsGetExecute(r ApiV1LldpInterfaceIdNeighborsGetRequest) (*V1LldpInterfaceIdNeighborsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LldpInterfaceIdNeighborsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LldpInterfaceIdNeighborsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lldp/{interfaceId}/neighbors"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LldpInterfaceIdSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	interfaceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LldpInterfaceIdSummaryGetRequest) Authorization(authorization string) ApiV1LldpInterfaceIdSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LldpInterfaceIdSummaryGetRequest) Execute() (*V1LldpInterfaceIdSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1LldpInterfaceIdSummaryGetExecute(r)
}

/*
V1LldpInterfaceIdSummaryGet Method for V1LldpInterfaceIdSummaryGet

Get the summary of LLDP neighbors for an interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId 
 @return ApiV1LldpInterfaceIdSummaryGetRequest
*/
func (a *DefaultAPIService) V1LldpInterfaceIdSummaryGet(ctx context.Context, interfaceId int64) ApiV1LldpInterfaceIdSummaryGetRequest {
	return ApiV1LldpInterfaceIdSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return V1LldpInterfaceIdSummaryGetResponse
func (a *DefaultAPIService) V1LldpInterfaceIdSummaryGetExecute(r ApiV1LldpInterfaceIdSummaryGetRequest) (*V1LldpInterfaceIdSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LldpInterfaceIdSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LldpInterfaceIdSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lldp/{interfaceId}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LldpInterfaceIdVendorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	interfaceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LldpInterfaceIdVendorsGetRequest) Authorization(authorization string) ApiV1LldpInterfaceIdVendorsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LldpInterfaceIdVendorsGetRequest) Execute() (*V1LldpInterfaceIdVendorsGetResponse, *http.Response, error) {
	return r.ApiService.V1LldpInterfaceIdVendorsGetExecute(r)
}

/*
V1LldpInterfaceIdVendorsGet Method for V1LldpInterfaceIdVendorsGet

Get the list LLDP vendors for an interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId 
 @return ApiV1LldpInterfaceIdVendorsGetRequest
*/
func (a *DefaultAPIService) V1LldpInterfaceIdVendorsGet(ctx context.Context, interfaceId int64) ApiV1LldpInterfaceIdVendorsGetRequest {
	return ApiV1LldpInterfaceIdVendorsGetRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return V1LldpInterfaceIdVendorsGetResponse
func (a *DefaultAPIService) V1LldpInterfaceIdVendorsGetExecute(r ApiV1LldpInterfaceIdVendorsGetRequest) (*V1LldpInterfaceIdVendorsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LldpInterfaceIdVendorsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LldpInterfaceIdVendorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lldp/{interfaceId}/vendors"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1LogsPostRequest *V1LogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LogsPostRequest) Authorization(authorization string) ApiV1LogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LogsPostRequest) V1LogsPostRequest(v1LogsPostRequest V1LogsPostRequest) ApiV1LogsPostRequest {
	r.v1LogsPostRequest = &v1LogsPostRequest
	return r
}

func (r ApiV1LogsPostRequest) Execute() (*V1LogsPostResponse, *http.Response, error) {
	return r.ApiService.V1LogsPostExecute(r)
}

/*
V1LogsPost Method for V1LogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1LogsPostRequest
*/
func (a *DefaultAPIService) V1LogsPost(ctx context.Context) ApiV1LogsPostRequest {
	return ApiV1LogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1LogsPostResponse
func (a *DefaultAPIService) V1LogsPostExecute(r ApiV1LogsPostRequest) (*V1LogsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LogsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1LogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1LogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1LogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsBandwidthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsBandwidthPostRequest *V1MonitoringCircuitsBandwidthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsBandwidthPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsBandwidthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsBandwidthPostRequest) V1MonitoringCircuitsBandwidthPostRequest(v1MonitoringCircuitsBandwidthPostRequest V1MonitoringCircuitsBandwidthPostRequest) ApiV1MonitoringCircuitsBandwidthPostRequest {
	r.v1MonitoringCircuitsBandwidthPostRequest = &v1MonitoringCircuitsBandwidthPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsBandwidthPostRequest) Execute() (*V1MonitoringCircuitsBandwidthPostResponse, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsBandwidthPostExecute(r)
}

/*
V1MonitoringCircuitsBandwidthPost Method for V1MonitoringCircuitsBandwidthPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsBandwidthPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsBandwidthPost(ctx context.Context) ApiV1MonitoringCircuitsBandwidthPostRequest {
	return ApiV1MonitoringCircuitsBandwidthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsBandwidthPostResponse
func (a *DefaultAPIService) V1MonitoringCircuitsBandwidthPostExecute(r ApiV1MonitoringCircuitsBandwidthPostRequest) (*V1MonitoringCircuitsBandwidthPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsBandwidthPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsBandwidthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsBandwidthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsBandwidthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsBandwidthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsIncidentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsIncidentsPostRequest *V1MonitoringCircuitsIncidentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsIncidentsPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsIncidentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsIncidentsPostRequest) V1MonitoringCircuitsIncidentsPostRequest(v1MonitoringCircuitsIncidentsPostRequest V1MonitoringCircuitsIncidentsPostRequest) ApiV1MonitoringCircuitsIncidentsPostRequest {
	r.v1MonitoringCircuitsIncidentsPostRequest = &v1MonitoringCircuitsIncidentsPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsIncidentsPostRequest) Execute() (*V1MonitoringCircuitsIncidentsPostResponse, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsIncidentsPostExecute(r)
}

/*
V1MonitoringCircuitsIncidentsPost Method for V1MonitoringCircuitsIncidentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsIncidentsPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsIncidentsPost(ctx context.Context) ApiV1MonitoringCircuitsIncidentsPostRequest {
	return ApiV1MonitoringCircuitsIncidentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsIncidentsPostResponse
func (a *DefaultAPIService) V1MonitoringCircuitsIncidentsPostExecute(r ApiV1MonitoringCircuitsIncidentsPostRequest) (*V1MonitoringCircuitsIncidentsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsIncidentsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsIncidentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/incidents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsIncidentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsIncidentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsIncidentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsSummaryPostRequest *V1MonitoringCircuitsSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsSummaryPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsSummaryPostRequest) V1MonitoringCircuitsSummaryPostRequest(v1MonitoringCircuitsSummaryPostRequest V1MonitoringCircuitsSummaryPostRequest) ApiV1MonitoringCircuitsSummaryPostRequest {
	r.v1MonitoringCircuitsSummaryPostRequest = &v1MonitoringCircuitsSummaryPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsSummaryPostRequest) Execute() (*V1MonitoringCircuitsSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsSummaryPostExecute(r)
}

/*
V1MonitoringCircuitsSummaryPost Method for V1MonitoringCircuitsSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsSummaryPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsSummaryPost(ctx context.Context) ApiV1MonitoringCircuitsSummaryPostRequest {
	return ApiV1MonitoringCircuitsSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsSummaryPostResponse
func (a *DefaultAPIService) V1MonitoringCircuitsSummaryPostExecute(r ApiV1MonitoringCircuitsSummaryPostRequest) (*V1MonitoringCircuitsSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsUtilizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsUtilizationPostRequest *V1MonitoringCircuitsUtilizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsUtilizationPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsUtilizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsUtilizationPostRequest) V1MonitoringCircuitsUtilizationPostRequest(v1MonitoringCircuitsUtilizationPostRequest V1MonitoringCircuitsUtilizationPostRequest) ApiV1MonitoringCircuitsUtilizationPostRequest {
	r.v1MonitoringCircuitsUtilizationPostRequest = &v1MonitoringCircuitsUtilizationPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsUtilizationPostRequest) Execute() (*V1MonitoringCircuitsUtilizationPostResponse, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsUtilizationPostExecute(r)
}

/*
V1MonitoringCircuitsUtilizationPost Method for V1MonitoringCircuitsUtilizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsUtilizationPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsUtilizationPost(ctx context.Context) ApiV1MonitoringCircuitsUtilizationPostRequest {
	return ApiV1MonitoringCircuitsUtilizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsUtilizationPostResponse
func (a *DefaultAPIService) V1MonitoringCircuitsUtilizationPostExecute(r ApiV1MonitoringCircuitsUtilizationPostRequest) (*V1MonitoringCircuitsUtilizationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsUtilizationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsUtilizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/utilization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsUtilizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsUtilizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsUtilizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsVisualizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsVisualizationPostRequest *V1MonitoringCircuitsVisualizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsVisualizationPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsVisualizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsVisualizationPostRequest) V1MonitoringCircuitsVisualizationPostRequest(v1MonitoringCircuitsVisualizationPostRequest V1MonitoringCircuitsVisualizationPostRequest) ApiV1MonitoringCircuitsVisualizationPostRequest {
	r.v1MonitoringCircuitsVisualizationPostRequest = &v1MonitoringCircuitsVisualizationPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsVisualizationPostRequest) Execute() (*V1MonitoringCircuitsVisualizationPostResponse, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsVisualizationPostExecute(r)
}

/*
V1MonitoringCircuitsVisualizationPost Method for V1MonitoringCircuitsVisualizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsVisualizationPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsVisualizationPost(ctx context.Context) ApiV1MonitoringCircuitsVisualizationPostRequest {
	return ApiV1MonitoringCircuitsVisualizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsVisualizationPostResponse
func (a *DefaultAPIService) V1MonitoringCircuitsVisualizationPostExecute(r ApiV1MonitoringCircuitsVisualizationPostRequest) (*V1MonitoringCircuitsVisualizationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsVisualizationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsVisualizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/visualization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsVisualizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsVisualizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsVisualizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1NatEntriesDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1NatEntriesDeviceIdGetRequest) Authorization(authorization string) ApiV1NatEntriesDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1NatEntriesDeviceIdGetRequest) Execute() (*V1NatEntriesDeviceIdGetResponse, *http.Response, error) {
	return r.ApiService.V1NatEntriesDeviceIdGetExecute(r)
}

/*
V1NatEntriesDeviceIdGet Method for V1NatEntriesDeviceIdGet

Get the NAT entries for the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1NatEntriesDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1NatEntriesDeviceIdGet(ctx context.Context, deviceId int64) ApiV1NatEntriesDeviceIdGetRequest {
	return ApiV1NatEntriesDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1NatEntriesDeviceIdGetResponse
func (a *DefaultAPIService) V1NatEntriesDeviceIdGetExecute(r ApiV1NatEntriesDeviceIdGetRequest) (*V1NatEntriesDeviceIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1NatEntriesDeviceIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1NatEntriesDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/nat/entries/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1NatUtilizationDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1NatUtilizationDeviceIdGetRequest) Authorization(authorization string) ApiV1NatUtilizationDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1NatUtilizationDeviceIdGetRequest) Execute() (*V1NatUtilizationDeviceIdGetResponse, *http.Response, error) {
	return r.ApiService.V1NatUtilizationDeviceIdGetExecute(r)
}

/*
V1NatUtilizationDeviceIdGet Method for V1NatUtilizationDeviceIdGet

Get the NAT usage for the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1NatUtilizationDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1NatUtilizationDeviceIdGet(ctx context.Context, deviceId int64) ApiV1NatUtilizationDeviceIdGetRequest {
	return ApiV1NatUtilizationDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1NatUtilizationDeviceIdGetResponse
func (a *DefaultAPIService) V1NatUtilizationDeviceIdGetExecute(r ApiV1NatUtilizationDeviceIdGetRequest) (*V1NatUtilizationDeviceIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1NatUtilizationDeviceIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1NatUtilizationDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/nat/utilization/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OnboardingCloudinitDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1OnboardingCloudinitDeleteRequest) Authorization(authorization string) ApiV1OnboardingCloudinitDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1OnboardingCloudinitDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1OnboardingCloudinitDeleteExecute(r)
}

/*
V1OnboardingCloudinitDelete Method for V1OnboardingCloudinitDelete

Delete the onboarding token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1OnboardingCloudinitDeleteRequest
*/
func (a *DefaultAPIService) V1OnboardingCloudinitDelete(ctx context.Context) ApiV1OnboardingCloudinitDeleteRequest {
	return ApiV1OnboardingCloudinitDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1OnboardingCloudinitDeleteExecute(r ApiV1OnboardingCloudinitDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1OnboardingCloudinitDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/cloudinit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1OnboardingCloudinitGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1OnboardingCloudinitGetRequest) Authorization(authorization string) ApiV1OnboardingCloudinitGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1OnboardingCloudinitGetRequest) Execute() (*V1OnboardingCloudinitGetResponse, *http.Response, error) {
	return r.ApiService.V1OnboardingCloudinitGetExecute(r)
}

/*
V1OnboardingCloudinitGet Method for V1OnboardingCloudinitGet

Get all the onboarding tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1OnboardingCloudinitGetRequest
*/
func (a *DefaultAPIService) V1OnboardingCloudinitGet(ctx context.Context) ApiV1OnboardingCloudinitGetRequest {
	return ApiV1OnboardingCloudinitGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1OnboardingCloudinitGetResponse
func (a *DefaultAPIService) V1OnboardingCloudinitGetExecute(r ApiV1OnboardingCloudinitGetRequest) (*V1OnboardingCloudinitGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1OnboardingCloudinitGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1OnboardingCloudinitGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/cloudinit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OnboardingCloudinitPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1OnboardingCloudinitPostRequest *V1OnboardingCloudinitPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1OnboardingCloudinitPostRequest) Authorization(authorization string) ApiV1OnboardingCloudinitPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1OnboardingCloudinitPostRequest) V1OnboardingCloudinitPostRequest(v1OnboardingCloudinitPostRequest V1OnboardingCloudinitPostRequest) ApiV1OnboardingCloudinitPostRequest {
	r.v1OnboardingCloudinitPostRequest = &v1OnboardingCloudinitPostRequest
	return r
}

func (r ApiV1OnboardingCloudinitPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1OnboardingCloudinitPostExecute(r)
}

/*
V1OnboardingCloudinitPost Method for V1OnboardingCloudinitPost

Create a onboarding token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1OnboardingCloudinitPostRequest
*/
func (a *DefaultAPIService) V1OnboardingCloudinitPost(ctx context.Context) ApiV1OnboardingCloudinitPostRequest {
	return ApiV1OnboardingCloudinitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1OnboardingCloudinitPostExecute(r ApiV1OnboardingCloudinitPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1OnboardingCloudinitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/onboarding/cloudinit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1OnboardingCloudinitPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1OnboardingCloudinitPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1OnboardingCloudinitPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyApplicationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyApplicationsGetRequest) Authorization(authorization string) ApiV1PolicyApplicationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyApplicationsGetRequest) Execute() (*V1PolicyApplicationsGetResponse, *http.Response, error) {
	return r.ApiService.V1PolicyApplicationsGetExecute(r)
}

/*
V1PolicyApplicationsGet Method for V1PolicyApplicationsGet

Get a list of builtin DPI applications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyApplicationsGetRequest
*/
func (a *DefaultAPIService) V1PolicyApplicationsGet(ctx context.Context) ApiV1PolicyApplicationsGetRequest {
	return ApiV1PolicyApplicationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyApplicationsGetResponse
func (a *DefaultAPIService) V1PolicyApplicationsGetExecute(r ApiV1PolicyApplicationsGetRequest) (*V1PolicyApplicationsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyApplicationsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyApplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyPrefixSetsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyPrefixSetsIdDeleteRequest) Authorization(authorization string) ApiV1PolicyPrefixSetsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyPrefixSetsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1PolicyPrefixSetsIdDeleteExecute(r)
}

/*
V1PolicyPrefixSetsIdDelete Method for V1PolicyPrefixSetsIdDelete

Delete a prefix-set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1PolicyPrefixSetsIdDeleteRequest
*/
func (a *DefaultAPIService) V1PolicyPrefixSetsIdDelete(ctx context.Context, id int64) ApiV1PolicyPrefixSetsIdDeleteRequest {
	return ApiV1PolicyPrefixSetsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1PolicyPrefixSetsIdDeleteExecute(r ApiV1PolicyPrefixSetsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyPrefixSetsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/prefix-sets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1PolicyPrefixSetsIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1PolicyPrefixSetsIdPutRequest *V1PolicyPrefixSetsIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyPrefixSetsIdPutRequest) Authorization(authorization string) ApiV1PolicyPrefixSetsIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyPrefixSetsIdPutRequest) V1PolicyPrefixSetsIdPutRequest(v1PolicyPrefixSetsIdPutRequest V1PolicyPrefixSetsIdPutRequest) ApiV1PolicyPrefixSetsIdPutRequest {
	r.v1PolicyPrefixSetsIdPutRequest = &v1PolicyPrefixSetsIdPutRequest
	return r
}

func (r ApiV1PolicyPrefixSetsIdPutRequest) Execute() (*V1PolicyPrefixSetsIdPutResponse, *http.Response, error) {
	return r.ApiService.V1PolicyPrefixSetsIdPutExecute(r)
}

/*
V1PolicyPrefixSetsIdPut Method for V1PolicyPrefixSetsIdPut

Update a prefix-set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1PolicyPrefixSetsIdPutRequest
*/
func (a *DefaultAPIService) V1PolicyPrefixSetsIdPut(ctx context.Context, id int64) ApiV1PolicyPrefixSetsIdPutRequest {
	return ApiV1PolicyPrefixSetsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1PolicyPrefixSetsIdPutResponse
func (a *DefaultAPIService) V1PolicyPrefixSetsIdPutExecute(r ApiV1PolicyPrefixSetsIdPutRequest) (*V1PolicyPrefixSetsIdPutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyPrefixSetsIdPutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyPrefixSetsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/prefix-sets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyPrefixSetsIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1PolicyPrefixSetsIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyPrefixSetsIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyPrefixSetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PolicyPrefixSetsPostRequest *V1PolicyPrefixSetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyPrefixSetsPostRequest) Authorization(authorization string) ApiV1PolicyPrefixSetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyPrefixSetsPostRequest) V1PolicyPrefixSetsPostRequest(v1PolicyPrefixSetsPostRequest V1PolicyPrefixSetsPostRequest) ApiV1PolicyPrefixSetsPostRequest {
	r.v1PolicyPrefixSetsPostRequest = &v1PolicyPrefixSetsPostRequest
	return r
}

func (r ApiV1PolicyPrefixSetsPostRequest) Execute() (*V1PolicyPrefixSetsPostResponse, *http.Response, error) {
	return r.ApiService.V1PolicyPrefixSetsPostExecute(r)
}

/*
V1PolicyPrefixSetsPost Method for V1PolicyPrefixSetsPost

Create a new prefix-set scoped to the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyPrefixSetsPostRequest
*/
func (a *DefaultAPIService) V1PolicyPrefixSetsPost(ctx context.Context) ApiV1PolicyPrefixSetsPostRequest {
	return ApiV1PolicyPrefixSetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyPrefixSetsPostResponse
func (a *DefaultAPIService) V1PolicyPrefixSetsPostExecute(r ApiV1PolicyPrefixSetsPostRequest) (*V1PolicyPrefixSetsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyPrefixSetsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyPrefixSetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/prefix-sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyPrefixSetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PolicyPrefixSetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyPrefixSetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	level *int32
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsIdDeleteRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1PolicyRouteTagSetsIdDeleteRequest) Level(level int32) ApiV1PolicyRouteTagSetsIdDeleteRequest {
	r.level = &level
	return r
}

func (r ApiV1PolicyRouteTagSetsIdDeleteRequest) Execute() (*V1PolicyRouteTagSetsIdDeleteResponse, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsIdDeleteExecute(r)
}

/*
V1PolicyRouteTagSetsIdDelete Method for V1PolicyRouteTagSetsIdDelete

Create a new route-tag scoped to the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1PolicyRouteTagSetsIdDeleteRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsIdDelete(ctx context.Context, id int64) ApiV1PolicyRouteTagSetsIdDeleteRequest {
	return ApiV1PolicyRouteTagSetsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsIdDeleteResponse
func (a *DefaultAPIService) V1PolicyRouteTagSetsIdDeleteExecute(r ApiV1PolicyRouteTagSetsIdDeleteRequest) (*V1PolicyRouteTagSetsIdDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsIdDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PolicyRouteTagSetsPostRequest *V1PolicyRouteTagSetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsPostRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsPostRequest) V1PolicyRouteTagSetsPostRequest(v1PolicyRouteTagSetsPostRequest V1PolicyRouteTagSetsPostRequest) ApiV1PolicyRouteTagSetsPostRequest {
	r.v1PolicyRouteTagSetsPostRequest = &v1PolicyRouteTagSetsPostRequest
	return r
}

func (r ApiV1PolicyRouteTagSetsPostRequest) Execute() (*V1PolicyRouteTagSetsPostResponse, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsPostExecute(r)
}

/*
V1PolicyRouteTagSetsPost Method for V1PolicyRouteTagSetsPost

Create a new route tag scoped to the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsPostRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsPost(ctx context.Context) ApiV1PolicyRouteTagSetsPostRequest {
	return ApiV1PolicyRouteTagSetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsPostResponse
func (a *DefaultAPIService) V1PolicyRouteTagSetsPostExecute(r ApiV1PolicyRouteTagSetsPostRequest) (*V1PolicyRouteTagSetsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyRouteTagSetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PolicyRouteTagSetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyRouteTagSetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsTagDetailGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsTagDetailGetRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsTagDetailGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsTagDetailGetRequest) Execute() (*V1PolicyRouteTagSetsTagDetailGetResponse, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsTagDetailGetExecute(r)
}

/*
V1PolicyRouteTagSetsTagDetailGet Method for V1PolicyRouteTagSetsTagDetailGet

Get all the route tags summary for the the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsTagDetailGetRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagDetailGet(ctx context.Context) ApiV1PolicyRouteTagSetsTagDetailGetRequest {
	return ApiV1PolicyRouteTagSetsTagDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsTagDetailGetResponse
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagDetailGetExecute(r ApiV1PolicyRouteTagSetsTagDetailGetRequest) (*V1PolicyRouteTagSetsTagDetailGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsTagDetailGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsTagDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/tag-detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsTagsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsTagsGetRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsTagsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsTagsGetRequest) Execute() (*V1PolicyRouteTagSetsTagsGetResponse, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsTagsGetExecute(r)
}

/*
V1PolicyRouteTagSetsTagsGet Method for V1PolicyRouteTagSetsTagsGet

Get all the route tags for the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsTagsGetRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsGet(ctx context.Context) ApiV1PolicyRouteTagSetsTagsGetRequest {
	return ApiV1PolicyRouteTagSetsTagsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsTagsGetResponse
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsGetExecute(r ApiV1PolicyRouteTagSetsTagsGetRequest) (*V1PolicyRouteTagSetsTagsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsTagsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsTagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsTagsSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsTagsSummaryGetRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsTagsSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsTagsSummaryGetRequest) Execute() (*V1PolicyRouteTagSetsTagsSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsTagsSummaryGetExecute(r)
}

/*
V1PolicyRouteTagSetsTagsSummaryGet Method for V1PolicyRouteTagSetsTagsSummaryGet

Get all the route tags summary for the the enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsTagsSummaryGetRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsSummaryGet(ctx context.Context) ApiV1PolicyRouteTagSetsTagsSummaryGetRequest {
	return ApiV1PolicyRouteTagSetsTagsSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsTagsSummaryGetResponse
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsSummaryGetExecute(r ApiV1PolicyRouteTagSetsTagsSummaryGetRequest) (*V1PolicyRouteTagSetsTagsSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsTagsSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsTagsSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/tags-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalApikeysDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	gcsName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalApikeysDeleteRequest) Authorization(authorization string) ApiV1PortalApikeysDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1PortalApikeysDeleteRequest) GcsName(gcsName string) ApiV1PortalApikeysDeleteRequest {
	r.gcsName = &gcsName
	return r
}

func (r ApiV1PortalApikeysDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1PortalApikeysDeleteExecute(r)
}

/*
V1PortalApikeysDelete Method for V1PortalApikeysDelete

Remove private GCS API key by GCS name to revoke portal access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalApikeysDeleteRequest
*/
func (a *DefaultAPIService) V1PortalApikeysDelete(ctx context.Context) ApiV1PortalApikeysDeleteRequest {
	return ApiV1PortalApikeysDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1PortalApikeysDeleteExecute(r ApiV1PortalApikeysDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalApikeysDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.gcsName == nil {
		return localVarReturnValue, nil, reportError("gcsName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "gcsName", r.gcsName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalApikeysGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalApikeysGetRequest) Authorization(authorization string) ApiV1PortalApikeysGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalApikeysGetRequest) Execute() (*V1PortalApikeysGetResponse, *http.Response, error) {
	return r.ApiService.V1PortalApikeysGetExecute(r)
}

/*
V1PortalApikeysGet Method for V1PortalApikeysGet

Get private GCS API key information and status for portal access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalApikeysGetRequest
*/
func (a *DefaultAPIService) V1PortalApikeysGet(ctx context.Context) ApiV1PortalApikeysGetRequest {
	return ApiV1PortalApikeysGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalApikeysGetResponse
func (a *DefaultAPIService) V1PortalApikeysGetExecute(r ApiV1PortalApikeysGetRequest) (*V1PortalApikeysGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalApikeysGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalApikeysGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalApikeysPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalApikeysPostRequest *V1PortalApikeysPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalApikeysPostRequest) Authorization(authorization string) ApiV1PortalApikeysPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalApikeysPostRequest) V1PortalApikeysPostRequest(v1PortalApikeysPostRequest V1PortalApikeysPostRequest) ApiV1PortalApikeysPostRequest {
	r.v1PortalApikeysPostRequest = &v1PortalApikeysPostRequest
	return r
}

func (r ApiV1PortalApikeysPostRequest) Execute() (*V1PortalApikeysPostResponse, *http.Response, error) {
	return r.ApiService.V1PortalApikeysPostExecute(r)
}

/*
V1PortalApikeysPost Method for V1PortalApikeysPost

Generate private GCS API key for portal access and authentication.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalApikeysPostRequest
*/
func (a *DefaultAPIService) V1PortalApikeysPost(ctx context.Context) ApiV1PortalApikeysPostRequest {
	return ApiV1PortalApikeysPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalApikeysPostResponse
func (a *DefaultAPIService) V1PortalApikeysPostExecute(r ApiV1PortalApikeysPostRequest) (*V1PortalApikeysPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalApikeysPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalApikeysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalApikeysPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PortalApikeysPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalApikeysPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivateDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateDetailsGetRequest) Authorization(authorization string) ApiV1PortalPrivateDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateDetailsGetRequest) Execute() (*V1PortalPrivateDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1PortalPrivateDetailsGetExecute(r)
}

/*
V1PortalPrivateDetailsGet Method for V1PortalPrivateDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateDetailsGetRequest
*/
func (a *DefaultAPIService) V1PortalPrivateDetailsGet(ctx context.Context) ApiV1PortalPrivateDetailsGetRequest {
	return ApiV1PortalPrivateDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalPrivateDetailsGetResponse
func (a *DefaultAPIService) V1PortalPrivateDetailsGetExecute(r ApiV1PortalPrivateDetailsGetRequest) (*V1PortalPrivateDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalPrivateDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivateInventoryDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateInventoryDetailsGetRequest) Authorization(authorization string) ApiV1PortalPrivateInventoryDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateInventoryDetailsGetRequest) Execute() (*V1PortalPrivateInventoryDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1PortalPrivateInventoryDetailsGetExecute(r)
}

/*
V1PortalPrivateInventoryDetailsGet Method for V1PortalPrivateInventoryDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateInventoryDetailsGetRequest
*/
func (a *DefaultAPIService) V1PortalPrivateInventoryDetailsGet(ctx context.Context) ApiV1PortalPrivateInventoryDetailsGetRequest {
	return ApiV1PortalPrivateInventoryDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalPrivateInventoryDetailsGetResponse
func (a *DefaultAPIService) V1PortalPrivateInventoryDetailsGetExecute(r ApiV1PortalPrivateInventoryDetailsGetRequest) (*V1PortalPrivateInventoryDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalPrivateInventoryDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateInventoryDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/inventory_details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalPrivatePostRequest *V1PortalPrivatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivatePostRequest) Authorization(authorization string) ApiV1PortalPrivatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivatePostRequest) V1PortalPrivatePostRequest(v1PortalPrivatePostRequest V1PortalPrivatePostRequest) ApiV1PortalPrivatePostRequest {
	r.v1PortalPrivatePostRequest = &v1PortalPrivatePostRequest
	return r
}

func (r ApiV1PortalPrivatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1PortalPrivatePostExecute(r)
}

/*
V1PortalPrivatePost Method for V1PortalPrivatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivatePostRequest
*/
func (a *DefaultAPIService) V1PortalPrivatePost(ctx context.Context) ApiV1PortalPrivatePostRequest {
	return ApiV1PortalPrivatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1PortalPrivatePostExecute(r ApiV1PortalPrivatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalPrivatePostRequest == nil {
		return nil, reportError("v1PortalPrivatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalPrivatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1PortalPrivateRegisterPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalPrivateRegisterPostRequest *V1PortalPrivateRegisterPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateRegisterPostRequest) Authorization(authorization string) ApiV1PortalPrivateRegisterPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateRegisterPostRequest) V1PortalPrivateRegisterPostRequest(v1PortalPrivateRegisterPostRequest V1PortalPrivateRegisterPostRequest) ApiV1PortalPrivateRegisterPostRequest {
	r.v1PortalPrivateRegisterPostRequest = &v1PortalPrivateRegisterPostRequest
	return r
}

func (r ApiV1PortalPrivateRegisterPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1PortalPrivateRegisterPostExecute(r)
}

/*
V1PortalPrivateRegisterPost Method for V1PortalPrivateRegisterPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateRegisterPostRequest
*/
func (a *DefaultAPIService) V1PortalPrivateRegisterPost(ctx context.Context) ApiV1PortalPrivateRegisterPostRequest {
	return ApiV1PortalPrivateRegisterPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1PortalPrivateRegisterPostExecute(r ApiV1PortalPrivateRegisterPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateRegisterPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalPrivateRegisterPostRequest == nil {
		return nil, reportError("v1PortalPrivateRegisterPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalPrivateRegisterPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1PortalPrivateSyncPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalPrivateSyncPostRequest *V1PortalPrivateSyncPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateSyncPostRequest) Authorization(authorization string) ApiV1PortalPrivateSyncPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateSyncPostRequest) V1PortalPrivateSyncPostRequest(v1PortalPrivateSyncPostRequest V1PortalPrivateSyncPostRequest) ApiV1PortalPrivateSyncPostRequest {
	r.v1PortalPrivateSyncPostRequest = &v1PortalPrivateSyncPostRequest
	return r
}

func (r ApiV1PortalPrivateSyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1PortalPrivateSyncPostExecute(r)
}

/*
V1PortalPrivateSyncPost Method for V1PortalPrivateSyncPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateSyncPostRequest
*/
func (a *DefaultAPIService) V1PortalPrivateSyncPost(ctx context.Context) ApiV1PortalPrivateSyncPostRequest {
	return ApiV1PortalPrivateSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1PortalPrivateSyncPostExecute(r ApiV1PortalPrivateSyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateSyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalPrivateSyncPostRequest == nil {
		return nil, reportError("v1PortalPrivateSyncPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalPrivateSyncPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1PresharedkeyGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PresharedkeyGetRequest) Authorization(authorization string) ApiV1PresharedkeyGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PresharedkeyGetRequest) Execute() (*V1PresharedkeyGetResponse, *http.Response, error) {
	return r.ApiService.V1PresharedkeyGetExecute(r)
}

/*
V1PresharedkeyGet Method for V1PresharedkeyGet

Get all domain categories from the DPI engine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PresharedkeyGetRequest
*/
func (a *DefaultAPIService) V1PresharedkeyGet(ctx context.Context) ApiV1PresharedkeyGetRequest {
	return ApiV1PresharedkeyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PresharedkeyGetResponse
func (a *DefaultAPIService) V1PresharedkeyGetExecute(r ApiV1PresharedkeyGetRequest) (*V1PresharedkeyGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PresharedkeyGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PresharedkeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/presharedkey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1QosCircuitProfilesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1QosCircuitProfilesGetRequest) Authorization(authorization string) ApiV1QosCircuitProfilesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1QosCircuitProfilesGetRequest) Execute() (*V1QosCircuitProfilesGetResponse, *http.Response, error) {
	return r.ApiService.V1QosCircuitProfilesGetExecute(r)
}

/*
V1QosCircuitProfilesGet Method for V1QosCircuitProfilesGet

Returns a list of QoS profiles for circuits with associated queues & attributes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1QosCircuitProfilesGetRequest
*/
func (a *DefaultAPIService) V1QosCircuitProfilesGet(ctx context.Context) ApiV1QosCircuitProfilesGetRequest {
	return ApiV1QosCircuitProfilesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1QosCircuitProfilesGetResponse
func (a *DefaultAPIService) V1QosCircuitProfilesGetExecute(r ApiV1QosCircuitProfilesGetRequest) (*V1QosCircuitProfilesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1QosCircuitProfilesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1QosCircuitProfilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/qos/circuit-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1RegionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1RegionsGetRequest) Authorization(authorization string) ApiV1RegionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1RegionsGetRequest) Execute() (*V1RegionsGetResponse, *http.Response, error) {
	return r.ApiService.V1RegionsGetExecute(r)
}

/*
V1RegionsGet Method for V1RegionsGet

Get regions used for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1RegionsGetRequest
*/
func (a *DefaultAPIService) V1RegionsGet(ctx context.Context) ApiV1RegionsGetRequest {
	return ApiV1RegionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1RegionsGetResponse
func (a *DefaultAPIService) V1RegionsGetExecute(r ApiV1RegionsGetRequest) (*V1RegionsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1RegionsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1RegionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	maxResults *int32
	search *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SearchGetRequest) Authorization(authorization string) ApiV1SearchGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1SearchGetRequest) MaxResults(maxResults int32) ApiV1SearchGetRequest {
	r.maxResults = &maxResults
	return r
}

// 
func (r ApiV1SearchGetRequest) Search(search string) ApiV1SearchGetRequest {
	r.search = &search
	return r
}

func (r ApiV1SearchGetRequest) Execute() (*V1SearchGetResponse, *http.Response, error) {
	return r.ApiService.V1SearchGetExecute(r)
}

/*
V1SearchGet Method for V1SearchGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SearchGetRequest
*/
func (a *DefaultAPIService) V1SearchGet(ctx context.Context) ApiV1SearchGetRequest {
	return ApiV1SearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SearchGetResponse
func (a *DefaultAPIService) V1SearchGetExecute(r ApiV1SearchGetRequest) (*V1SearchGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SearchGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SiteDetailsSitelistsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SiteDetailsSitelistsPostRequest *V1SiteDetailsSitelistsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SiteDetailsSitelistsPostRequest) Authorization(authorization string) ApiV1SiteDetailsSitelistsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SiteDetailsSitelistsPostRequest) V1SiteDetailsSitelistsPostRequest(v1SiteDetailsSitelistsPostRequest V1SiteDetailsSitelistsPostRequest) ApiV1SiteDetailsSitelistsPostRequest {
	r.v1SiteDetailsSitelistsPostRequest = &v1SiteDetailsSitelistsPostRequest
	return r
}

func (r ApiV1SiteDetailsSitelistsPostRequest) Execute() (*V1SiteDetailsSitelistsPostResponse, *http.Response, error) {
	return r.ApiService.V1SiteDetailsSitelistsPostExecute(r)
}

/*
V1SiteDetailsSitelistsPost Method for V1SiteDetailsSitelistsPost

Get a list of site list references for a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SiteDetailsSitelistsPostRequest
*/
func (a *DefaultAPIService) V1SiteDetailsSitelistsPost(ctx context.Context) ApiV1SiteDetailsSitelistsPostRequest {
	return ApiV1SiteDetailsSitelistsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SiteDetailsSitelistsPostResponse
func (a *DefaultAPIService) V1SiteDetailsSitelistsPostExecute(r ApiV1SiteDetailsSitelistsPostRequest) (*V1SiteDetailsSitelistsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SiteDetailsSitelistsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SiteDetailsSitelistsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/site/details/sitelists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SiteDetailsSitelistsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SiteDetailsSitelistsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SiteDetailsSitelistsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SiteIdDetailsInterfacesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SiteIdDetailsInterfacesGetRequest) Authorization(authorization string) ApiV1SiteIdDetailsInterfacesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SiteIdDetailsInterfacesGetRequest) Execute() (*V1SiteIdDetailsInterfacesGetResponse, *http.Response, error) {
	return r.ApiService.V1SiteIdDetailsInterfacesGetExecute(r)
}

/*
V1SiteIdDetailsInterfacesGet Method for V1SiteIdDetailsInterfacesGet

Get a list of a site's interfaces, loopback listed first

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1SiteIdDetailsInterfacesGetRequest
*/
func (a *DefaultAPIService) V1SiteIdDetailsInterfacesGet(ctx context.Context, id int64) ApiV1SiteIdDetailsInterfacesGetRequest {
	return ApiV1SiteIdDetailsInterfacesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1SiteIdDetailsInterfacesGetResponse
func (a *DefaultAPIService) V1SiteIdDetailsInterfacesGetExecute(r ApiV1SiteIdDetailsInterfacesGetRequest) (*V1SiteIdDetailsInterfacesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SiteIdDetailsInterfacesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SiteIdDetailsInterfacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/site/{id}/details/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesDetailsGetRequest) Authorization(authorization string) ApiV1SitesDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesDetailsGetRequest) Execute() (*V1SitesDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1SitesDetailsGetExecute(r)
}

/*
V1SitesDetailsGet Method for V1SitesDetailsGet

Get a list of sites with aggregated values and site wide status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SitesDetailsGetRequest
*/
func (a *DefaultAPIService) V1SitesDetailsGet(ctx context.Context) ApiV1SitesDetailsGetRequest {
	return ApiV1SitesDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SitesDetailsGetResponse
func (a *DefaultAPIService) V1SitesDetailsGetExecute(r ApiV1SitesDetailsGetRequest) (*V1SitesDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesGetRequest) Authorization(authorization string) ApiV1SitesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesGetRequest) Execute() (*V1SitesGetResponse, *http.Response, error) {
	return r.ApiService.V1SitesGetExecute(r)
}

/*
V1SitesGet Method for V1SitesGet

Get sites for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SitesGetRequest
*/
func (a *DefaultAPIService) V1SitesGet(ctx context.Context) ApiV1SitesGetRequest {
	return ApiV1SitesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SitesGetResponse
func (a *DefaultAPIService) V1SitesGetExecute(r ApiV1SitesGetRequest) (*V1SitesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SitesPostRequest *V1SitesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesPostRequest) Authorization(authorization string) ApiV1SitesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesPostRequest) V1SitesPostRequest(v1SitesPostRequest V1SitesPostRequest) ApiV1SitesPostRequest {
	r.v1SitesPostRequest = &v1SitesPostRequest
	return r
}

func (r ApiV1SitesPostRequest) Execute() (*V1SitesPostResponse, *http.Response, error) {
	return r.ApiService.V1SitesPostExecute(r)
}

/*
V1SitesPost Method for V1SitesPost

Create an enterprise site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SitesPostRequest
*/
func (a *DefaultAPIService) V1SitesPost(ctx context.Context) ApiV1SitesPostRequest {
	return ApiV1SitesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SitesPostResponse
func (a *DefaultAPIService) V1SitesPostExecute(r ApiV1SitesPostRequest) (*V1SitesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SitesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SitesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SitesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdCircuitsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdCircuitsGetRequest) Authorization(authorization string) ApiV1SitesSiteIdCircuitsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdCircuitsGetRequest) Execute() (*V1SitesSiteIdCircuitsGetResponse, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdCircuitsGetExecute(r)
}

/*
V1SitesSiteIdCircuitsGet Method for V1SitesSiteIdCircuitsGet

Get Circuits for the site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdCircuitsGetRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdCircuitsGet(ctx context.Context, siteId int64) ApiV1SitesSiteIdCircuitsGetRequest {
	return ApiV1SitesSiteIdCircuitsGetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1SitesSiteIdCircuitsGetResponse
func (a *DefaultAPIService) V1SitesSiteIdCircuitsGetExecute(r ApiV1SitesSiteIdCircuitsGetRequest) (*V1SitesSiteIdCircuitsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesSiteIdCircuitsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdCircuitsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}/circuits"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdDeleteRequest) Authorization(authorization string) ApiV1SitesSiteIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1SitesSiteIdDeleteExecute(r)
}

/*
V1SitesSiteIdDelete Method for V1SitesSiteIdDelete

Delete a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdDeleteRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdDelete(ctx context.Context, siteId int64) ApiV1SitesSiteIdDeleteRequest {
	return ApiV1SitesSiteIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1SitesSiteIdDeleteExecute(r ApiV1SitesSiteIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdDevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdDevicesGetRequest) Authorization(authorization string) ApiV1SitesSiteIdDevicesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdDevicesGetRequest) Execute() (*V1SitesSiteIdDevicesGetResponse, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdDevicesGetExecute(r)
}

/*
V1SitesSiteIdDevicesGet Method for V1SitesSiteIdDevicesGet

Get Devices for the site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdDevicesGetRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdDevicesGet(ctx context.Context, siteId int64) ApiV1SitesSiteIdDevicesGetRequest {
	return ApiV1SitesSiteIdDevicesGetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1SitesSiteIdDevicesGetResponse
func (a *DefaultAPIService) V1SitesSiteIdDevicesGetExecute(r ApiV1SitesSiteIdDevicesGetRequest) (*V1SitesSiteIdDevicesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesSiteIdDevicesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdDevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.siteId < 0 {
		return localVarReturnValue, nil, reportError("siteId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v1SitesSiteIdPostRequest *V1SitesSiteIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdPostRequest) Authorization(authorization string) ApiV1SitesSiteIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdPostRequest) V1SitesSiteIdPostRequest(v1SitesSiteIdPostRequest V1SitesSiteIdPostRequest) ApiV1SitesSiteIdPostRequest {
	r.v1SitesSiteIdPostRequest = &v1SitesSiteIdPostRequest
	return r
}

func (r ApiV1SitesSiteIdPostRequest) Execute() (*V1SitesSiteIdPostResponse, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdPostExecute(r)
}

/*
V1SitesSiteIdPost Method for V1SitesSiteIdPost

Update a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdPostRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdPost(ctx context.Context, siteId int64) ApiV1SitesSiteIdPostRequest {
	return ApiV1SitesSiteIdPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1SitesSiteIdPostResponse
func (a *DefaultAPIService) V1SitesSiteIdPostExecute(r ApiV1SitesSiteIdPostRequest) (*V1SitesSiteIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesSiteIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SitesSiteIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SitesSiteIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SitesSiteIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareAutoUpgradeDefaultGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareAutoUpgradeDefaultGetRequest) Authorization(authorization string) ApiV1SoftwareAutoUpgradeDefaultGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareAutoUpgradeDefaultGetRequest) Execute() (*V1SoftwareAutoUpgradeDefaultGetResponse, *http.Response, error) {
	return r.ApiService.V1SoftwareAutoUpgradeDefaultGetExecute(r)
}

/*
V1SoftwareAutoUpgradeDefaultGet Method for V1SoftwareAutoUpgradeDefaultGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareAutoUpgradeDefaultGetRequest
*/
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultGet(ctx context.Context) ApiV1SoftwareAutoUpgradeDefaultGetRequest {
	return ApiV1SoftwareAutoUpgradeDefaultGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareAutoUpgradeDefaultGetResponse
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultGetExecute(r ApiV1SoftwareAutoUpgradeDefaultGetRequest) (*V1SoftwareAutoUpgradeDefaultGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareAutoUpgradeDefaultGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareAutoUpgradeDefaultGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/auto-upgrade/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareAutoUpgradeDefaultPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SoftwareAutoUpgradeDefaultPutRequest *V1SoftwareAutoUpgradeDefaultPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareAutoUpgradeDefaultPutRequest) Authorization(authorization string) ApiV1SoftwareAutoUpgradeDefaultPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareAutoUpgradeDefaultPutRequest) V1SoftwareAutoUpgradeDefaultPutRequest(v1SoftwareAutoUpgradeDefaultPutRequest V1SoftwareAutoUpgradeDefaultPutRequest) ApiV1SoftwareAutoUpgradeDefaultPutRequest {
	r.v1SoftwareAutoUpgradeDefaultPutRequest = &v1SoftwareAutoUpgradeDefaultPutRequest
	return r
}

func (r ApiV1SoftwareAutoUpgradeDefaultPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1SoftwareAutoUpgradeDefaultPutExecute(r)
}

/*
V1SoftwareAutoUpgradeDefaultPut Method for V1SoftwareAutoUpgradeDefaultPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareAutoUpgradeDefaultPutRequest
*/
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultPut(ctx context.Context) ApiV1SoftwareAutoUpgradeDefaultPutRequest {
	return ApiV1SoftwareAutoUpgradeDefaultPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultPutExecute(r ApiV1SoftwareAutoUpgradeDefaultPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareAutoUpgradeDefaultPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/auto-upgrade/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1SoftwareAutoUpgradeDefaultPutRequest == nil {
		return nil, reportError("v1SoftwareAutoUpgradeDefaultPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SoftwareAutoUpgradeDefaultPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1SoftwareGcsreleaseUploadNotesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SoftwareGcsreleaseUploadNotesPostRequest *V1SoftwareGcsreleaseUploadNotesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) Authorization(authorization string) ApiV1SoftwareGcsreleaseUploadNotesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) V1SoftwareGcsreleaseUploadNotesPostRequest(v1SoftwareGcsreleaseUploadNotesPostRequest V1SoftwareGcsreleaseUploadNotesPostRequest) ApiV1SoftwareGcsreleaseUploadNotesPostRequest {
	r.v1SoftwareGcsreleaseUploadNotesPostRequest = &v1SoftwareGcsreleaseUploadNotesPostRequest
	return r
}

func (r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1SoftwareGcsreleaseUploadNotesPostExecute(r)
}

/*
V1SoftwareGcsreleaseUploadNotesPost Method for V1SoftwareGcsreleaseUploadNotesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareGcsreleaseUploadNotesPostRequest
*/
func (a *DefaultAPIService) V1SoftwareGcsreleaseUploadNotesPost(ctx context.Context) ApiV1SoftwareGcsreleaseUploadNotesPostRequest {
	return ApiV1SoftwareGcsreleaseUploadNotesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1SoftwareGcsreleaseUploadNotesPostExecute(r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareGcsreleaseUploadNotesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/gcsrelease/upload/notes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SoftwareGcsreleaseUploadNotesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SoftwareGcsreleaseUploadNotesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SoftwareGcsreleaseUploadNotesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareReleaseNotesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareReleaseNotesGetRequest) Authorization(authorization string) ApiV1SoftwareReleaseNotesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareReleaseNotesGetRequest) Execute() (*V1SoftwareReleaseNotesGetResponse, *http.Response, error) {
	return r.ApiService.V1SoftwareReleaseNotesGetExecute(r)
}

/*
V1SoftwareReleaseNotesGet Method for V1SoftwareReleaseNotesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareReleaseNotesGetRequest
*/
func (a *DefaultAPIService) V1SoftwareReleaseNotesGet(ctx context.Context) ApiV1SoftwareReleaseNotesGetRequest {
	return ApiV1SoftwareReleaseNotesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareReleaseNotesGetResponse
func (a *DefaultAPIService) V1SoftwareReleaseNotesGetExecute(r ApiV1SoftwareReleaseNotesGetRequest) (*V1SoftwareReleaseNotesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareReleaseNotesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareReleaseNotesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/release/notes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareReleasesDownloadGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareReleasesDownloadGetRequest) Authorization(authorization string) ApiV1SoftwareReleasesDownloadGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareReleasesDownloadGetRequest) Execute() (*V1SoftwareReleasesDownloadGetResponse, *http.Response, error) {
	return r.ApiService.V1SoftwareReleasesDownloadGetExecute(r)
}

/*
V1SoftwareReleasesDownloadGet Method for V1SoftwareReleasesDownloadGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareReleasesDownloadGetRequest
*/
func (a *DefaultAPIService) V1SoftwareReleasesDownloadGet(ctx context.Context) ApiV1SoftwareReleasesDownloadGetRequest {
	return ApiV1SoftwareReleasesDownloadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareReleasesDownloadGetResponse
func (a *DefaultAPIService) V1SoftwareReleasesDownloadGetExecute(r ApiV1SoftwareReleasesDownloadGetRequest) (*V1SoftwareReleasesDownloadGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareReleasesDownloadGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareReleasesDownloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/releases/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareReleasesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareReleasesSummaryGetRequest) Authorization(authorization string) ApiV1SoftwareReleasesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareReleasesSummaryGetRequest) Execute() (*V1SoftwareReleasesSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1SoftwareReleasesSummaryGetExecute(r)
}

/*
V1SoftwareReleasesSummaryGet Method for V1SoftwareReleasesSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareReleasesSummaryGetRequest
*/
func (a *DefaultAPIService) V1SoftwareReleasesSummaryGet(ctx context.Context) ApiV1SoftwareReleasesSummaryGetRequest {
	return ApiV1SoftwareReleasesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareReleasesSummaryGetResponse
func (a *DefaultAPIService) V1SoftwareReleasesSummaryGetExecute(r ApiV1SoftwareReleasesSummaryGetRequest) (*V1SoftwareReleasesSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareReleasesSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareReleasesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/releases/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareRunningDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareRunningDetailsGetRequest) Authorization(authorization string) ApiV1SoftwareRunningDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareRunningDetailsGetRequest) Execute() (*V1SoftwareRunningDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V1SoftwareRunningDetailsGetExecute(r)
}

/*
V1SoftwareRunningDetailsGet Method for V1SoftwareRunningDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareRunningDetailsGetRequest
*/
func (a *DefaultAPIService) V1SoftwareRunningDetailsGet(ctx context.Context) ApiV1SoftwareRunningDetailsGetRequest {
	return ApiV1SoftwareRunningDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareRunningDetailsGetResponse
func (a *DefaultAPIService) V1SoftwareRunningDetailsGetExecute(r ApiV1SoftwareRunningDetailsGetRequest) (*V1SoftwareRunningDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareRunningDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareRunningDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/running/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareRunningSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareRunningSummaryGetRequest) Authorization(authorization string) ApiV1SoftwareRunningSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareRunningSummaryGetRequest) Execute() (*V1SoftwareRunningSummaryGetResponse, *http.Response, error) {
	return r.ApiService.V1SoftwareRunningSummaryGetExecute(r)
}

/*
V1SoftwareRunningSummaryGet Method for V1SoftwareRunningSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareRunningSummaryGetRequest
*/
func (a *DefaultAPIService) V1SoftwareRunningSummaryGet(ctx context.Context) ApiV1SoftwareRunningSummaryGetRequest {
	return ApiV1SoftwareRunningSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareRunningSummaryGetResponse
func (a *DefaultAPIService) V1SoftwareRunningSummaryGetExecute(r ApiV1SoftwareRunningSummaryGetRequest) (*V1SoftwareRunningSummaryGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareRunningSummaryGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareRunningSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/running/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TalkersDeviceDeviceIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1TalkersDeviceDeviceIdTopPostRequest *V1TalkersDeviceDeviceIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TalkersDeviceDeviceIdTopPostRequest) Authorization(authorization string) ApiV1TalkersDeviceDeviceIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TalkersDeviceDeviceIdTopPostRequest) V1TalkersDeviceDeviceIdTopPostRequest(v1TalkersDeviceDeviceIdTopPostRequest V1TalkersDeviceDeviceIdTopPostRequest) ApiV1TalkersDeviceDeviceIdTopPostRequest {
	r.v1TalkersDeviceDeviceIdTopPostRequest = &v1TalkersDeviceDeviceIdTopPostRequest
	return r
}

func (r ApiV1TalkersDeviceDeviceIdTopPostRequest) Execute() (*V1TalkersDeviceDeviceIdTopPostResponse, *http.Response, error) {
	return r.ApiService.V1TalkersDeviceDeviceIdTopPostExecute(r)
}

/*
V1TalkersDeviceDeviceIdTopPost Method for V1TalkersDeviceDeviceIdTopPost

Get top talkers for a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1TalkersDeviceDeviceIdTopPostRequest
*/
func (a *DefaultAPIService) V1TalkersDeviceDeviceIdTopPost(ctx context.Context, deviceId int64) ApiV1TalkersDeviceDeviceIdTopPostRequest {
	return ApiV1TalkersDeviceDeviceIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1TalkersDeviceDeviceIdTopPostResponse
func (a *DefaultAPIService) V1TalkersDeviceDeviceIdTopPostExecute(r ApiV1TalkersDeviceDeviceIdTopPostRequest) (*V1TalkersDeviceDeviceIdTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TalkersDeviceDeviceIdTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TalkersDeviceDeviceIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/talkers/device/{deviceId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TalkersDeviceDeviceIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TalkersDeviceDeviceIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TalkersDeviceDeviceIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TalkersSiteSiteIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v1TalkersSiteSiteIdTopPostRequest *V1TalkersSiteSiteIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TalkersSiteSiteIdTopPostRequest) Authorization(authorization string) ApiV1TalkersSiteSiteIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TalkersSiteSiteIdTopPostRequest) V1TalkersSiteSiteIdTopPostRequest(v1TalkersSiteSiteIdTopPostRequest V1TalkersSiteSiteIdTopPostRequest) ApiV1TalkersSiteSiteIdTopPostRequest {
	r.v1TalkersSiteSiteIdTopPostRequest = &v1TalkersSiteSiteIdTopPostRequest
	return r
}

func (r ApiV1TalkersSiteSiteIdTopPostRequest) Execute() (*V1TalkersSiteSiteIdTopPostResponse, *http.Response, error) {
	return r.ApiService.V1TalkersSiteSiteIdTopPostExecute(r)
}

/*
V1TalkersSiteSiteIdTopPost Method for V1TalkersSiteSiteIdTopPost

Get top talkers for a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1TalkersSiteSiteIdTopPostRequest
*/
func (a *DefaultAPIService) V1TalkersSiteSiteIdTopPost(ctx context.Context, siteId int64) ApiV1TalkersSiteSiteIdTopPostRequest {
	return ApiV1TalkersSiteSiteIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1TalkersSiteSiteIdTopPostResponse
func (a *DefaultAPIService) V1TalkersSiteSiteIdTopPostExecute(r ApiV1TalkersSiteSiteIdTopPostRequest) (*V1TalkersSiteSiteIdTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TalkersSiteSiteIdTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TalkersSiteSiteIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/talkers/site/{siteId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TalkersSiteSiteIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TalkersSiteSiteIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TalkersSiteSiteIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TempPasswordPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1TempPasswordPutRequest *V1TempPasswordPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TempPasswordPutRequest) Authorization(authorization string) ApiV1TempPasswordPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TempPasswordPutRequest) V1TempPasswordPutRequest(v1TempPasswordPutRequest V1TempPasswordPutRequest) ApiV1TempPasswordPutRequest {
	r.v1TempPasswordPutRequest = &v1TempPasswordPutRequest
	return r
}

func (r ApiV1TempPasswordPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1TempPasswordPutExecute(r)
}

/*
V1TempPasswordPut Method for V1TempPasswordPut

Generate and send temporary passwords to multiple emails for B2B service access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TempPasswordPutRequest
*/
func (a *DefaultAPIService) V1TempPasswordPut(ctx context.Context) ApiV1TempPasswordPutRequest {
	return ApiV1TempPasswordPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1TempPasswordPutExecute(r ApiV1TempPasswordPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TempPasswordPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/temp/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TempPasswordPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1TempPasswordPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TempPasswordPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingDeviceDeviceIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1TroubleshootingDeviceDeviceIdPostRequest *V1TroubleshootingDeviceDeviceIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingDeviceDeviceIdPostRequest) Authorization(authorization string) ApiV1TroubleshootingDeviceDeviceIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingDeviceDeviceIdPostRequest) V1TroubleshootingDeviceDeviceIdPostRequest(v1TroubleshootingDeviceDeviceIdPostRequest V1TroubleshootingDeviceDeviceIdPostRequest) ApiV1TroubleshootingDeviceDeviceIdPostRequest {
	r.v1TroubleshootingDeviceDeviceIdPostRequest = &v1TroubleshootingDeviceDeviceIdPostRequest
	return r
}

func (r ApiV1TroubleshootingDeviceDeviceIdPostRequest) Execute() (*V1TroubleshootingDeviceDeviceIdPostResponse, *http.Response, error) {
	return r.ApiService.V1TroubleshootingDeviceDeviceIdPostExecute(r)
}

/*
V1TroubleshootingDeviceDeviceIdPost Method for V1TroubleshootingDeviceDeviceIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1TroubleshootingDeviceDeviceIdPostRequest
*/
func (a *DefaultAPIService) V1TroubleshootingDeviceDeviceIdPost(ctx context.Context, deviceId int64) ApiV1TroubleshootingDeviceDeviceIdPostRequest {
	return ApiV1TroubleshootingDeviceDeviceIdPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1TroubleshootingDeviceDeviceIdPostResponse
func (a *DefaultAPIService) V1TroubleshootingDeviceDeviceIdPostExecute(r ApiV1TroubleshootingDeviceDeviceIdPostRequest) (*V1TroubleshootingDeviceDeviceIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingDeviceDeviceIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingDeviceDeviceIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/device/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TroubleshootingDeviceDeviceIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TroubleshootingDeviceDeviceIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TroubleshootingDeviceDeviceIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingEnterprisePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1TroubleshootingEnterprisePostRequest *V1TroubleshootingEnterprisePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingEnterprisePostRequest) Authorization(authorization string) ApiV1TroubleshootingEnterprisePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingEnterprisePostRequest) V1TroubleshootingEnterprisePostRequest(v1TroubleshootingEnterprisePostRequest V1TroubleshootingEnterprisePostRequest) ApiV1TroubleshootingEnterprisePostRequest {
	r.v1TroubleshootingEnterprisePostRequest = &v1TroubleshootingEnterprisePostRequest
	return r
}

func (r ApiV1TroubleshootingEnterprisePostRequest) Execute() (*V1TroubleshootingEnterprisePostResponse, *http.Response, error) {
	return r.ApiService.V1TroubleshootingEnterprisePostExecute(r)
}

/*
V1TroubleshootingEnterprisePost Method for V1TroubleshootingEnterprisePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingEnterprisePostRequest
*/
func (a *DefaultAPIService) V1TroubleshootingEnterprisePost(ctx context.Context) ApiV1TroubleshootingEnterprisePostRequest {
	return ApiV1TroubleshootingEnterprisePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingEnterprisePostResponse
func (a *DefaultAPIService) V1TroubleshootingEnterprisePostExecute(r ApiV1TroubleshootingEnterprisePostRequest) (*V1TroubleshootingEnterprisePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingEnterprisePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingEnterprisePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TroubleshootingEnterprisePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TroubleshootingEnterprisePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TroubleshootingEnterprisePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingFilterGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingFilterGetRequest) Authorization(authorization string) ApiV1TroubleshootingFilterGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingFilterGetRequest) Execute() (*V1TroubleshootingFilterGetResponse, *http.Response, error) {
	return r.ApiService.V1TroubleshootingFilterGetExecute(r)
}

/*
V1TroubleshootingFilterGet Method for V1TroubleshootingFilterGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingFilterGetRequest
*/
func (a *DefaultAPIService) V1TroubleshootingFilterGet(ctx context.Context) ApiV1TroubleshootingFilterGetRequest {
	return ApiV1TroubleshootingFilterGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingFilterGetResponse
func (a *DefaultAPIService) V1TroubleshootingFilterGetExecute(r ApiV1TroubleshootingFilterGetRequest) (*V1TroubleshootingFilterGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingFilterGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingFilterGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingSiteConnectivityStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingSiteConnectivityStatusGetRequest) Authorization(authorization string) ApiV1TroubleshootingSiteConnectivityStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingSiteConnectivityStatusGetRequest) Execute() (*V1TroubleshootingSiteConnectivityStatusGetResponse, *http.Response, error) {
	return r.ApiService.V1TroubleshootingSiteConnectivityStatusGetExecute(r)
}

/*
V1TroubleshootingSiteConnectivityStatusGet Method for V1TroubleshootingSiteConnectivityStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingSiteConnectivityStatusGetRequest
*/
func (a *DefaultAPIService) V1TroubleshootingSiteConnectivityStatusGet(ctx context.Context) ApiV1TroubleshootingSiteConnectivityStatusGetRequest {
	return ApiV1TroubleshootingSiteConnectivityStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingSiteConnectivityStatusGetResponse
func (a *DefaultAPIService) V1TroubleshootingSiteConnectivityStatusGetExecute(r ApiV1TroubleshootingSiteConnectivityStatusGetRequest) (*V1TroubleshootingSiteConnectivityStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingSiteConnectivityStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingSiteConnectivityStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/site-connectivity-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingSiteSiteIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingSiteSiteIdGetRequest) Authorization(authorization string) ApiV1TroubleshootingSiteSiteIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingSiteSiteIdGetRequest) Execute() (*V1TroubleshootingSiteSiteIdGetResponse, *http.Response, error) {
	return r.ApiService.V1TroubleshootingSiteSiteIdGetExecute(r)
}

/*
V1TroubleshootingSiteSiteIdGet Method for V1TroubleshootingSiteSiteIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1TroubleshootingSiteSiteIdGetRequest
*/
func (a *DefaultAPIService) V1TroubleshootingSiteSiteIdGet(ctx context.Context, siteId int64) ApiV1TroubleshootingSiteSiteIdGetRequest {
	return ApiV1TroubleshootingSiteSiteIdGetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1TroubleshootingSiteSiteIdGetResponse
func (a *DefaultAPIService) V1TroubleshootingSiteSiteIdGetExecute(r ApiV1TroubleshootingSiteSiteIdGetRequest) (*V1TroubleshootingSiteSiteIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingSiteSiteIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingSiteSiteIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/site/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingTopSitesByAlertsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1TroubleshootingTopSitesByAlertsPostRequest *V1TroubleshootingTopSitesByAlertsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingTopSitesByAlertsPostRequest) Authorization(authorization string) ApiV1TroubleshootingTopSitesByAlertsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingTopSitesByAlertsPostRequest) V1TroubleshootingTopSitesByAlertsPostRequest(v1TroubleshootingTopSitesByAlertsPostRequest V1TroubleshootingTopSitesByAlertsPostRequest) ApiV1TroubleshootingTopSitesByAlertsPostRequest {
	r.v1TroubleshootingTopSitesByAlertsPostRequest = &v1TroubleshootingTopSitesByAlertsPostRequest
	return r
}

func (r ApiV1TroubleshootingTopSitesByAlertsPostRequest) Execute() (*V1TroubleshootingTopSitesByAlertsPostResponse, *http.Response, error) {
	return r.ApiService.V1TroubleshootingTopSitesByAlertsPostExecute(r)
}

/*
V1TroubleshootingTopSitesByAlertsPost Method for V1TroubleshootingTopSitesByAlertsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingTopSitesByAlertsPostRequest
*/
func (a *DefaultAPIService) V1TroubleshootingTopSitesByAlertsPost(ctx context.Context) ApiV1TroubleshootingTopSitesByAlertsPostRequest {
	return ApiV1TroubleshootingTopSitesByAlertsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingTopSitesByAlertsPostResponse
func (a *DefaultAPIService) V1TroubleshootingTopSitesByAlertsPostExecute(r ApiV1TroubleshootingTopSitesByAlertsPostRequest) (*V1TroubleshootingTopSitesByAlertsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingTopSitesByAlertsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingTopSitesByAlertsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/top-sites-by-alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TroubleshootingTopSitesByAlertsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TroubleshootingTopSitesByAlertsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TroubleshootingTopSitesByAlertsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TtTtIdentityDeviceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	ttIdentity string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TtTtIdentityDeviceStatusGetRequest) Authorization(authorization string) ApiV1TtTtIdentityDeviceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TtTtIdentityDeviceStatusGetRequest) Execute() (*V1TtTtIdentityDeviceStatusGetResponse, *http.Response, error) {
	return r.ApiService.V1TtTtIdentityDeviceStatusGetExecute(r)
}

/*
V1TtTtIdentityDeviceStatusGet Method for V1TtTtIdentityDeviceStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ttIdentity 
 @return ApiV1TtTtIdentityDeviceStatusGetRequest
*/
func (a *DefaultAPIService) V1TtTtIdentityDeviceStatusGet(ctx context.Context, ttIdentity string) ApiV1TtTtIdentityDeviceStatusGetRequest {
	return ApiV1TtTtIdentityDeviceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		ttIdentity: ttIdentity,
	}
}

// Execute executes the request
//  @return V1TtTtIdentityDeviceStatusGetResponse
func (a *DefaultAPIService) V1TtTtIdentityDeviceStatusGetExecute(r ApiV1TtTtIdentityDeviceStatusGetRequest) (*V1TtTtIdentityDeviceStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TtTtIdentityDeviceStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TtTtIdentityDeviceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tt/{ttIdentity}/device-status"
	localVarPath = strings.Replace(localVarPath, "{"+"ttIdentity"+"}", url.PathEscape(parameterValueToString(r.ttIdentity, "ttIdentity")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersEmailPasswordPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	email string
	token *string
	v1UsersEmailPasswordPatchRequest *V1UsersEmailPasswordPatchRequest
}

// Password reset token
func (r ApiV1UsersEmailPasswordPatchRequest) Token(token string) ApiV1UsersEmailPasswordPatchRequest {
	r.token = &token
	return r
}

func (r ApiV1UsersEmailPasswordPatchRequest) V1UsersEmailPasswordPatchRequest(v1UsersEmailPasswordPatchRequest V1UsersEmailPasswordPatchRequest) ApiV1UsersEmailPasswordPatchRequest {
	r.v1UsersEmailPasswordPatchRequest = &v1UsersEmailPasswordPatchRequest
	return r
}

func (r ApiV1UsersEmailPasswordPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1UsersEmailPasswordPatchExecute(r)
}

/*
V1UsersEmailPasswordPatch Method for V1UsersEmailPasswordPatch

Change password for a user using email and token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param email User email address
 @return ApiV1UsersEmailPasswordPatchRequest
*/
func (a *DefaultAPIService) V1UsersEmailPasswordPatch(ctx context.Context, email string) ApiV1UsersEmailPasswordPatchRequest {
	return ApiV1UsersEmailPasswordPatchRequest{
		ApiService: a,
		ctx: ctx,
		email: email,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1UsersEmailPasswordPatchExecute(r ApiV1UsersEmailPasswordPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersEmailPasswordPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{email}/password"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", url.PathEscape(parameterValueToString(r.email, "email")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return nil, reportError("token is required and must be specified")
	}
	if r.v1UsersEmailPasswordPatchRequest == nil {
		return nil, reportError("v1UsersEmailPasswordPatchRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1UsersEmailPasswordPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1UsersEmailRecoveryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	email string
}

func (r ApiV1UsersEmailRecoveryGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1UsersEmailRecoveryGetExecute(r)
}

/*
V1UsersEmailRecoveryGet Method for V1UsersEmailRecoveryGet

Send password recovery email to user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param email User email address
 @return ApiV1UsersEmailRecoveryGetRequest
*/
func (a *DefaultAPIService) V1UsersEmailRecoveryGet(ctx context.Context, email string) ApiV1UsersEmailRecoveryGetRequest {
	return ApiV1UsersEmailRecoveryGetRequest{
		ApiService: a,
		ctx: ctx,
		email: email,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1UsersEmailRecoveryGetExecute(r ApiV1UsersEmailRecoveryGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersEmailRecoveryGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{email}/recovery"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", url.PathEscape(parameterValueToString(r.email, "email")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1UsersEmailVerifiedPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	email string
	token *string
}

// Email verification token
func (r ApiV1UsersEmailVerifiedPatchRequest) Token(token string) ApiV1UsersEmailVerifiedPatchRequest {
	r.token = &token
	return r
}

func (r ApiV1UsersEmailVerifiedPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1UsersEmailVerifiedPatchExecute(r)
}

/*
V1UsersEmailVerifiedPatch Method for V1UsersEmailVerifiedPatch

Verify user email using verification token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param email User email address
 @return ApiV1UsersEmailVerifiedPatchRequest
*/
func (a *DefaultAPIService) V1UsersEmailVerifiedPatch(ctx context.Context, email string) ApiV1UsersEmailVerifiedPatchRequest {
	return ApiV1UsersEmailVerifiedPatchRequest{
		ApiService: a,
		ctx: ctx,
		email: email,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1UsersEmailVerifiedPatchExecute(r ApiV1UsersEmailVerifiedPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersEmailVerifiedPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{email}/verified"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", url.PathEscape(parameterValueToString(r.email, "email")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.token == nil {
		return nil, reportError("token is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1UsersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersGetRequest) Authorization(authorization string) ApiV1UsersGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1UsersGetRequest) Id(id string) ApiV1UsersGetRequest {
	r.id = &id
	return r
}

func (r ApiV1UsersGetRequest) Execute() (*V1UsersGetResponse, *http.Response, error) {
	return r.ApiService.V1UsersGetExecute(r)
}

/*
V1UsersGet Method for V1UsersGet

Get user information by user IDs with detailed profile data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1UsersGetRequest
*/
func (a *DefaultAPIService) V1UsersGet(ctx context.Context) ApiV1UsersGetRequest {
	return ApiV1UsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1UsersGetResponse
func (a *DefaultAPIService) V1UsersGetExecute(r ApiV1UsersGetRequest) (*V1UsersGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UsersGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdDeleteRequest) Authorization(authorization string) ApiV1UsersIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1UsersIdDeleteExecute(r)
}

/*
V1UsersIdDelete Method for V1UsersIdDelete

Delete user account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdDeleteRequest
*/
func (a *DefaultAPIService) V1UsersIdDelete(ctx context.Context, id string) ApiV1UsersIdDeleteRequest {
	return ApiV1UsersIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1UsersIdDeleteExecute(r ApiV1UsersIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1UsersIdEnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdEnterprisesGetRequest) Authorization(authorization string) ApiV1UsersIdEnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdEnterprisesGetRequest) Execute() (*V1UsersIdEnterprisesGetResponse, *http.Response, error) {
	return r.ApiService.V1UsersIdEnterprisesGetExecute(r)
}

/*
V1UsersIdEnterprisesGet Method for V1UsersIdEnterprisesGet

Get all enterprises a specific user can access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdEnterprisesGetRequest
*/
func (a *DefaultAPIService) V1UsersIdEnterprisesGet(ctx context.Context, id string) ApiV1UsersIdEnterprisesGetRequest {
	return ApiV1UsersIdEnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1UsersIdEnterprisesGetResponse
func (a *DefaultAPIService) V1UsersIdEnterprisesGetExecute(r ApiV1UsersIdEnterprisesGetRequest) (*V1UsersIdEnterprisesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UsersIdEnterprisesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdEnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/enterprises"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdGroupsEnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdGroupsEnterprisesGetRequest) Authorization(authorization string) ApiV1UsersIdGroupsEnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdGroupsEnterprisesGetRequest) Execute() (*V1UsersIdGroupsEnterprisesGetResponse, *http.Response, error) {
	return r.ApiService.V1UsersIdGroupsEnterprisesGetExecute(r)
}

/*
V1UsersIdGroupsEnterprisesGet Method for V1UsersIdGroupsEnterprisesGet

Get enterprise-specific groups for a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdGroupsEnterprisesGetRequest
*/
func (a *DefaultAPIService) V1UsersIdGroupsEnterprisesGet(ctx context.Context, id string) ApiV1UsersIdGroupsEnterprisesGetRequest {
	return ApiV1UsersIdGroupsEnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1UsersIdGroupsEnterprisesGetResponse
func (a *DefaultAPIService) V1UsersIdGroupsEnterprisesGetExecute(r ApiV1UsersIdGroupsEnterprisesGetRequest) (*V1UsersIdGroupsEnterprisesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UsersIdGroupsEnterprisesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdGroupsEnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/groups/enterprises"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdGroupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdGroupsGetRequest) Authorization(authorization string) ApiV1UsersIdGroupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdGroupsGetRequest) Execute() (*V1UsersIdGroupsGetResponse, *http.Response, error) {
	return r.ApiService.V1UsersIdGroupsGetExecute(r)
}

/*
V1UsersIdGroupsGet Method for V1UsersIdGroupsGet

Get all groups that a specific user belongs to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdGroupsGetRequest
*/
func (a *DefaultAPIService) V1UsersIdGroupsGet(ctx context.Context, id string) ApiV1UsersIdGroupsGetRequest {
	return ApiV1UsersIdGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1UsersIdGroupsGetResponse
func (a *DefaultAPIService) V1UsersIdGroupsGetExecute(r ApiV1UsersIdGroupsGetRequest) (*V1UsersIdGroupsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UsersIdGroupsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdGroupsRootGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdGroupsRootGetRequest) Authorization(authorization string) ApiV1UsersIdGroupsRootGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdGroupsRootGetRequest) Execute() (*V1UsersIdGroupsRootGetResponse, *http.Response, error) {
	return r.ApiService.V1UsersIdGroupsRootGetExecute(r)
}

/*
V1UsersIdGroupsRootGet Method for V1UsersIdGroupsRootGet

Get root-level groups for a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdGroupsRootGetRequest
*/
func (a *DefaultAPIService) V1UsersIdGroupsRootGet(ctx context.Context, id string) ApiV1UsersIdGroupsRootGetRequest {
	return ApiV1UsersIdGroupsRootGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1UsersIdGroupsRootGetResponse
func (a *DefaultAPIService) V1UsersIdGroupsRootGetExecute(r ApiV1UsersIdGroupsRootGetRequest) (*V1UsersIdGroupsRootGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UsersIdGroupsRootGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdGroupsRootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/groups/root"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdVerifyPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdVerifyPatchRequest) Authorization(authorization string) ApiV1UsersIdVerifyPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdVerifyPatchRequest) Body(body map[string]interface{}) ApiV1UsersIdVerifyPatchRequest {
	r.body = &body
	return r
}

func (r ApiV1UsersIdVerifyPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1UsersIdVerifyPatchExecute(r)
}

/*
V1UsersIdVerifyPatch Method for V1UsersIdVerifyPatch

Resend account verification email to user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdVerifyPatchRequest
*/
func (a *DefaultAPIService) V1UsersIdVerifyPatch(ctx context.Context, id string) ApiV1UsersIdVerifyPatchRequest {
	return ApiV1UsersIdVerifyPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1UsersIdVerifyPatchExecute(r ApiV1UsersIdVerifyPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdVerifyPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1UsersPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1UsersPutRequest *V1UsersPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersPutRequest) Authorization(authorization string) ApiV1UsersPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersPutRequest) V1UsersPutRequest(v1UsersPutRequest V1UsersPutRequest) ApiV1UsersPutRequest {
	r.v1UsersPutRequest = &v1UsersPutRequest
	return r
}

func (r ApiV1UsersPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1UsersPutExecute(r)
}

/*
V1UsersPut Method for V1UsersPut

Create a new user account with profile information. Assigns to specified group or default read-only group. Handles both IDP and non-IDP configured enterprises.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1UsersPutRequest
*/
func (a *DefaultAPIService) V1UsersPut(ctx context.Context) ApiV1UsersPutRequest {
	return ApiV1UsersPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1UsersPutExecute(r ApiV1UsersPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.v1UsersPutRequest == nil {
		return nil, reportError("v1UsersPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1UsersPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1VersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1VersionPostRequest *V1VersionPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1VersionPostRequest) Authorization(authorization string) ApiV1VersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1VersionPostRequest) V1VersionPostRequest(v1VersionPostRequest V1VersionPostRequest) ApiV1VersionPostRequest {
	r.v1VersionPostRequest = &v1VersionPostRequest
	return r
}

func (r ApiV1VersionPostRequest) Execute() (*V1VersionPostResponse, *http.Response, error) {
	return r.ApiService.V1VersionPostExecute(r)
}

/*
V1VersionPost Method for V1VersionPost

Update device config version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1VersionPostRequest
*/
func (a *DefaultAPIService) V1VersionPost(ctx context.Context) ApiV1VersionPostRequest {
	return ApiV1VersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1VersionPostResponse
func (a *DefaultAPIService) V1VersionPostExecute(r ApiV1VersionPostRequest) (*V1VersionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1VersionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1VersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1VersionPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1VersionPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1VersionPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ZonesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ZonesGetRequest) Authorization(authorization string) ApiV1ZonesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ZonesGetRequest) Execute() (*V1ZonesGetResponse, *http.Response, error) {
	return r.ApiService.V1ZonesGetExecute(r)
}

/*
V1ZonesGet Method for V1ZonesGet

Get Zones for the current enterprise

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ZonesGetRequest
*/
func (a *DefaultAPIService) V1ZonesGet(ctx context.Context) ApiV1ZonesGetRequest {
	return ApiV1ZonesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ZonesGetResponse
func (a *DefaultAPIService) V1ZonesGetExecute(r ApiV1ZonesGetRequest) (*V1ZonesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ZonesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ZonesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AckCreateupdatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AckCreateupdatePostRequest *V2AckCreateupdatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AckCreateupdatePostRequest) Authorization(authorization string) ApiV2AckCreateupdatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AckCreateupdatePostRequest) V2AckCreateupdatePostRequest(v2AckCreateupdatePostRequest V2AckCreateupdatePostRequest) ApiV2AckCreateupdatePostRequest {
	r.v2AckCreateupdatePostRequest = &v2AckCreateupdatePostRequest
	return r
}

func (r ApiV2AckCreateupdatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AckCreateupdatePostExecute(r)
}

/*
V2AckCreateupdatePost Method for V2AckCreateupdatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AckCreateupdatePostRequest
*/
func (a *DefaultAPIService) V2AckCreateupdatePost(ctx context.Context) ApiV2AckCreateupdatePostRequest {
	return ApiV2AckCreateupdatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AckCreateupdatePostExecute(r ApiV2AckCreateupdatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AckCreateupdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/ack/createupdate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AckCreateupdatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AckCreateupdatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AckCreateupdatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AggregatedNotificationEnableDisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AggregatedNotificationEnableDisablePostRequest *V2AggregatedNotificationEnableDisablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AggregatedNotificationEnableDisablePostRequest) Authorization(authorization string) ApiV2AggregatedNotificationEnableDisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AggregatedNotificationEnableDisablePostRequest) V2AggregatedNotificationEnableDisablePostRequest(v2AggregatedNotificationEnableDisablePostRequest V2AggregatedNotificationEnableDisablePostRequest) ApiV2AggregatedNotificationEnableDisablePostRequest {
	r.v2AggregatedNotificationEnableDisablePostRequest = &v2AggregatedNotificationEnableDisablePostRequest
	return r
}

func (r ApiV2AggregatedNotificationEnableDisablePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AggregatedNotificationEnableDisablePostExecute(r)
}

/*
V2AggregatedNotificationEnableDisablePost Method for V2AggregatedNotificationEnableDisablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AggregatedNotificationEnableDisablePostRequest
*/
func (a *DefaultAPIService) V2AggregatedNotificationEnableDisablePost(ctx context.Context) ApiV2AggregatedNotificationEnableDisablePostRequest {
	return ApiV2AggregatedNotificationEnableDisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AggregatedNotificationEnableDisablePostExecute(r ApiV2AggregatedNotificationEnableDisablePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AggregatedNotificationEnableDisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/aggregated-notification/enable-disable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AggregatedNotificationEnableDisablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AggregatedNotificationEnableDisablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AggregatedNotificationEnableDisablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AggregatedNotificationGetStateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AggregatedNotificationGetStateGetRequest) Authorization(authorization string) ApiV2AggregatedNotificationGetStateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AggregatedNotificationGetStateGetRequest) Execute() (*V2AggregatedNotificationGetStateGetResponse, *http.Response, error) {
	return r.ApiService.V2AggregatedNotificationGetStateGetExecute(r)
}

/*
V2AggregatedNotificationGetStateGet Method for V2AggregatedNotificationGetStateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AggregatedNotificationGetStateGetRequest
*/
func (a *DefaultAPIService) V2AggregatedNotificationGetStateGet(ctx context.Context) ApiV2AggregatedNotificationGetStateGetRequest {
	return ApiV2AggregatedNotificationGetStateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AggregatedNotificationGetStateGetResponse
func (a *DefaultAPIService) V2AggregatedNotificationGetStateGetExecute(r ApiV2AggregatedNotificationGetStateGetRequest) (*V2AggregatedNotificationGetStateGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AggregatedNotificationGetStateGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AggregatedNotificationGetStateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/aggregated-notification/get-state"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistByEnterpriseGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistByEnterpriseGetRequest) Authorization(authorization string) ApiV2AllowlistByEnterpriseGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistByEnterpriseGetRequest) Execute() (*V2AllowlistByEnterpriseGetResponse, *http.Response, error) {
	return r.ApiService.V2AllowlistByEnterpriseGetExecute(r)
}

/*
V2AllowlistByEnterpriseGet Method for V2AllowlistByEnterpriseGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AllowlistByEnterpriseGetRequest
*/
func (a *DefaultAPIService) V2AllowlistByEnterpriseGet(ctx context.Context) ApiV2AllowlistByEnterpriseGetRequest {
	return ApiV2AllowlistByEnterpriseGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AllowlistByEnterpriseGetResponse
func (a *DefaultAPIService) V2AllowlistByEnterpriseGetExecute(r ApiV2AllowlistByEnterpriseGetRequest) (*V2AllowlistByEnterpriseGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AllowlistByEnterpriseGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistByEnterpriseGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist-by-enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AllowlistCreatePostRequest *V2AllowlistCreatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistCreatePostRequest) Authorization(authorization string) ApiV2AllowlistCreatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistCreatePostRequest) V2AllowlistCreatePostRequest(v2AllowlistCreatePostRequest V2AllowlistCreatePostRequest) ApiV2AllowlistCreatePostRequest {
	r.v2AllowlistCreatePostRequest = &v2AllowlistCreatePostRequest
	return r
}

func (r ApiV2AllowlistCreatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AllowlistCreatePostExecute(r)
}

/*
V2AllowlistCreatePost Method for V2AllowlistCreatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AllowlistCreatePostRequest
*/
func (a *DefaultAPIService) V2AllowlistCreatePost(ctx context.Context) ApiV2AllowlistCreatePostRequest {
	return ApiV2AllowlistCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AllowlistCreatePostExecute(r ApiV2AllowlistCreatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AllowlistCreatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AllowlistCreatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AllowlistCreatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	alertId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest) Authorization(authorization string) ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AllowlistDeletebyalertidAlertIdDeleteExecute(r)
}

/*
V2AllowlistDeletebyalertidAlertIdDelete Method for V2AllowlistDeletebyalertidAlertIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertId Alert id of the alert to delete allowlist/mutelist for
 @return ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest
*/
func (a *DefaultAPIService) V2AllowlistDeletebyalertidAlertIdDelete(ctx context.Context, alertId string) ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest {
	return ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		alertId: alertId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AllowlistDeletebyalertidAlertIdDeleteExecute(r ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistDeletebyalertidAlertIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/deletebyalertid/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	entityId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest) Authorization(authorization string) ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AllowlistDeletebyentityidEntityIdDeleteExecute(r)
}

/*
V2AllowlistDeletebyentityidEntityIdDelete Method for V2AllowlistDeletebyentityidEntityIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityId Entity id of the alert to delete allowlist/mutelist for
 @return ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest
*/
func (a *DefaultAPIService) V2AllowlistDeletebyentityidEntityIdDelete(ctx context.Context, entityId string) ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest {
	return ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		entityId: entityId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AllowlistDeletebyentityidEntityIdDeleteExecute(r ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistDeletebyentityidEntityIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/deletebyentityid/{entityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", url.PathEscape(parameterValueToString(r.entityId, "entityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistRuleIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	ruleId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistRuleIdGetRequest) Authorization(authorization string) ApiV2AllowlistRuleIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistRuleIdGetRequest) Execute() (*V2AllowlistRuleIdGetResponse, *http.Response, error) {
	return r.ApiService.V2AllowlistRuleIdGetExecute(r)
}

/*
V2AllowlistRuleIdGet Method for V2AllowlistRuleIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleId Alert id of the alert to retrieve allowlist/mutelist for
 @return ApiV2AllowlistRuleIdGetRequest
*/
func (a *DefaultAPIService) V2AllowlistRuleIdGet(ctx context.Context, ruleId string) ApiV2AllowlistRuleIdGetRequest {
	return ApiV2AllowlistRuleIdGetRequest{
		ApiService: a,
		ctx: ctx,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return V2AllowlistRuleIdGetResponse
func (a *DefaultAPIService) V2AllowlistRuleIdGetExecute(r ApiV2AllowlistRuleIdGetRequest) (*V2AllowlistRuleIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AllowlistRuleIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistRuleIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantAddToConversationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantAddToConversationPostRequest *V2AssistantAddToConversationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantAddToConversationPostRequest) Authorization(authorization string) ApiV2AssistantAddToConversationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantAddToConversationPostRequest) V2AssistantAddToConversationPostRequest(v2AssistantAddToConversationPostRequest V2AssistantAddToConversationPostRequest) ApiV2AssistantAddToConversationPostRequest {
	r.v2AssistantAddToConversationPostRequest = &v2AssistantAddToConversationPostRequest
	return r
}

func (r ApiV2AssistantAddToConversationPostRequest) Execute() (*V2AssistantAddToConversationPostResponse, *http.Response, error) {
	return r.ApiService.V2AssistantAddToConversationPostExecute(r)
}

/*
V2AssistantAddToConversationPost Method for V2AssistantAddToConversationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantAddToConversationPostRequest
*/
func (a *DefaultAPIService) V2AssistantAddToConversationPost(ctx context.Context) ApiV2AssistantAddToConversationPostRequest {
	return ApiV2AssistantAddToConversationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantAddToConversationPostResponse
func (a *DefaultAPIService) V2AssistantAddToConversationPostExecute(r ApiV2AssistantAddToConversationPostRequest) (*V2AssistantAddToConversationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantAddToConversationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantAddToConversationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/add-to-conversation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantAddToConversationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantAddToConversationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantAddToConversationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantConversationContextHistoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantConversationContextHistoryPostRequest *V2AssistantConversationContextHistoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantConversationContextHistoryPostRequest) Authorization(authorization string) ApiV2AssistantConversationContextHistoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantConversationContextHistoryPostRequest) V2AssistantConversationContextHistoryPostRequest(v2AssistantConversationContextHistoryPostRequest V2AssistantConversationContextHistoryPostRequest) ApiV2AssistantConversationContextHistoryPostRequest {
	r.v2AssistantConversationContextHistoryPostRequest = &v2AssistantConversationContextHistoryPostRequest
	return r
}

func (r ApiV2AssistantConversationContextHistoryPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantConversationContextHistoryPostExecute(r)
}

/*
V2AssistantConversationContextHistoryPost Method for V2AssistantConversationContextHistoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantConversationContextHistoryPostRequest
*/
func (a *DefaultAPIService) V2AssistantConversationContextHistoryPost(ctx context.Context) ApiV2AssistantConversationContextHistoryPostRequest {
	return ApiV2AssistantConversationContextHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantConversationContextHistoryPostExecute(r ApiV2AssistantConversationContextHistoryPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantConversationContextHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/conversation-context-history/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantConversationContextHistoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantConversationContextHistoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantConversationContextHistoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	conversationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantConversationIdDeleteRequest) Authorization(authorization string) ApiV2AssistantConversationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantConversationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantConversationIdDeleteExecute(r)
}

/*
V2AssistantConversationIdDelete Method for V2AssistantConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId 
 @return ApiV2AssistantConversationIdDeleteRequest
*/
func (a *DefaultAPIService) V2AssistantConversationIdDelete(ctx context.Context, conversationId int64) ApiV2AssistantConversationIdDeleteRequest {
	return ApiV2AssistantConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantConversationIdDeleteExecute(r ApiV2AssistantConversationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/{conversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversationId"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantConversationInterfaceEnableDisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantConversationInterfaceEnableDisablePostRequest *V2AssistantConversationInterfaceEnableDisablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantConversationInterfaceEnableDisablePostRequest) Authorization(authorization string) ApiV2AssistantConversationInterfaceEnableDisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantConversationInterfaceEnableDisablePostRequest) V2AssistantConversationInterfaceEnableDisablePostRequest(v2AssistantConversationInterfaceEnableDisablePostRequest V2AssistantConversationInterfaceEnableDisablePostRequest) ApiV2AssistantConversationInterfaceEnableDisablePostRequest {
	r.v2AssistantConversationInterfaceEnableDisablePostRequest = &v2AssistantConversationInterfaceEnableDisablePostRequest
	return r
}

func (r ApiV2AssistantConversationInterfaceEnableDisablePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantConversationInterfaceEnableDisablePostExecute(r)
}

/*
V2AssistantConversationInterfaceEnableDisablePost Method for V2AssistantConversationInterfaceEnableDisablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantConversationInterfaceEnableDisablePostRequest
*/
func (a *DefaultAPIService) V2AssistantConversationInterfaceEnableDisablePost(ctx context.Context) ApiV2AssistantConversationInterfaceEnableDisablePostRequest {
	return ApiV2AssistantConversationInterfaceEnableDisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantConversationInterfaceEnableDisablePostExecute(r ApiV2AssistantConversationInterfaceEnableDisablePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantConversationInterfaceEnableDisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/conversation-interface-enable-disable/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantConversationInterfaceEnableDisablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantConversationInterfaceEnableDisablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantConversationInterfaceEnableDisablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantConversationInterfaceStateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantConversationInterfaceStateGetRequest) Authorization(authorization string) ApiV2AssistantConversationInterfaceStateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantConversationInterfaceStateGetRequest) Execute() (*V2AssistantConversationInterfaceStateGetResponse, *http.Response, error) {
	return r.ApiService.V2AssistantConversationInterfaceStateGetExecute(r)
}

/*
V2AssistantConversationInterfaceStateGet Method for V2AssistantConversationInterfaceStateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantConversationInterfaceStateGetRequest
*/
func (a *DefaultAPIService) V2AssistantConversationInterfaceStateGet(ctx context.Context) ApiV2AssistantConversationInterfaceStateGetRequest {
	return ApiV2AssistantConversationInterfaceStateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantConversationInterfaceStateGetResponse
func (a *DefaultAPIService) V2AssistantConversationInterfaceStateGetExecute(r ApiV2AssistantConversationInterfaceStateGetRequest) (*V2AssistantConversationInterfaceStateGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantConversationInterfaceStateGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantConversationInterfaceStateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/conversation-interface-state/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	conversationId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest) Authorization(authorization string) ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantDeleteConversationChatConversationIdDeleteExecute(r)
}

/*
V2AssistantDeleteConversationChatConversationIdDelete Method for V2AssistantDeleteConversationChatConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId 
 @return ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest
*/
func (a *DefaultAPIService) V2AssistantDeleteConversationChatConversationIdDelete(ctx context.Context, conversationId string) ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest {
	return ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantDeleteConversationChatConversationIdDeleteExecute(r ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantDeleteConversationChatConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/delete-conversation-chat/{conversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversationId"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantDeleteConversationConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	conversationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantDeleteConversationConversationIdDeleteRequest) Authorization(authorization string) ApiV2AssistantDeleteConversationConversationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantDeleteConversationConversationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantDeleteConversationConversationIdDeleteExecute(r)
}

/*
V2AssistantDeleteConversationConversationIdDelete Method for V2AssistantDeleteConversationConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId 
 @return ApiV2AssistantDeleteConversationConversationIdDeleteRequest
*/
func (a *DefaultAPIService) V2AssistantDeleteConversationConversationIdDelete(ctx context.Context, conversationId int64) ApiV2AssistantDeleteConversationConversationIdDeleteRequest {
	return ApiV2AssistantDeleteConversationConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantDeleteConversationConversationIdDeleteExecute(r ApiV2AssistantDeleteConversationConversationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantDeleteConversationConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/delete-conversation/{conversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversationId"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantGetConversationDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantGetConversationDetailsPostRequest *V2AssistantGetConversationDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantGetConversationDetailsPostRequest) Authorization(authorization string) ApiV2AssistantGetConversationDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantGetConversationDetailsPostRequest) V2AssistantGetConversationDetailsPostRequest(v2AssistantGetConversationDetailsPostRequest V2AssistantGetConversationDetailsPostRequest) ApiV2AssistantGetConversationDetailsPostRequest {
	r.v2AssistantGetConversationDetailsPostRequest = &v2AssistantGetConversationDetailsPostRequest
	return r
}

func (r ApiV2AssistantGetConversationDetailsPostRequest) Execute() (*V2AssistantGetConversationDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssistantGetConversationDetailsPostExecute(r)
}

/*
V2AssistantGetConversationDetailsPost Method for V2AssistantGetConversationDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantGetConversationDetailsPostRequest
*/
func (a *DefaultAPIService) V2AssistantGetConversationDetailsPost(ctx context.Context) ApiV2AssistantGetConversationDetailsPostRequest {
	return ApiV2AssistantGetConversationDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantGetConversationDetailsPostResponse
func (a *DefaultAPIService) V2AssistantGetConversationDetailsPostExecute(r ApiV2AssistantGetConversationDetailsPostRequest) (*V2AssistantGetConversationDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantGetConversationDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantGetConversationDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/get-conversation-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantGetConversationDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantGetConversationDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantGetConversationDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantGetConversationsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantGetConversationsPostRequest *V2AssistantGetConversationsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantGetConversationsPostRequest) Authorization(authorization string) ApiV2AssistantGetConversationsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantGetConversationsPostRequest) V2AssistantGetConversationsPostRequest(v2AssistantGetConversationsPostRequest V2AssistantGetConversationsPostRequest) ApiV2AssistantGetConversationsPostRequest {
	r.v2AssistantGetConversationsPostRequest = &v2AssistantGetConversationsPostRequest
	return r
}

func (r ApiV2AssistantGetConversationsPostRequest) Execute() (*V2AssistantGetConversationsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssistantGetConversationsPostExecute(r)
}

/*
V2AssistantGetConversationsPost Method for V2AssistantGetConversationsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantGetConversationsPostRequest
*/
func (a *DefaultAPIService) V2AssistantGetConversationsPost(ctx context.Context) ApiV2AssistantGetConversationsPostRequest {
	return ApiV2AssistantGetConversationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantGetConversationsPostResponse
func (a *DefaultAPIService) V2AssistantGetConversationsPostExecute(r ApiV2AssistantGetConversationsPostRequest) (*V2AssistantGetConversationsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantGetConversationsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantGetConversationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/get-conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantGetConversationsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantGetConversationsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantGetConversationsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantUpdateConversationNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantUpdateConversationNamePostRequest *V2AssistantUpdateConversationNamePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantUpdateConversationNamePostRequest) Authorization(authorization string) ApiV2AssistantUpdateConversationNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantUpdateConversationNamePostRequest) V2AssistantUpdateConversationNamePostRequest(v2AssistantUpdateConversationNamePostRequest V2AssistantUpdateConversationNamePostRequest) ApiV2AssistantUpdateConversationNamePostRequest {
	r.v2AssistantUpdateConversationNamePostRequest = &v2AssistantUpdateConversationNamePostRequest
	return r
}

func (r ApiV2AssistantUpdateConversationNamePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantUpdateConversationNamePostExecute(r)
}

/*
V2AssistantUpdateConversationNamePost Method for V2AssistantUpdateConversationNamePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantUpdateConversationNamePostRequest
*/
func (a *DefaultAPIService) V2AssistantUpdateConversationNamePost(ctx context.Context) ApiV2AssistantUpdateConversationNamePostRequest {
	return ApiV2AssistantUpdateConversationNamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantUpdateConversationNamePostExecute(r ApiV2AssistantUpdateConversationNamePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantUpdateConversationNamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/update-conversation-name"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantUpdateConversationNamePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantUpdateConversationNamePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantUpdateConversationNamePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantVersionPostRequest) Authorization(authorization string) ApiV2AssistantVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantVersionPostRequest) Body(body map[string]interface{}) ApiV2AssistantVersionPostRequest {
	r.body = &body
	return r
}

func (r ApiV2AssistantVersionPostRequest) Execute() (*V2AssistantVersionPostResponse, *http.Response, error) {
	return r.ApiService.V2AssistantVersionPostExecute(r)
}

/*
V2AssistantVersionPost Method for V2AssistantVersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantVersionPostRequest
*/
func (a *DefaultAPIService) V2AssistantVersionPost(ctx context.Context) ApiV2AssistantVersionPostRequest {
	return ApiV2AssistantVersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantVersionPostResponse
func (a *DefaultAPIService) V2AssistantVersionPostExecute(r ApiV2AssistantVersionPostRequest) (*V2AssistantVersionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantVersionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantVersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceApplicationdetailsbynamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceApplicationdetailsbynamePostRequest *V2AssuranceApplicationdetailsbynamePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceApplicationdetailsbynamePostRequest) Authorization(authorization string) ApiV2AssuranceApplicationdetailsbynamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceApplicationdetailsbynamePostRequest) V2AssuranceApplicationdetailsbynamePostRequest(v2AssuranceApplicationdetailsbynamePostRequest V2AssuranceApplicationdetailsbynamePostRequest) ApiV2AssuranceApplicationdetailsbynamePostRequest {
	r.v2AssuranceApplicationdetailsbynamePostRequest = &v2AssuranceApplicationdetailsbynamePostRequest
	return r
}

func (r ApiV2AssuranceApplicationdetailsbynamePostRequest) Execute() (*V2AssuranceApplicationdetailsbynamePostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceApplicationdetailsbynamePostExecute(r)
}

/*
V2AssuranceApplicationdetailsbynamePost Method for V2AssuranceApplicationdetailsbynamePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceApplicationdetailsbynamePostRequest
*/
func (a *DefaultAPIService) V2AssuranceApplicationdetailsbynamePost(ctx context.Context) ApiV2AssuranceApplicationdetailsbynamePostRequest {
	return ApiV2AssuranceApplicationdetailsbynamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceApplicationdetailsbynamePostResponse
func (a *DefaultAPIService) V2AssuranceApplicationdetailsbynamePostExecute(r ApiV2AssuranceApplicationdetailsbynamePostRequest) (*V2AssuranceApplicationdetailsbynamePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceApplicationdetailsbynamePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceApplicationdetailsbynamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/applicationdetailsbyname"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceApplicationdetailsbynamePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceApplicationdetailsbynamePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceApplicationdetailsbynamePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceApplicationprofilesummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceApplicationprofilesummaryPostRequest *V2AssuranceApplicationprofilesummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceApplicationprofilesummaryPostRequest) Authorization(authorization string) ApiV2AssuranceApplicationprofilesummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceApplicationprofilesummaryPostRequest) V2AssuranceApplicationprofilesummaryPostRequest(v2AssuranceApplicationprofilesummaryPostRequest V2AssuranceApplicationprofilesummaryPostRequest) ApiV2AssuranceApplicationprofilesummaryPostRequest {
	r.v2AssuranceApplicationprofilesummaryPostRequest = &v2AssuranceApplicationprofilesummaryPostRequest
	return r
}

func (r ApiV2AssuranceApplicationprofilesummaryPostRequest) Execute() (*V2AssuranceApplicationprofilesummaryPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceApplicationprofilesummaryPostExecute(r)
}

/*
V2AssuranceApplicationprofilesummaryPost Method for V2AssuranceApplicationprofilesummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceApplicationprofilesummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceApplicationprofilesummaryPost(ctx context.Context) ApiV2AssuranceApplicationprofilesummaryPostRequest {
	return ApiV2AssuranceApplicationprofilesummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceApplicationprofilesummaryPostResponse
func (a *DefaultAPIService) V2AssuranceApplicationprofilesummaryPostExecute(r ApiV2AssuranceApplicationprofilesummaryPostRequest) (*V2AssuranceApplicationprofilesummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceApplicationprofilesummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceApplicationprofilesummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/applicationprofilesummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceApplicationprofilesummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceApplicationprofilesummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceApplicationprofilesummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketAppServersAllGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketAppServersAllGetRequest) Authorization(authorization string) ApiV2AssuranceBucketAppServersAllGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketAppServersAllGetRequest) Execute() (*V2AssuranceBucketAppServersAllGetResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketAppServersAllGetExecute(r)
}

/*
V2AssuranceBucketAppServersAllGet Method for V2AssuranceBucketAppServersAllGet

Get all servers associated with each item in a list of bucket apps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketAppServersAllGetRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketAppServersAllGet(ctx context.Context) ApiV2AssuranceBucketAppServersAllGetRequest {
	return ApiV2AssuranceBucketAppServersAllGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketAppServersAllGetResponse
func (a *DefaultAPIService) V2AssuranceBucketAppServersAllGetExecute(r ApiV2AssuranceBucketAppServersAllGetRequest) (*V2AssuranceBucketAppServersAllGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketAppServersAllGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketAppServersAllGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-app-servers/all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketAppServersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketAppServersPostRequest *V2AssuranceBucketAppServersPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketAppServersPostRequest) Authorization(authorization string) ApiV2AssuranceBucketAppServersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketAppServersPostRequest) V2AssuranceBucketAppServersPostRequest(v2AssuranceBucketAppServersPostRequest V2AssuranceBucketAppServersPostRequest) ApiV2AssuranceBucketAppServersPostRequest {
	r.v2AssuranceBucketAppServersPostRequest = &v2AssuranceBucketAppServersPostRequest
	return r
}

func (r ApiV2AssuranceBucketAppServersPostRequest) Execute() (*V2AssuranceBucketAppServersPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketAppServersPostExecute(r)
}

/*
V2AssuranceBucketAppServersPost Method for V2AssuranceBucketAppServersPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketAppServersPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketAppServersPost(ctx context.Context) ApiV2AssuranceBucketAppServersPostRequest {
	return ApiV2AssuranceBucketAppServersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketAppServersPostResponse
func (a *DefaultAPIService) V2AssuranceBucketAppServersPostExecute(r ApiV2AssuranceBucketAppServersPostRequest) (*V2AssuranceBucketAppServersPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketAppServersPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketAppServersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-app-servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketAppServersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketAppServersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketAppServersPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketAppsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketAppsPostRequest *V2AssuranceBucketAppsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketAppsPostRequest) Authorization(authorization string) ApiV2AssuranceBucketAppsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketAppsPostRequest) V2AssuranceBucketAppsPostRequest(v2AssuranceBucketAppsPostRequest V2AssuranceBucketAppsPostRequest) ApiV2AssuranceBucketAppsPostRequest {
	r.v2AssuranceBucketAppsPostRequest = &v2AssuranceBucketAppsPostRequest
	return r
}

func (r ApiV2AssuranceBucketAppsPostRequest) Execute() (*V2AssuranceBucketAppsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketAppsPostExecute(r)
}

/*
V2AssuranceBucketAppsPost Method for V2AssuranceBucketAppsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketAppsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketAppsPost(ctx context.Context) ApiV2AssuranceBucketAppsPostRequest {
	return ApiV2AssuranceBucketAppsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketAppsPostResponse
func (a *DefaultAPIService) V2AssuranceBucketAppsPostExecute(r ApiV2AssuranceBucketAppsPostRequest) (*V2AssuranceBucketAppsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketAppsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketAppsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketAppsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketAppsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketAppsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketServicesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketServicesPostRequest *V2AssuranceBucketServicesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketServicesPostRequest) Authorization(authorization string) ApiV2AssuranceBucketServicesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketServicesPostRequest) V2AssuranceBucketServicesPostRequest(v2AssuranceBucketServicesPostRequest V2AssuranceBucketServicesPostRequest) ApiV2AssuranceBucketServicesPostRequest {
	r.v2AssuranceBucketServicesPostRequest = &v2AssuranceBucketServicesPostRequest
	return r
}

func (r ApiV2AssuranceBucketServicesPostRequest) Execute() (*V2AssuranceBucketServicesPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketServicesPostExecute(r)
}

/*
V2AssuranceBucketServicesPost Method for V2AssuranceBucketServicesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketServicesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketServicesPost(ctx context.Context) ApiV2AssuranceBucketServicesPostRequest {
	return ApiV2AssuranceBucketServicesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketServicesPostResponse
func (a *DefaultAPIService) V2AssuranceBucketServicesPostExecute(r ApiV2AssuranceBucketServicesPostRequest) (*V2AssuranceBucketServicesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketServicesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketServicesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketServicesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketServicesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketServicesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketTopologiesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketTopologiesPostRequest *V2AssuranceBucketTopologiesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketTopologiesPostRequest) Authorization(authorization string) ApiV2AssuranceBucketTopologiesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketTopologiesPostRequest) V2AssuranceBucketTopologiesPostRequest(v2AssuranceBucketTopologiesPostRequest V2AssuranceBucketTopologiesPostRequest) ApiV2AssuranceBucketTopologiesPostRequest {
	r.v2AssuranceBucketTopologiesPostRequest = &v2AssuranceBucketTopologiesPostRequest
	return r
}

func (r ApiV2AssuranceBucketTopologiesPostRequest) Execute() (*V2AssuranceBucketTopologiesPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketTopologiesPostExecute(r)
}

/*
V2AssuranceBucketTopologiesPost Method for V2AssuranceBucketTopologiesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketTopologiesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketTopologiesPost(ctx context.Context) ApiV2AssuranceBucketTopologiesPostRequest {
	return ApiV2AssuranceBucketTopologiesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketTopologiesPostResponse
func (a *DefaultAPIService) V2AssuranceBucketTopologiesPostExecute(r ApiV2AssuranceBucketTopologiesPostRequest) (*V2AssuranceBucketTopologiesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketTopologiesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketTopologiesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-topologies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketTopologiesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketTopologiesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketTopologiesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketdetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketdetailsPostRequest *V2AssuranceBucketdetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketdetailsPostRequest) Authorization(authorization string) ApiV2AssuranceBucketdetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketdetailsPostRequest) V2AssuranceBucketdetailsPostRequest(v2AssuranceBucketdetailsPostRequest V2AssuranceBucketdetailsPostRequest) ApiV2AssuranceBucketdetailsPostRequest {
	r.v2AssuranceBucketdetailsPostRequest = &v2AssuranceBucketdetailsPostRequest
	return r
}

func (r ApiV2AssuranceBucketdetailsPostRequest) Execute() (*V2AssuranceBucketdetailsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketdetailsPostExecute(r)
}

/*
V2AssuranceBucketdetailsPost Method for V2AssuranceBucketdetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketdetailsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketdetailsPost(ctx context.Context) ApiV2AssuranceBucketdetailsPostRequest {
	return ApiV2AssuranceBucketdetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketdetailsPostResponse
func (a *DefaultAPIService) V2AssuranceBucketdetailsPostExecute(r ApiV2AssuranceBucketdetailsPostRequest) (*V2AssuranceBucketdetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketdetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketdetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucketdetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketdetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketdetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketdetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceCreateUserReportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceCreateUserReportPostRequest *V2AssuranceCreateUserReportPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceCreateUserReportPostRequest) Authorization(authorization string) ApiV2AssuranceCreateUserReportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceCreateUserReportPostRequest) V2AssuranceCreateUserReportPostRequest(v2AssuranceCreateUserReportPostRequest V2AssuranceCreateUserReportPostRequest) ApiV2AssuranceCreateUserReportPostRequest {
	r.v2AssuranceCreateUserReportPostRequest = &v2AssuranceCreateUserReportPostRequest
	return r
}

func (r ApiV2AssuranceCreateUserReportPostRequest) Execute() (*V2AssuranceCreateUserReportPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceCreateUserReportPostExecute(r)
}

/*
V2AssuranceCreateUserReportPost Method for V2AssuranceCreateUserReportPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceCreateUserReportPostRequest
*/
func (a *DefaultAPIService) V2AssuranceCreateUserReportPost(ctx context.Context) ApiV2AssuranceCreateUserReportPostRequest {
	return ApiV2AssuranceCreateUserReportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceCreateUserReportPostResponse
func (a *DefaultAPIService) V2AssuranceCreateUserReportPostExecute(r ApiV2AssuranceCreateUserReportPostRequest) (*V2AssuranceCreateUserReportPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceCreateUserReportPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceCreateUserReportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/create-user-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceCreateUserReportPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceCreateUserReportPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceCreateUserReportPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceCreateclassifiedapplicationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceCreateclassifiedapplicationPostRequest *V2AssuranceCreateclassifiedapplicationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceCreateclassifiedapplicationPostRequest) Authorization(authorization string) ApiV2AssuranceCreateclassifiedapplicationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceCreateclassifiedapplicationPostRequest) V2AssuranceCreateclassifiedapplicationPostRequest(v2AssuranceCreateclassifiedapplicationPostRequest V2AssuranceCreateclassifiedapplicationPostRequest) ApiV2AssuranceCreateclassifiedapplicationPostRequest {
	r.v2AssuranceCreateclassifiedapplicationPostRequest = &v2AssuranceCreateclassifiedapplicationPostRequest
	return r
}

func (r ApiV2AssuranceCreateclassifiedapplicationPostRequest) Execute() (*V2AssuranceCreateclassifiedapplicationPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceCreateclassifiedapplicationPostExecute(r)
}

/*
V2AssuranceCreateclassifiedapplicationPost Method for V2AssuranceCreateclassifiedapplicationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceCreateclassifiedapplicationPostRequest
*/
func (a *DefaultAPIService) V2AssuranceCreateclassifiedapplicationPost(ctx context.Context) ApiV2AssuranceCreateclassifiedapplicationPostRequest {
	return ApiV2AssuranceCreateclassifiedapplicationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceCreateclassifiedapplicationPostResponse
func (a *DefaultAPIService) V2AssuranceCreateclassifiedapplicationPostExecute(r ApiV2AssuranceCreateclassifiedapplicationPostRequest) (*V2AssuranceCreateclassifiedapplicationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceCreateclassifiedapplicationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceCreateclassifiedapplicationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/createclassifiedapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceCreateclassifiedapplicationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceCreateclassifiedapplicationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceCreateclassifiedapplicationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceDeleteUserReportDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	reportId *int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceDeleteUserReportDeleteRequest) Authorization(authorization string) ApiV2AssuranceDeleteUserReportDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV2AssuranceDeleteUserReportDeleteRequest) ReportId(reportId int64) ApiV2AssuranceDeleteUserReportDeleteRequest {
	r.reportId = &reportId
	return r
}

func (r ApiV2AssuranceDeleteUserReportDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssuranceDeleteUserReportDeleteExecute(r)
}

/*
V2AssuranceDeleteUserReportDelete Method for V2AssuranceDeleteUserReportDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceDeleteUserReportDeleteRequest
*/
func (a *DefaultAPIService) V2AssuranceDeleteUserReportDelete(ctx context.Context) ApiV2AssuranceDeleteUserReportDeleteRequest {
	return ApiV2AssuranceDeleteUserReportDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssuranceDeleteUserReportDeleteExecute(r ApiV2AssuranceDeleteUserReportDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceDeleteUserReportDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/delete-user-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.reportId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportId", r.reportId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	classificationEntryIdList *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) Authorization(authorization string) ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) ClassificationEntryIdList(classificationEntryIdList []string) ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest {
	r.classificationEntryIdList = &classificationEntryIdList
	return r
}

func (r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssuranceDeleteclassifiedapplicationDeleteExecute(r)
}

/*
V2AssuranceDeleteclassifiedapplicationDelete Method for V2AssuranceDeleteclassifiedapplicationDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest
*/
func (a *DefaultAPIService) V2AssuranceDeleteclassifiedapplicationDelete(ctx context.Context) ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest {
	return ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssuranceDeleteclassifiedapplicationDeleteExecute(r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceDeleteclassifiedapplicationDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/deleteclassifiedapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.classificationEntryIdList != nil {
		t := *r.classificationEntryIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classificationEntryIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classificationEntryIdList", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceDownloadUserReportGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceDownloadUserReportGetRequest) Authorization(authorization string) ApiV2AssuranceDownloadUserReportGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceDownloadUserReportGetRequest) Execute() (*V2AssuranceDownloadUserReportGetResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceDownloadUserReportGetExecute(r)
}

/*
V2AssuranceDownloadUserReportGet Method for V2AssuranceDownloadUserReportGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceDownloadUserReportGetRequest
*/
func (a *DefaultAPIService) V2AssuranceDownloadUserReportGet(ctx context.Context) ApiV2AssuranceDownloadUserReportGetRequest {
	return ApiV2AssuranceDownloadUserReportGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceDownloadUserReportGetResponse
func (a *DefaultAPIService) V2AssuranceDownloadUserReportGetExecute(r ApiV2AssuranceDownloadUserReportGetRequest) (*V2AssuranceDownloadUserReportGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceDownloadUserReportGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceDownloadUserReportGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/download-user-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceEndpointIntelPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceEndpointIntelPostRequest *V2AssuranceEndpointIntelPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceEndpointIntelPostRequest) Authorization(authorization string) ApiV2AssuranceEndpointIntelPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceEndpointIntelPostRequest) V2AssuranceEndpointIntelPostRequest(v2AssuranceEndpointIntelPostRequest V2AssuranceEndpointIntelPostRequest) ApiV2AssuranceEndpointIntelPostRequest {
	r.v2AssuranceEndpointIntelPostRequest = &v2AssuranceEndpointIntelPostRequest
	return r
}

func (r ApiV2AssuranceEndpointIntelPostRequest) Execute() (*V2AssuranceEndpointIntelPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceEndpointIntelPostExecute(r)
}

/*
V2AssuranceEndpointIntelPost Method for V2AssuranceEndpointIntelPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceEndpointIntelPostRequest
*/
func (a *DefaultAPIService) V2AssuranceEndpointIntelPost(ctx context.Context) ApiV2AssuranceEndpointIntelPostRequest {
	return ApiV2AssuranceEndpointIntelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceEndpointIntelPostResponse
func (a *DefaultAPIService) V2AssuranceEndpointIntelPostExecute(r ApiV2AssuranceEndpointIntelPostRequest) (*V2AssuranceEndpointIntelPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceEndpointIntelPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceEndpointIntelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/endpoint-intel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceEndpointIntelPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceEndpointIntelPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceEndpointIntelPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceEnterprisesummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceEnterprisesummaryPostRequest *V2AssuranceEnterprisesummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceEnterprisesummaryPostRequest) Authorization(authorization string) ApiV2AssuranceEnterprisesummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceEnterprisesummaryPostRequest) V2AssuranceEnterprisesummaryPostRequest(v2AssuranceEnterprisesummaryPostRequest V2AssuranceEnterprisesummaryPostRequest) ApiV2AssuranceEnterprisesummaryPostRequest {
	r.v2AssuranceEnterprisesummaryPostRequest = &v2AssuranceEnterprisesummaryPostRequest
	return r
}

func (r ApiV2AssuranceEnterprisesummaryPostRequest) Execute() (*V2AssuranceEnterprisesummaryPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceEnterprisesummaryPostExecute(r)
}

/*
V2AssuranceEnterprisesummaryPost Method for V2AssuranceEnterprisesummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceEnterprisesummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceEnterprisesummaryPost(ctx context.Context) ApiV2AssuranceEnterprisesummaryPostRequest {
	return ApiV2AssuranceEnterprisesummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceEnterprisesummaryPostResponse
func (a *DefaultAPIService) V2AssuranceEnterprisesummaryPostExecute(r ApiV2AssuranceEnterprisesummaryPostRequest) (*V2AssuranceEnterprisesummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceEnterprisesummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceEnterprisesummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/enterprisesummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceEnterprisesummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceEnterprisesummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceEnterprisesummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceFlowSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceFlowSummaryPostRequest *V2AssuranceFlowSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceFlowSummaryPostRequest) Authorization(authorization string) ApiV2AssuranceFlowSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceFlowSummaryPostRequest) V2AssuranceFlowSummaryPostRequest(v2AssuranceFlowSummaryPostRequest V2AssuranceFlowSummaryPostRequest) ApiV2AssuranceFlowSummaryPostRequest {
	r.v2AssuranceFlowSummaryPostRequest = &v2AssuranceFlowSummaryPostRequest
	return r
}

func (r ApiV2AssuranceFlowSummaryPostRequest) Execute() (*V2AssuranceFlowSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceFlowSummaryPostExecute(r)
}

/*
V2AssuranceFlowSummaryPost Method for V2AssuranceFlowSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceFlowSummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceFlowSummaryPost(ctx context.Context) ApiV2AssuranceFlowSummaryPostRequest {
	return ApiV2AssuranceFlowSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceFlowSummaryPostResponse
func (a *DefaultAPIService) V2AssuranceFlowSummaryPostExecute(r ApiV2AssuranceFlowSummaryPostRequest) (*V2AssuranceFlowSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceFlowSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceFlowSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/flow-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceFlowSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceFlowSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceFlowSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceGetclassifiedapplicationlistGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceGetclassifiedapplicationlistGetRequest) Authorization(authorization string) ApiV2AssuranceGetclassifiedapplicationlistGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceGetclassifiedapplicationlistGetRequest) Execute() (*V2AssuranceGetclassifiedapplicationlistGetResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceGetclassifiedapplicationlistGetExecute(r)
}

/*
V2AssuranceGetclassifiedapplicationlistGet Method for V2AssuranceGetclassifiedapplicationlistGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceGetclassifiedapplicationlistGetRequest
*/
func (a *DefaultAPIService) V2AssuranceGetclassifiedapplicationlistGet(ctx context.Context) ApiV2AssuranceGetclassifiedapplicationlistGetRequest {
	return ApiV2AssuranceGetclassifiedapplicationlistGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceGetclassifiedapplicationlistGetResponse
func (a *DefaultAPIService) V2AssuranceGetclassifiedapplicationlistGetExecute(r ApiV2AssuranceGetclassifiedapplicationlistGetRequest) (*V2AssuranceGetclassifiedapplicationlistGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceGetclassifiedapplicationlistGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceGetclassifiedapplicationlistGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/getclassifiedapplicationlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceReadUserReportListGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceReadUserReportListGetRequest) Authorization(authorization string) ApiV2AssuranceReadUserReportListGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceReadUserReportListGetRequest) Execute() (*V2AssuranceReadUserReportListGetResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceReadUserReportListGetExecute(r)
}

/*
V2AssuranceReadUserReportListGet Method for V2AssuranceReadUserReportListGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceReadUserReportListGetRequest
*/
func (a *DefaultAPIService) V2AssuranceReadUserReportListGet(ctx context.Context) ApiV2AssuranceReadUserReportListGetRequest {
	return ApiV2AssuranceReadUserReportListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceReadUserReportListGetResponse
func (a *DefaultAPIService) V2AssuranceReadUserReportListGetExecute(r ApiV2AssuranceReadUserReportListGetRequest) (*V2AssuranceReadUserReportListGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceReadUserReportListGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceReadUserReportListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/read-user-report-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceScoredetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceScoredetailsPostRequest *V2AssuranceScoredetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceScoredetailsPostRequest) Authorization(authorization string) ApiV2AssuranceScoredetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceScoredetailsPostRequest) V2AssuranceScoredetailsPostRequest(v2AssuranceScoredetailsPostRequest V2AssuranceScoredetailsPostRequest) ApiV2AssuranceScoredetailsPostRequest {
	r.v2AssuranceScoredetailsPostRequest = &v2AssuranceScoredetailsPostRequest
	return r
}

func (r ApiV2AssuranceScoredetailsPostRequest) Execute() (*V2AssuranceScoredetailsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceScoredetailsPostExecute(r)
}

/*
V2AssuranceScoredetailsPost Method for V2AssuranceScoredetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceScoredetailsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceScoredetailsPost(ctx context.Context) ApiV2AssuranceScoredetailsPostRequest {
	return ApiV2AssuranceScoredetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceScoredetailsPostResponse
func (a *DefaultAPIService) V2AssuranceScoredetailsPostExecute(r ApiV2AssuranceScoredetailsPostRequest) (*V2AssuranceScoredetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceScoredetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceScoredetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/scoredetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceScoredetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceScoredetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceScoredetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyClientSessionDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyClientSessionDetailsPostRequest *V2AssuranceTopologyClientSessionDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyClientSessionDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) V2AssuranceTopologyClientSessionDetailsPostRequest(v2AssuranceTopologyClientSessionDetailsPostRequest V2AssuranceTopologyClientSessionDetailsPostRequest) ApiV2AssuranceTopologyClientSessionDetailsPostRequest {
	r.v2AssuranceTopologyClientSessionDetailsPostRequest = &v2AssuranceTopologyClientSessionDetailsPostRequest
	return r
}

func (r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) Execute() (*V2AssuranceTopologyClientSessionDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyClientSessionDetailsPostExecute(r)
}

/*
V2AssuranceTopologyClientSessionDetailsPost Method for V2AssuranceTopologyClientSessionDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyClientSessionDetailsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionDetailsPost(ctx context.Context) ApiV2AssuranceTopologyClientSessionDetailsPostRequest {
	return ApiV2AssuranceTopologyClientSessionDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyClientSessionDetailsPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionDetailsPostExecute(r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) (*V2AssuranceTopologyClientSessionDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyClientSessionDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyClientSessionDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-client-session-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyClientSessionDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyClientSessionDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyClientSessionDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyClientSessionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyClientSessionsPostRequest *V2AssuranceTopologyClientSessionsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyClientSessionsPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyClientSessionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyClientSessionsPostRequest) V2AssuranceTopologyClientSessionsPostRequest(v2AssuranceTopologyClientSessionsPostRequest V2AssuranceTopologyClientSessionsPostRequest) ApiV2AssuranceTopologyClientSessionsPostRequest {
	r.v2AssuranceTopologyClientSessionsPostRequest = &v2AssuranceTopologyClientSessionsPostRequest
	return r
}

func (r ApiV2AssuranceTopologyClientSessionsPostRequest) Execute() (*V2AssuranceTopologyClientSessionsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyClientSessionsPostExecute(r)
}

/*
V2AssuranceTopologyClientSessionsPost Method for V2AssuranceTopologyClientSessionsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyClientSessionsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionsPost(ctx context.Context) ApiV2AssuranceTopologyClientSessionsPostRequest {
	return ApiV2AssuranceTopologyClientSessionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyClientSessionsPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionsPostExecute(r ApiV2AssuranceTopologyClientSessionsPostRequest) (*V2AssuranceTopologyClientSessionsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyClientSessionsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyClientSessionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-client-sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyClientSessionsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyClientSessionsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyClientSessionsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyClientSummariesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyClientSummariesPostRequest *V2AssuranceTopologyClientSummariesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyClientSummariesPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyClientSummariesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyClientSummariesPostRequest) V2AssuranceTopologyClientSummariesPostRequest(v2AssuranceTopologyClientSummariesPostRequest V2AssuranceTopologyClientSummariesPostRequest) ApiV2AssuranceTopologyClientSummariesPostRequest {
	r.v2AssuranceTopologyClientSummariesPostRequest = &v2AssuranceTopologyClientSummariesPostRequest
	return r
}

func (r ApiV2AssuranceTopologyClientSummariesPostRequest) Execute() (*V2AssuranceTopologyClientSummariesPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyClientSummariesPostExecute(r)
}

/*
V2AssuranceTopologyClientSummariesPost Method for V2AssuranceTopologyClientSummariesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyClientSummariesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyClientSummariesPost(ctx context.Context) ApiV2AssuranceTopologyClientSummariesPostRequest {
	return ApiV2AssuranceTopologyClientSummariesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyClientSummariesPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyClientSummariesPostExecute(r ApiV2AssuranceTopologyClientSummariesPostRequest) (*V2AssuranceTopologyClientSummariesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyClientSummariesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyClientSummariesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-client-summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyClientSummariesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyClientSummariesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyClientSummariesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyFlowsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyFlowsPostRequest *V2AssuranceTopologyFlowsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyFlowsPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyFlowsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyFlowsPostRequest) V2AssuranceTopologyFlowsPostRequest(v2AssuranceTopologyFlowsPostRequest V2AssuranceTopologyFlowsPostRequest) ApiV2AssuranceTopologyFlowsPostRequest {
	r.v2AssuranceTopologyFlowsPostRequest = &v2AssuranceTopologyFlowsPostRequest
	return r
}

func (r ApiV2AssuranceTopologyFlowsPostRequest) Execute() (*V2AssuranceTopologyFlowsPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyFlowsPostExecute(r)
}

/*
V2AssuranceTopologyFlowsPost Method for V2AssuranceTopologyFlowsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyFlowsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyFlowsPost(ctx context.Context) ApiV2AssuranceTopologyFlowsPostRequest {
	return ApiV2AssuranceTopologyFlowsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyFlowsPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyFlowsPostExecute(r ApiV2AssuranceTopologyFlowsPostRequest) (*V2AssuranceTopologyFlowsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyFlowsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyFlowsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyFlowsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyFlowsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyFlowsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyInventoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyInventoryPostRequest *V2AssuranceTopologyInventoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyInventoryPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyInventoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyInventoryPostRequest) V2AssuranceTopologyInventoryPostRequest(v2AssuranceTopologyInventoryPostRequest V2AssuranceTopologyInventoryPostRequest) ApiV2AssuranceTopologyInventoryPostRequest {
	r.v2AssuranceTopologyInventoryPostRequest = &v2AssuranceTopologyInventoryPostRequest
	return r
}

func (r ApiV2AssuranceTopologyInventoryPostRequest) Execute() (*V2AssuranceTopologyInventoryPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyInventoryPostExecute(r)
}

/*
V2AssuranceTopologyInventoryPost Method for V2AssuranceTopologyInventoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyInventoryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyInventoryPost(ctx context.Context) ApiV2AssuranceTopologyInventoryPostRequest {
	return ApiV2AssuranceTopologyInventoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyInventoryPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyInventoryPostExecute(r ApiV2AssuranceTopologyInventoryPostRequest) (*V2AssuranceTopologyInventoryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyInventoryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyInventoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyInventoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyInventoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyInventoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyOverviewPostRequest *V2AssuranceTopologyOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyOverviewPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyOverviewPostRequest) V2AssuranceTopologyOverviewPostRequest(v2AssuranceTopologyOverviewPostRequest V2AssuranceTopologyOverviewPostRequest) ApiV2AssuranceTopologyOverviewPostRequest {
	r.v2AssuranceTopologyOverviewPostRequest = &v2AssuranceTopologyOverviewPostRequest
	return r
}

func (r ApiV2AssuranceTopologyOverviewPostRequest) Execute() (*V2AssuranceTopologyOverviewPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyOverviewPostExecute(r)
}

/*
V2AssuranceTopologyOverviewPost Method for V2AssuranceTopologyOverviewPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyOverviewPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyOverviewPost(ctx context.Context) ApiV2AssuranceTopologyOverviewPostRequest {
	return ApiV2AssuranceTopologyOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyOverviewPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyOverviewPostExecute(r ApiV2AssuranceTopologyOverviewPostRequest) (*V2AssuranceTopologyOverviewPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyOverviewPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyRegionSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyRegionSummaryPostRequest *V2AssuranceTopologyRegionSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyRegionSummaryPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyRegionSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyRegionSummaryPostRequest) V2AssuranceTopologyRegionSummaryPostRequest(v2AssuranceTopologyRegionSummaryPostRequest V2AssuranceTopologyRegionSummaryPostRequest) ApiV2AssuranceTopologyRegionSummaryPostRequest {
	r.v2AssuranceTopologyRegionSummaryPostRequest = &v2AssuranceTopologyRegionSummaryPostRequest
	return r
}

func (r ApiV2AssuranceTopologyRegionSummaryPostRequest) Execute() (*V2AssuranceTopologyRegionSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyRegionSummaryPostExecute(r)
}

/*
V2AssuranceTopologyRegionSummaryPost Method for V2AssuranceTopologyRegionSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyRegionSummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyRegionSummaryPost(ctx context.Context) ApiV2AssuranceTopologyRegionSummaryPostRequest {
	return ApiV2AssuranceTopologyRegionSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyRegionSummaryPostResponse
func (a *DefaultAPIService) V2AssuranceTopologyRegionSummaryPostExecute(r ApiV2AssuranceTopologyRegionSummaryPostRequest) (*V2AssuranceTopologyRegionSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyRegionSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyRegionSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-region-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyRegionSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyRegionSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyRegionSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologySiteSummariesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologySiteSummariesPostRequest *V2AssuranceTopologySiteSummariesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologySiteSummariesPostRequest) Authorization(authorization string) ApiV2AssuranceTopologySiteSummariesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologySiteSummariesPostRequest) V2AssuranceTopologySiteSummariesPostRequest(v2AssuranceTopologySiteSummariesPostRequest V2AssuranceTopologySiteSummariesPostRequest) ApiV2AssuranceTopologySiteSummariesPostRequest {
	r.v2AssuranceTopologySiteSummariesPostRequest = &v2AssuranceTopologySiteSummariesPostRequest
	return r
}

func (r ApiV2AssuranceTopologySiteSummariesPostRequest) Execute() (*V2AssuranceTopologySiteSummariesPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologySiteSummariesPostExecute(r)
}

/*
V2AssuranceTopologySiteSummariesPost Method for V2AssuranceTopologySiteSummariesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologySiteSummariesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologySiteSummariesPost(ctx context.Context) ApiV2AssuranceTopologySiteSummariesPostRequest {
	return ApiV2AssuranceTopologySiteSummariesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologySiteSummariesPostResponse
func (a *DefaultAPIService) V2AssuranceTopologySiteSummariesPostExecute(r ApiV2AssuranceTopologySiteSummariesPostRequest) (*V2AssuranceTopologySiteSummariesPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologySiteSummariesPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologySiteSummariesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-site-summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologySiteSummariesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologySiteSummariesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologySiteSummariesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest *V2AssuranceUnclassifiedapplicationprofilesummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) Authorization(authorization string) ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) V2AssuranceUnclassifiedapplicationprofilesummaryPostRequest(v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest V2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest {
	r.v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest = &v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest
	return r
}

func (r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) Execute() (*V2AssuranceUnclassifiedapplicationprofilesummaryPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceUnclassifiedapplicationprofilesummaryPostExecute(r)
}

/*
V2AssuranceUnclassifiedapplicationprofilesummaryPost Method for V2AssuranceUnclassifiedapplicationprofilesummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceUnclassifiedapplicationprofilesummaryPost(ctx context.Context) ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest {
	return ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceUnclassifiedapplicationprofilesummaryPostResponse
func (a *DefaultAPIService) V2AssuranceUnclassifiedapplicationprofilesummaryPostExecute(r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) (*V2AssuranceUnclassifiedapplicationprofilesummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceUnclassifiedapplicationprofilesummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceUnclassifiedapplicationprofilesummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/unclassifiedapplicationprofilesummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceUnclassifiedapplicationprofilesummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceUpdateclassifiedapplicationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceUpdateclassifiedapplicationPostRequest *V2AssuranceUpdateclassifiedapplicationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) Authorization(authorization string) ApiV2AssuranceUpdateclassifiedapplicationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) V2AssuranceUpdateclassifiedapplicationPostRequest(v2AssuranceUpdateclassifiedapplicationPostRequest V2AssuranceUpdateclassifiedapplicationPostRequest) ApiV2AssuranceUpdateclassifiedapplicationPostRequest {
	r.v2AssuranceUpdateclassifiedapplicationPostRequest = &v2AssuranceUpdateclassifiedapplicationPostRequest
	return r
}

func (r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssuranceUpdateclassifiedapplicationPostExecute(r)
}

/*
V2AssuranceUpdateclassifiedapplicationPost Method for V2AssuranceUpdateclassifiedapplicationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceUpdateclassifiedapplicationPostRequest
*/
func (a *DefaultAPIService) V2AssuranceUpdateclassifiedapplicationPost(ctx context.Context) ApiV2AssuranceUpdateclassifiedapplicationPostRequest {
	return ApiV2AssuranceUpdateclassifiedapplicationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssuranceUpdateclassifiedapplicationPostExecute(r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceUpdateclassifiedapplicationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/updateclassifiedapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceUpdateclassifiedapplicationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceUpdateclassifiedapplicationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceUpdateclassifiedapplicationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceVersionPostRequest) Authorization(authorization string) ApiV2AssuranceVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceVersionPostRequest) Body(body map[string]interface{}) ApiV2AssuranceVersionPostRequest {
	r.body = &body
	return r
}

func (r ApiV2AssuranceVersionPostRequest) Execute() (*V2AssuranceVersionPostResponse, *http.Response, error) {
	return r.ApiService.V2AssuranceVersionPostExecute(r)
}

/*
V2AssuranceVersionPost Method for V2AssuranceVersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceVersionPostRequest
*/
func (a *DefaultAPIService) V2AssuranceVersionPost(ctx context.Context) ApiV2AssuranceVersionPostRequest {
	return ApiV2AssuranceVersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceVersionPostResponse
func (a *DefaultAPIService) V2AssuranceVersionPostExecute(r ApiV2AssuranceVersionPostRequest) (*V2AssuranceVersionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceVersionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceVersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AuditLogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AuditLogsPostRequest *V2AuditLogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AuditLogsPostRequest) Authorization(authorization string) ApiV2AuditLogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AuditLogsPostRequest) V2AuditLogsPostRequest(v2AuditLogsPostRequest V2AuditLogsPostRequest) ApiV2AuditLogsPostRequest {
	r.v2AuditLogsPostRequest = &v2AuditLogsPostRequest
	return r
}

func (r ApiV2AuditLogsPostRequest) Execute() (*V2AuditLogsPostResponse, *http.Response, error) {
	return r.ApiService.V2AuditLogsPostExecute(r)
}

/*
V2AuditLogsPost Method for V2AuditLogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AuditLogsPostRequest
*/
func (a *DefaultAPIService) V2AuditLogsPost(ctx context.Context) ApiV2AuditLogsPostRequest {
	return ApiV2AuditLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AuditLogsPostResponse
func (a *DefaultAPIService) V2AuditLogsPostExecute(r ApiV2AuditLogsPostRequest) (*V2AuditLogsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AuditLogsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AuditLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/audit/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AuditLogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AuditLogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AuditLogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ChildalertlistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ChildalertlistPostRequest *V2ChildalertlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ChildalertlistPostRequest) Authorization(authorization string) ApiV2ChildalertlistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ChildalertlistPostRequest) V2ChildalertlistPostRequest(v2ChildalertlistPostRequest V2ChildalertlistPostRequest) ApiV2ChildalertlistPostRequest {
	r.v2ChildalertlistPostRequest = &v2ChildalertlistPostRequest
	return r
}

func (r ApiV2ChildalertlistPostRequest) Execute() (*V2ChildalertlistPostResponse, *http.Response, error) {
	return r.ApiService.V2ChildalertlistPostExecute(r)
}

/*
V2ChildalertlistPost Method for V2ChildalertlistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ChildalertlistPostRequest
*/
func (a *DefaultAPIService) V2ChildalertlistPost(ctx context.Context) ApiV2ChildalertlistPostRequest {
	return ApiV2ChildalertlistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ChildalertlistPostResponse
func (a *DefaultAPIService) V2ChildalertlistPostExecute(r ApiV2ChildalertlistPostRequest) (*V2ChildalertlistPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ChildalertlistPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ChildalertlistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/childalertlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ChildalertlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ChildalertlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ChildalertlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2DeviceDeviceIdLanSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v2DeviceDeviceIdLanSegmentsPostRequest *V2DeviceDeviceIdLanSegmentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2DeviceDeviceIdLanSegmentsPostRequest) Authorization(authorization string) ApiV2DeviceDeviceIdLanSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2DeviceDeviceIdLanSegmentsPostRequest) V2DeviceDeviceIdLanSegmentsPostRequest(v2DeviceDeviceIdLanSegmentsPostRequest V2DeviceDeviceIdLanSegmentsPostRequest) ApiV2DeviceDeviceIdLanSegmentsPostRequest {
	r.v2DeviceDeviceIdLanSegmentsPostRequest = &v2DeviceDeviceIdLanSegmentsPostRequest
	return r
}

func (r ApiV2DeviceDeviceIdLanSegmentsPostRequest) Execute() (*V2DeviceDeviceIdLanSegmentsPostResponse, *http.Response, error) {
	return r.ApiService.V2DeviceDeviceIdLanSegmentsPostExecute(r)
}

/*
V2DeviceDeviceIdLanSegmentsPost Method for V2DeviceDeviceIdLanSegmentsPost

Get route count for all the LAN Segments in a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV2DeviceDeviceIdLanSegmentsPostRequest
*/
func (a *DefaultAPIService) V2DeviceDeviceIdLanSegmentsPost(ctx context.Context, deviceId int64) ApiV2DeviceDeviceIdLanSegmentsPostRequest {
	return ApiV2DeviceDeviceIdLanSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V2DeviceDeviceIdLanSegmentsPostResponse
func (a *DefaultAPIService) V2DeviceDeviceIdLanSegmentsPostExecute(r ApiV2DeviceDeviceIdLanSegmentsPostRequest) (*V2DeviceDeviceIdLanSegmentsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DeviceDeviceIdLanSegmentsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2DeviceDeviceIdLanSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/device/{deviceId}/lan-segments"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2DeviceDeviceIdLanSegmentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2DeviceDeviceIdLanSegmentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2DeviceDeviceIdLanSegmentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2DeviceDeviceIdTopologyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v2DeviceDeviceIdTopologyPostRequest *V2DeviceDeviceIdTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2DeviceDeviceIdTopologyPostRequest) Authorization(authorization string) ApiV2DeviceDeviceIdTopologyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2DeviceDeviceIdTopologyPostRequest) V2DeviceDeviceIdTopologyPostRequest(v2DeviceDeviceIdTopologyPostRequest V2DeviceDeviceIdTopologyPostRequest) ApiV2DeviceDeviceIdTopologyPostRequest {
	r.v2DeviceDeviceIdTopologyPostRequest = &v2DeviceDeviceIdTopologyPostRequest
	return r
}

func (r ApiV2DeviceDeviceIdTopologyPostRequest) Execute() (*V2DeviceDeviceIdTopologyPostResponse, *http.Response, error) {
	return r.ApiService.V2DeviceDeviceIdTopologyPostExecute(r)
}

/*
V2DeviceDeviceIdTopologyPost Method for V2DeviceDeviceIdTopologyPost

Get the device topology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV2DeviceDeviceIdTopologyPostRequest
*/
func (a *DefaultAPIService) V2DeviceDeviceIdTopologyPost(ctx context.Context, deviceId int64) ApiV2DeviceDeviceIdTopologyPostRequest {
	return ApiV2DeviceDeviceIdTopologyPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V2DeviceDeviceIdTopologyPostResponse
func (a *DefaultAPIService) V2DeviceDeviceIdTopologyPostExecute(r ApiV2DeviceDeviceIdTopologyPostRequest) (*V2DeviceDeviceIdTopologyPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DeviceDeviceIdTopologyPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2DeviceDeviceIdTopologyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/device/{deviceId}/topology"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2DeviceDeviceIdTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2DeviceDeviceIdTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2DeviceDeviceIdTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetConsumersUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetConsumersUsageTopPostRequest *V2ExtranetConsumersUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetConsumersUsageTopPostRequest) Authorization(authorization string) ApiV2ExtranetConsumersUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetConsumersUsageTopPostRequest) V2ExtranetConsumersUsageTopPostRequest(v2ExtranetConsumersUsageTopPostRequest V2ExtranetConsumersUsageTopPostRequest) ApiV2ExtranetConsumersUsageTopPostRequest {
	r.v2ExtranetConsumersUsageTopPostRequest = &v2ExtranetConsumersUsageTopPostRequest
	return r
}

func (r ApiV2ExtranetConsumersUsageTopPostRequest) Execute() (*V2ExtranetConsumersUsageTopPostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetConsumersUsageTopPostExecute(r)
}

/*
V2ExtranetConsumersUsageTopPost Method for V2ExtranetConsumersUsageTopPost

Get extranet service top consumer usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetConsumersUsageTopPostRequest
*/
func (a *DefaultAPIService) V2ExtranetConsumersUsageTopPost(ctx context.Context) ApiV2ExtranetConsumersUsageTopPostRequest {
	return ApiV2ExtranetConsumersUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetConsumersUsageTopPostResponse
func (a *DefaultAPIService) V2ExtranetConsumersUsageTopPostExecute(r ApiV2ExtranetConsumersUsageTopPostRequest) (*V2ExtranetConsumersUsageTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetConsumersUsageTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetConsumersUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/consumers-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetConsumersUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetConsumersUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetConsumersUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetLanSegmentsUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetLanSegmentsUsageTopPostRequest *V2ExtranetLanSegmentsUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetLanSegmentsUsageTopPostRequest) Authorization(authorization string) ApiV2ExtranetLanSegmentsUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetLanSegmentsUsageTopPostRequest) V2ExtranetLanSegmentsUsageTopPostRequest(v2ExtranetLanSegmentsUsageTopPostRequest V2ExtranetLanSegmentsUsageTopPostRequest) ApiV2ExtranetLanSegmentsUsageTopPostRequest {
	r.v2ExtranetLanSegmentsUsageTopPostRequest = &v2ExtranetLanSegmentsUsageTopPostRequest
	return r
}

func (r ApiV2ExtranetLanSegmentsUsageTopPostRequest) Execute() (*V2ExtranetLanSegmentsUsageTopPostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetLanSegmentsUsageTopPostExecute(r)
}

/*
V2ExtranetLanSegmentsUsageTopPost Method for V2ExtranetLanSegmentsUsageTopPost

Get extranet service top lan segment usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetLanSegmentsUsageTopPostRequest
*/
func (a *DefaultAPIService) V2ExtranetLanSegmentsUsageTopPost(ctx context.Context) ApiV2ExtranetLanSegmentsUsageTopPostRequest {
	return ApiV2ExtranetLanSegmentsUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetLanSegmentsUsageTopPostResponse
func (a *DefaultAPIService) V2ExtranetLanSegmentsUsageTopPostExecute(r ApiV2ExtranetLanSegmentsUsageTopPostRequest) (*V2ExtranetLanSegmentsUsageTopPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetLanSegmentsUsageTopPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetLanSegmentsUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/lan-segments-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetLanSegmentsUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetLanSegmentsUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetLanSegmentsUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetServiceOvertimeConsumptionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetServiceOvertimeConsumptionPostRequest *V2ExtranetServiceOvertimeConsumptionPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) Authorization(authorization string) ApiV2ExtranetServiceOvertimeConsumptionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) V2ExtranetServiceOvertimeConsumptionPostRequest(v2ExtranetServiceOvertimeConsumptionPostRequest V2ExtranetServiceOvertimeConsumptionPostRequest) ApiV2ExtranetServiceOvertimeConsumptionPostRequest {
	r.v2ExtranetServiceOvertimeConsumptionPostRequest = &v2ExtranetServiceOvertimeConsumptionPostRequest
	return r
}

func (r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) Execute() (*V2ExtranetServiceOvertimeConsumptionPostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetServiceOvertimeConsumptionPostExecute(r)
}

/*
V2ExtranetServiceOvertimeConsumptionPost Method for V2ExtranetServiceOvertimeConsumptionPost

Get extranet service cumulative consumption over timewindow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetServiceOvertimeConsumptionPostRequest
*/
func (a *DefaultAPIService) V2ExtranetServiceOvertimeConsumptionPost(ctx context.Context) ApiV2ExtranetServiceOvertimeConsumptionPostRequest {
	return ApiV2ExtranetServiceOvertimeConsumptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetServiceOvertimeConsumptionPostResponse
func (a *DefaultAPIService) V2ExtranetServiceOvertimeConsumptionPostExecute(r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) (*V2ExtranetServiceOvertimeConsumptionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetServiceOvertimeConsumptionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetServiceOvertimeConsumptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/service-overtime-consumption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetServiceOvertimeConsumptionPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetServiceOvertimeConsumptionPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetServiceOvertimeConsumptionPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetSitesConsumptionOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetSitesConsumptionOverviewPostRequest *V2ExtranetSitesConsumptionOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetSitesConsumptionOverviewPostRequest) Authorization(authorization string) ApiV2ExtranetSitesConsumptionOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetSitesConsumptionOverviewPostRequest) V2ExtranetSitesConsumptionOverviewPostRequest(v2ExtranetSitesConsumptionOverviewPostRequest V2ExtranetSitesConsumptionOverviewPostRequest) ApiV2ExtranetSitesConsumptionOverviewPostRequest {
	r.v2ExtranetSitesConsumptionOverviewPostRequest = &v2ExtranetSitesConsumptionOverviewPostRequest
	return r
}

func (r ApiV2ExtranetSitesConsumptionOverviewPostRequest) Execute() (*V2ExtranetSitesConsumptionOverviewPostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetSitesConsumptionOverviewPostExecute(r)
}

/*
V2ExtranetSitesConsumptionOverviewPost Method for V2ExtranetSitesConsumptionOverviewPost

Get extranet service consumption overview over timewindow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetSitesConsumptionOverviewPostRequest
*/
func (a *DefaultAPIService) V2ExtranetSitesConsumptionOverviewPost(ctx context.Context) ApiV2ExtranetSitesConsumptionOverviewPostRequest {
	return ApiV2ExtranetSitesConsumptionOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetSitesConsumptionOverviewPostResponse
func (a *DefaultAPIService) V2ExtranetSitesConsumptionOverviewPostExecute(r ApiV2ExtranetSitesConsumptionOverviewPostRequest) (*V2ExtranetSitesConsumptionOverviewPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetSitesConsumptionOverviewPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetSitesConsumptionOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/sites-consumption-overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetSitesConsumptionOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetSitesConsumptionOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetSitesConsumptionOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetSitesUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetSitesUsagePostRequest *V2ExtranetSitesUsagePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetSitesUsagePostRequest) Authorization(authorization string) ApiV2ExtranetSitesUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetSitesUsagePostRequest) V2ExtranetSitesUsagePostRequest(v2ExtranetSitesUsagePostRequest V2ExtranetSitesUsagePostRequest) ApiV2ExtranetSitesUsagePostRequest {
	r.v2ExtranetSitesUsagePostRequest = &v2ExtranetSitesUsagePostRequest
	return r
}

func (r ApiV2ExtranetSitesUsagePostRequest) Execute() (*V2ExtranetSitesUsagePostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetSitesUsagePostExecute(r)
}

/*
V2ExtranetSitesUsagePost Method for V2ExtranetSitesUsagePost

Get extranet service sites usage stats v2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetSitesUsagePostRequest
*/
func (a *DefaultAPIService) V2ExtranetSitesUsagePost(ctx context.Context) ApiV2ExtranetSitesUsagePostRequest {
	return ApiV2ExtranetSitesUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetSitesUsagePostResponse
func (a *DefaultAPIService) V2ExtranetSitesUsagePostExecute(r ApiV2ExtranetSitesUsagePostRequest) (*V2ExtranetSitesUsagePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetSitesUsagePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetSitesUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/sites-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetSitesUsagePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetSitesUsagePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetSitesUsagePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetTotalUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetTotalUsagePostRequest *V2ExtranetTotalUsagePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetTotalUsagePostRequest) Authorization(authorization string) ApiV2ExtranetTotalUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetTotalUsagePostRequest) V2ExtranetTotalUsagePostRequest(v2ExtranetTotalUsagePostRequest V2ExtranetTotalUsagePostRequest) ApiV2ExtranetTotalUsagePostRequest {
	r.v2ExtranetTotalUsagePostRequest = &v2ExtranetTotalUsagePostRequest
	return r
}

func (r ApiV2ExtranetTotalUsagePostRequest) Execute() (*V2ExtranetTotalUsagePostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetTotalUsagePostExecute(r)
}

/*
V2ExtranetTotalUsagePost Method for V2ExtranetTotalUsagePost

Get extranet service total usage stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetTotalUsagePostRequest
*/
func (a *DefaultAPIService) V2ExtranetTotalUsagePost(ctx context.Context) ApiV2ExtranetTotalUsagePostRequest {
	return ApiV2ExtranetTotalUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetTotalUsagePostResponse
func (a *DefaultAPIService) V2ExtranetTotalUsagePostExecute(r ApiV2ExtranetTotalUsagePostRequest) (*V2ExtranetTotalUsagePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetTotalUsagePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetTotalUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/total-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetTotalUsagePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetTotalUsagePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetTotalUsagePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetsMonitoringConsumersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetsMonitoringConsumersPostRequest *V2ExtranetsMonitoringConsumersPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetsMonitoringConsumersPostRequest) Authorization(authorization string) ApiV2ExtranetsMonitoringConsumersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetsMonitoringConsumersPostRequest) V2ExtranetsMonitoringConsumersPostRequest(v2ExtranetsMonitoringConsumersPostRequest V2ExtranetsMonitoringConsumersPostRequest) ApiV2ExtranetsMonitoringConsumersPostRequest {
	r.v2ExtranetsMonitoringConsumersPostRequest = &v2ExtranetsMonitoringConsumersPostRequest
	return r
}

func (r ApiV2ExtranetsMonitoringConsumersPostRequest) Execute() (*V2ExtranetsMonitoringConsumersPostResponse, *http.Response, error) {
	return r.ApiService.V2ExtranetsMonitoringConsumersPostExecute(r)
}

/*
V2ExtranetsMonitoringConsumersPost Method for V2ExtranetsMonitoringConsumersPost

Get consumer list for b2b producer service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetsMonitoringConsumersPostRequest
*/
func (a *DefaultAPIService) V2ExtranetsMonitoringConsumersPost(ctx context.Context) ApiV2ExtranetsMonitoringConsumersPostRequest {
	return ApiV2ExtranetsMonitoringConsumersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetsMonitoringConsumersPostResponse
func (a *DefaultAPIService) V2ExtranetsMonitoringConsumersPostExecute(r ApiV2ExtranetsMonitoringConsumersPostRequest) (*V2ExtranetsMonitoringConsumersPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetsMonitoringConsumersPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetsMonitoringConsumersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranets-monitoring/consumers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetsMonitoringConsumersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetsMonitoringConsumersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetsMonitoringConsumersPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationGetallEnterpriseIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationGetallEnterpriseIdGetRequest) Authorization(authorization string) ApiV2IntegrationGetallEnterpriseIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationGetallEnterpriseIdGetRequest) Execute() (*V2IntegrationGetallEnterpriseIdGetResponse, *http.Response, error) {
	return r.ApiService.V2IntegrationGetallEnterpriseIdGetExecute(r)
}

/*
V2IntegrationGetallEnterpriseIdGet Method for V2IntegrationGetallEnterpriseIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId Enterprise id
 @return ApiV2IntegrationGetallEnterpriseIdGetRequest
*/
func (a *DefaultAPIService) V2IntegrationGetallEnterpriseIdGet(ctx context.Context, enterpriseId int64) ApiV2IntegrationGetallEnterpriseIdGetRequest {
	return ApiV2IntegrationGetallEnterpriseIdGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V2IntegrationGetallEnterpriseIdGetResponse
func (a *DefaultAPIService) V2IntegrationGetallEnterpriseIdGetExecute(r ApiV2IntegrationGetallEnterpriseIdGetRequest) (*V2IntegrationGetallEnterpriseIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2IntegrationGetallEnterpriseIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationGetallEnterpriseIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/getall/{enterpriseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationIntegrationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	integrationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationIntegrationIdDeleteRequest) Authorization(authorization string) ApiV2IntegrationIntegrationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationIntegrationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2IntegrationIntegrationIdDeleteExecute(r)
}

/*
V2IntegrationIntegrationIdDelete Method for V2IntegrationIntegrationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId ID of the integration to be deleted
 @return ApiV2IntegrationIntegrationIdDeleteRequest
*/
func (a *DefaultAPIService) V2IntegrationIntegrationIdDelete(ctx context.Context, integrationId int64) ApiV2IntegrationIntegrationIdDeleteRequest {
	return ApiV2IntegrationIntegrationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2IntegrationIntegrationIdDeleteExecute(r ApiV2IntegrationIntegrationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationIntegrationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/{integrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationId"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationIntegrationIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	integrationId int64
	v2IntegrationIntegrationIdPutRequest *V2IntegrationIntegrationIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationIntegrationIdPutRequest) Authorization(authorization string) ApiV2IntegrationIntegrationIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationIntegrationIdPutRequest) V2IntegrationIntegrationIdPutRequest(v2IntegrationIntegrationIdPutRequest V2IntegrationIntegrationIdPutRequest) ApiV2IntegrationIntegrationIdPutRequest {
	r.v2IntegrationIntegrationIdPutRequest = &v2IntegrationIntegrationIdPutRequest
	return r
}

func (r ApiV2IntegrationIntegrationIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2IntegrationIntegrationIdPutExecute(r)
}

/*
V2IntegrationIntegrationIdPut Method for V2IntegrationIntegrationIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId integration id
 @return ApiV2IntegrationIntegrationIdPutRequest
*/
func (a *DefaultAPIService) V2IntegrationIntegrationIdPut(ctx context.Context, integrationId int64) ApiV2IntegrationIntegrationIdPutRequest {
	return ApiV2IntegrationIntegrationIdPutRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2IntegrationIntegrationIdPutExecute(r ApiV2IntegrationIntegrationIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationIntegrationIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/{integrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationId"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2IntegrationIntegrationIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2IntegrationIntegrationIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2IntegrationIntegrationIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2IntegrationPostRequest *V2IntegrationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationPostRequest) Authorization(authorization string) ApiV2IntegrationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationPostRequest) V2IntegrationPostRequest(v2IntegrationPostRequest V2IntegrationPostRequest) ApiV2IntegrationPostRequest {
	r.v2IntegrationPostRequest = &v2IntegrationPostRequest
	return r
}

func (r ApiV2IntegrationPostRequest) Execute() (*V2IntegrationPostResponse, *http.Response, error) {
	return r.ApiService.V2IntegrationPostExecute(r)
}

/*
V2IntegrationPost Method for V2IntegrationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2IntegrationPostRequest
*/
func (a *DefaultAPIService) V2IntegrationPost(ctx context.Context) ApiV2IntegrationPostRequest {
	return ApiV2IntegrationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2IntegrationPostResponse
func (a *DefaultAPIService) V2IntegrationPostExecute(r ApiV2IntegrationPostRequest) (*V2IntegrationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2IntegrationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2IntegrationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2IntegrationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2IntegrationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
	integrationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest) Authorization(authorization string) ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2IntegrationTestEnterpriseIdIntegrationIdGetExecute(r)
}

/*
V2IntegrationTestEnterpriseIdIntegrationIdGet Method for V2IntegrationTestEnterpriseIdIntegrationIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId Enterprise id
 @param integrationId Integration id
 @return ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest
*/
func (a *DefaultAPIService) V2IntegrationTestEnterpriseIdIntegrationIdGet(ctx context.Context, enterpriseId int64, integrationId int64) ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest {
	return ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2IntegrationTestEnterpriseIdIntegrationIdGetExecute(r ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationTestEnterpriseIdIntegrationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/test/{enterpriseId}/{integrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationId"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringBfdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringBfdPostRequest *V2MonitoringBfdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringBfdPostRequest) Authorization(authorization string) ApiV2MonitoringBfdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringBfdPostRequest) V2MonitoringBfdPostRequest(v2MonitoringBfdPostRequest V2MonitoringBfdPostRequest) ApiV2MonitoringBfdPostRequest {
	r.v2MonitoringBfdPostRequest = &v2MonitoringBfdPostRequest
	return r
}

func (r ApiV2MonitoringBfdPostRequest) Execute() (*V2MonitoringBfdPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringBfdPostExecute(r)
}

/*
V2MonitoringBfdPost Method for V2MonitoringBfdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringBfdPostRequest
*/
func (a *DefaultAPIService) V2MonitoringBfdPost(ctx context.Context) ApiV2MonitoringBfdPostRequest {
	return ApiV2MonitoringBfdPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringBfdPostResponse
func (a *DefaultAPIService) V2MonitoringBfdPostExecute(r ApiV2MonitoringBfdPostRequest) (*V2MonitoringBfdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringBfdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringBfdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/bfd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringBfdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringBfdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringBfdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringBgpPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringBgpPostRequest *V2MonitoringBgpPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringBgpPostRequest) Authorization(authorization string) ApiV2MonitoringBgpPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringBgpPostRequest) V2MonitoringBgpPostRequest(v2MonitoringBgpPostRequest V2MonitoringBgpPostRequest) ApiV2MonitoringBgpPostRequest {
	r.v2MonitoringBgpPostRequest = &v2MonitoringBgpPostRequest
	return r
}

func (r ApiV2MonitoringBgpPostRequest) Execute() (*V2MonitoringBgpPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringBgpPostExecute(r)
}

/*
V2MonitoringBgpPost Method for V2MonitoringBgpPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringBgpPostRequest
*/
func (a *DefaultAPIService) V2MonitoringBgpPost(ctx context.Context) ApiV2MonitoringBgpPostRequest {
	return ApiV2MonitoringBgpPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringBgpPostResponse
func (a *DefaultAPIService) V2MonitoringBgpPostExecute(r ApiV2MonitoringBgpPostRequest) (*V2MonitoringBgpPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringBgpPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringBgpPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/bgp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringBgpPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringBgpPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringBgpPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsBandwidthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsBandwidthPostRequest *V2MonitoringCircuitsBandwidthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsBandwidthPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsBandwidthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsBandwidthPostRequest) V2MonitoringCircuitsBandwidthPostRequest(v2MonitoringCircuitsBandwidthPostRequest V2MonitoringCircuitsBandwidthPostRequest) ApiV2MonitoringCircuitsBandwidthPostRequest {
	r.v2MonitoringCircuitsBandwidthPostRequest = &v2MonitoringCircuitsBandwidthPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsBandwidthPostRequest) Execute() (*V2MonitoringCircuitsBandwidthPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsBandwidthPostExecute(r)
}

/*
V2MonitoringCircuitsBandwidthPost Method for V2MonitoringCircuitsBandwidthPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsBandwidthPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsBandwidthPost(ctx context.Context) ApiV2MonitoringCircuitsBandwidthPostRequest {
	return ApiV2MonitoringCircuitsBandwidthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringCircuitsBandwidthPostResponse
func (a *DefaultAPIService) V2MonitoringCircuitsBandwidthPostExecute(r ApiV2MonitoringCircuitsBandwidthPostRequest) (*V2MonitoringCircuitsBandwidthPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringCircuitsBandwidthPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsBandwidthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsBandwidthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsBandwidthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsBandwidthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsSummaryPostRequest *V2MonitoringCircuitsSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsSummaryPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsSummaryPostRequest) V2MonitoringCircuitsSummaryPostRequest(v2MonitoringCircuitsSummaryPostRequest V2MonitoringCircuitsSummaryPostRequest) ApiV2MonitoringCircuitsSummaryPostRequest {
	r.v2MonitoringCircuitsSummaryPostRequest = &v2MonitoringCircuitsSummaryPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsSummaryPostRequest) Execute() (*V2MonitoringCircuitsSummaryPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsSummaryPostExecute(r)
}

/*
V2MonitoringCircuitsSummaryPost Method for V2MonitoringCircuitsSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsSummaryPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsSummaryPost(ctx context.Context) ApiV2MonitoringCircuitsSummaryPostRequest {
	return ApiV2MonitoringCircuitsSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringCircuitsSummaryPostResponse
func (a *DefaultAPIService) V2MonitoringCircuitsSummaryPostExecute(r ApiV2MonitoringCircuitsSummaryPostRequest) (*V2MonitoringCircuitsSummaryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringCircuitsSummaryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsUtilizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsUtilizationPostRequest *V2MonitoringCircuitsUtilizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsUtilizationPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsUtilizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsUtilizationPostRequest) V2MonitoringCircuitsUtilizationPostRequest(v2MonitoringCircuitsUtilizationPostRequest V2MonitoringCircuitsUtilizationPostRequest) ApiV2MonitoringCircuitsUtilizationPostRequest {
	r.v2MonitoringCircuitsUtilizationPostRequest = &v2MonitoringCircuitsUtilizationPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsUtilizationPostRequest) Execute() (*V2MonitoringCircuitsUtilizationPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsUtilizationPostExecute(r)
}

/*
V2MonitoringCircuitsUtilizationPost Method for V2MonitoringCircuitsUtilizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsUtilizationPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsUtilizationPost(ctx context.Context) ApiV2MonitoringCircuitsUtilizationPostRequest {
	return ApiV2MonitoringCircuitsUtilizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringCircuitsUtilizationPostResponse
func (a *DefaultAPIService) V2MonitoringCircuitsUtilizationPostExecute(r ApiV2MonitoringCircuitsUtilizationPostRequest) (*V2MonitoringCircuitsUtilizationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringCircuitsUtilizationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsUtilizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/utilization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsUtilizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsUtilizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsUtilizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsVisualizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsVisualizationPostRequest *V2MonitoringCircuitsVisualizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsVisualizationPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsVisualizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsVisualizationPostRequest) V2MonitoringCircuitsVisualizationPostRequest(v2MonitoringCircuitsVisualizationPostRequest V2MonitoringCircuitsVisualizationPostRequest) ApiV2MonitoringCircuitsVisualizationPostRequest {
	r.v2MonitoringCircuitsVisualizationPostRequest = &v2MonitoringCircuitsVisualizationPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsVisualizationPostRequest) Execute() (*V2MonitoringCircuitsVisualizationPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsVisualizationPostExecute(r)
}

/*
V2MonitoringCircuitsVisualizationPost Method for V2MonitoringCircuitsVisualizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsVisualizationPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsVisualizationPost(ctx context.Context) ApiV2MonitoringCircuitsVisualizationPostRequest {
	return ApiV2MonitoringCircuitsVisualizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringCircuitsVisualizationPostResponse
func (a *DefaultAPIService) V2MonitoringCircuitsVisualizationPostExecute(r ApiV2MonitoringCircuitsVisualizationPostRequest) (*V2MonitoringCircuitsVisualizationPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringCircuitsVisualizationPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsVisualizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/visualization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsVisualizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsVisualizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsVisualizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetEdgeStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
	isProvider *bool
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetEdgeStatusGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetEdgeStatusGetRequest {
	r.authorization = &authorization
	return r
}

// the id associated with an entity - consumer_id for consumer, and service_id for the producer/service
func (r ApiV2MonitoringExtranetEdgeStatusGetRequest) Id(id int64) ApiV2MonitoringExtranetEdgeStatusGetRequest {
	r.id = &id
	return r
}

// whether the entity is a provider or consumer
func (r ApiV2MonitoringExtranetEdgeStatusGetRequest) IsProvider(isProvider bool) ApiV2MonitoringExtranetEdgeStatusGetRequest {
	r.isProvider = &isProvider
	return r
}

func (r ApiV2MonitoringExtranetEdgeStatusGetRequest) Execute() (*V2MonitoringExtranetEdgeStatusGetResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetEdgeStatusGetExecute(r)
}

/*
V2MonitoringExtranetEdgeStatusGet Method for V2MonitoringExtranetEdgeStatusGet

Returns connectivity status for individual edges/gateways in extranet/ b2b application service monitoring. Provides granular view of which specific edges can reach server IP addresses. Shows per-edge connectivity status including healthy, impaired, or down states. Helps identify specific edge-level connectivity issues within sites.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetEdgeStatusGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetEdgeStatusGet(ctx context.Context) ApiV2MonitoringExtranetEdgeStatusGetRequest {
	return ApiV2MonitoringExtranetEdgeStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetEdgeStatusGetResponse
func (a *DefaultAPIService) V2MonitoringExtranetEdgeStatusGetExecute(r ApiV2MonitoringExtranetEdgeStatusGetRequest) (*V2MonitoringExtranetEdgeStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetEdgeStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetEdgeStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/edge-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.isProvider == nil {
		return localVarReturnValue, nil, reportError("isProvider is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "isProvider", r.isProvider, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetLogDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringExtranetLogDetailsPostRequest *V2MonitoringExtranetLogDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetLogDetailsPostRequest) Authorization(authorization string) ApiV2MonitoringExtranetLogDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetLogDetailsPostRequest) V2MonitoringExtranetLogDetailsPostRequest(v2MonitoringExtranetLogDetailsPostRequest V2MonitoringExtranetLogDetailsPostRequest) ApiV2MonitoringExtranetLogDetailsPostRequest {
	r.v2MonitoringExtranetLogDetailsPostRequest = &v2MonitoringExtranetLogDetailsPostRequest
	return r
}

func (r ApiV2MonitoringExtranetLogDetailsPostRequest) Execute() (*V2MonitoringExtranetLogDetailsPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetLogDetailsPostExecute(r)
}

/*
V2MonitoringExtranetLogDetailsPost Method for V2MonitoringExtranetLogDetailsPost

Returns connectivity logs for service monitoring. Includes timestamps for when connectivity from an edge/gateway to a Server IP address was lost or regained.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetLogDetailsPostRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetLogDetailsPost(ctx context.Context) ApiV2MonitoringExtranetLogDetailsPostRequest {
	return ApiV2MonitoringExtranetLogDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetLogDetailsPostResponse
func (a *DefaultAPIService) V2MonitoringExtranetLogDetailsPostExecute(r ApiV2MonitoringExtranetLogDetailsPostRequest) (*V2MonitoringExtranetLogDetailsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetLogDetailsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetLogDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/log-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringExtranetLogDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringExtranetLogDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringExtranetLogDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetServiceStatusDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
	isProvider *bool
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetServiceStatusDetailsGetRequest {
	r.authorization = &authorization
	return r
}

// the id associated with an entity - consumer_id for consumer, and service_id for the producer/service
func (r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) Id(id int64) ApiV2MonitoringExtranetServiceStatusDetailsGetRequest {
	r.id = &id
	return r
}

// whether the entity is a provider or consumer
func (r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) IsProvider(isProvider bool) ApiV2MonitoringExtranetServiceStatusDetailsGetRequest {
	r.isProvider = &isProvider
	return r
}

func (r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) Execute() (*V2MonitoringExtranetServiceStatusDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetServiceStatusDetailsGetExecute(r)
}

/*
V2MonitoringExtranetServiceStatusDetailsGet Method for V2MonitoringExtranetServiceStatusDetailsGet

Returns a list of Site-to-ServerIPAddress statuses for a particular producer of consumer. Each element contains a Site object (with site information) and a mapping of Server Ip addresses to the corresponding Reachability status.Healthy status indicates all the edges/gateways within the Site can reach all the Server IP addresses.Impaired status indicates that some of the edges/gateways within the Site can reach only a subset of Server IP addresses.Down status indicates that none of the edges/gateways within the Site can reach any of the Server IP addresses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetServiceStatusDetailsGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusDetailsGet(ctx context.Context) ApiV2MonitoringExtranetServiceStatusDetailsGetRequest {
	return ApiV2MonitoringExtranetServiceStatusDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetServiceStatusDetailsGetResponse
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusDetailsGetExecute(r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) (*V2MonitoringExtranetServiceStatusDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetServiceStatusDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetServiceStatusDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/service-status/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.isProvider == nil {
		return localVarReturnValue, nil, reportError("isProvider is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "isProvider", r.isProvider, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetServiceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
	isProvider *bool
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetServiceStatusGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetServiceStatusGetRequest {
	r.authorization = &authorization
	return r
}

// the id associated with an entity - consumer_id for consumer, and service_id for the producer/service
func (r ApiV2MonitoringExtranetServiceStatusGetRequest) Id(id int64) ApiV2MonitoringExtranetServiceStatusGetRequest {
	r.id = &id
	return r
}

// whether the entity is a provider or consumer
func (r ApiV2MonitoringExtranetServiceStatusGetRequest) IsProvider(isProvider bool) ApiV2MonitoringExtranetServiceStatusGetRequest {
	r.isProvider = &isProvider
	return r
}

func (r ApiV2MonitoringExtranetServiceStatusGetRequest) Execute() (*V2MonitoringExtranetServiceStatusGetResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetServiceStatusGetExecute(r)
}

/*
V2MonitoringExtranetServiceStatusGet Method for V2MonitoringExtranetServiceStatusGet

Returns a list of Status objects indicating the availability/reachability of all the Server IP addresses configured to the service. Healthy status indicates the Server IP address is reachable from all provider sites. Impaired status indicates the Server IP address is reachable from a subset of provider sites. Down status indicates the Server IP address can't be reached from any of the provider sites.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetServiceStatusGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusGet(ctx context.Context) ApiV2MonitoringExtranetServiceStatusGetRequest {
	return ApiV2MonitoringExtranetServiceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetServiceStatusGetResponse
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusGetExecute(r ApiV2MonitoringExtranetServiceStatusGetRequest) (*V2MonitoringExtranetServiceStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetServiceStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetServiceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/service-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.isProvider == nil {
		return localVarReturnValue, nil, reportError("isProvider is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "isProvider", r.isProvider, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetSiteStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
	isProvider *bool
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetSiteStatusGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetSiteStatusGetRequest {
	r.authorization = &authorization
	return r
}

// the id associated with an entity - consumer_id for consumer, and service_id for the producer/service
func (r ApiV2MonitoringExtranetSiteStatusGetRequest) Id(id int64) ApiV2MonitoringExtranetSiteStatusGetRequest {
	r.id = &id
	return r
}

// whether the entity is a provider or consumer
func (r ApiV2MonitoringExtranetSiteStatusGetRequest) IsProvider(isProvider bool) ApiV2MonitoringExtranetSiteStatusGetRequest {
	r.isProvider = &isProvider
	return r
}

func (r ApiV2MonitoringExtranetSiteStatusGetRequest) Execute() (*V2MonitoringExtranetSiteStatusGetResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetSiteStatusGetExecute(r)
}

/*
V2MonitoringExtranetSiteStatusGet Method for V2MonitoringExtranetSiteStatusGet

Returns a list of Statuses objects indicating the availability/reachability of the Server IP addresses from the Sites configured to the Provider or Consumer of the service.Healthy status indicates the Site can reach all the Server IP Addresses.Impaired status indicates that the Site can reach only a subset of Server IP addresses.Down status indicates the Site can reach none of the Server IP addresses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetSiteStatusGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetSiteStatusGet(ctx context.Context) ApiV2MonitoringExtranetSiteStatusGetRequest {
	return ApiV2MonitoringExtranetSiteStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetSiteStatusGetResponse
func (a *DefaultAPIService) V2MonitoringExtranetSiteStatusGetExecute(r ApiV2MonitoringExtranetSiteStatusGetRequest) (*V2MonitoringExtranetSiteStatusGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetSiteStatusGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetSiteStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/site-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.isProvider == nil {
		return localVarReturnValue, nil, reportError("isProvider is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "isProvider", r.isProvider, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetStatusDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
	isProvider *bool
	serverAddress *string
	siteId *int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	r.authorization = &authorization
	return r
}

// the id associated with an entity - consumer_id for consumer, and service_id for the producer/service
func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) Id(id int64) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	r.id = &id
	return r
}

// whether the entity is a provider or consumer
func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) IsProvider(isProvider bool) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	r.isProvider = &isProvider
	return r
}

// the address of the server
func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) ServerAddress(serverAddress string) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	r.serverAddress = &serverAddress
	return r
}

// the id of the site
func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) SiteId(siteId int64) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	r.siteId = &siteId
	return r
}

func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) Execute() (*V2MonitoringExtranetStatusDetailsGetResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetStatusDetailsGetExecute(r)
}

/*
V2MonitoringExtranetStatusDetailsGet Method for V2MonitoringExtranetStatusDetailsGet

Detailed view of the reachability of the Server IP addresses from the selected (producer or consumer) Site.Lists Site-to-ServerIPAddress statuses for the selected SiteLists Edge-to-ServerIPAddress statuses for All Edges within the selected Site.Returns physical Location of the SiteReturns Region of the Site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetStatusDetailsGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetStatusDetailsGet(ctx context.Context) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	return ApiV2MonitoringExtranetStatusDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetStatusDetailsGetResponse
func (a *DefaultAPIService) V2MonitoringExtranetStatusDetailsGetExecute(r ApiV2MonitoringExtranetStatusDetailsGetRequest) (*V2MonitoringExtranetStatusDetailsGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetStatusDetailsGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetStatusDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/status-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.isProvider == nil {
		return localVarReturnValue, nil, reportError("isProvider is required and must be specified")
	}
	if r.serverAddress == nil {
		return localVarReturnValue, nil, reportError("serverAddress is required and must be specified")
	}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "isProvider", r.isProvider, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "serverAddress", r.serverAddress, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringIkeErrorHistoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringIkeErrorHistoryPostRequest *V2MonitoringIkeErrorHistoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringIkeErrorHistoryPostRequest) Authorization(authorization string) ApiV2MonitoringIkeErrorHistoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringIkeErrorHistoryPostRequest) V2MonitoringIkeErrorHistoryPostRequest(v2MonitoringIkeErrorHistoryPostRequest V2MonitoringIkeErrorHistoryPostRequest) ApiV2MonitoringIkeErrorHistoryPostRequest {
	r.v2MonitoringIkeErrorHistoryPostRequest = &v2MonitoringIkeErrorHistoryPostRequest
	return r
}

func (r ApiV2MonitoringIkeErrorHistoryPostRequest) Execute() (*V2MonitoringIkeErrorHistoryPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringIkeErrorHistoryPostExecute(r)
}

/*
V2MonitoringIkeErrorHistoryPost Method for V2MonitoringIkeErrorHistoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringIkeErrorHistoryPostRequest
*/
func (a *DefaultAPIService) V2MonitoringIkeErrorHistoryPost(ctx context.Context) ApiV2MonitoringIkeErrorHistoryPostRequest {
	return ApiV2MonitoringIkeErrorHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringIkeErrorHistoryPostResponse
func (a *DefaultAPIService) V2MonitoringIkeErrorHistoryPostExecute(r ApiV2MonitoringIkeErrorHistoryPostRequest) (*V2MonitoringIkeErrorHistoryPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringIkeErrorHistoryPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringIkeErrorHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/ike-error-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringIkeErrorHistoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringIkeErrorHistoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringIkeErrorHistoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringInterfacePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringInterfacePostRequest *V2MonitoringInterfacePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringInterfacePostRequest) Authorization(authorization string) ApiV2MonitoringInterfacePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringInterfacePostRequest) V2MonitoringInterfacePostRequest(v2MonitoringInterfacePostRequest V2MonitoringInterfacePostRequest) ApiV2MonitoringInterfacePostRequest {
	r.v2MonitoringInterfacePostRequest = &v2MonitoringInterfacePostRequest
	return r
}

func (r ApiV2MonitoringInterfacePostRequest) Execute() (*V2MonitoringInterfacePostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringInterfacePostExecute(r)
}

/*
V2MonitoringInterfacePost Method for V2MonitoringInterfacePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringInterfacePostRequest
*/
func (a *DefaultAPIService) V2MonitoringInterfacePost(ctx context.Context) ApiV2MonitoringInterfacePostRequest {
	return ApiV2MonitoringInterfacePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringInterfacePostResponse
func (a *DefaultAPIService) V2MonitoringInterfacePostExecute(r ApiV2MonitoringInterfacePostRequest) (*V2MonitoringInterfacePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringInterfacePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringInterfacePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringInterfacePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringInterfacePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringInterfacePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringIpsecPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringIpsecPostRequest *V2MonitoringIpsecPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringIpsecPostRequest) Authorization(authorization string) ApiV2MonitoringIpsecPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringIpsecPostRequest) V2MonitoringIpsecPostRequest(v2MonitoringIpsecPostRequest V2MonitoringIpsecPostRequest) ApiV2MonitoringIpsecPostRequest {
	r.v2MonitoringIpsecPostRequest = &v2MonitoringIpsecPostRequest
	return r
}

func (r ApiV2MonitoringIpsecPostRequest) Execute() (*V2MonitoringIpsecPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringIpsecPostExecute(r)
}

/*
V2MonitoringIpsecPost Method for V2MonitoringIpsecPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringIpsecPostRequest
*/
func (a *DefaultAPIService) V2MonitoringIpsecPost(ctx context.Context) ApiV2MonitoringIpsecPostRequest {
	return ApiV2MonitoringIpsecPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringIpsecPostResponse
func (a *DefaultAPIService) V2MonitoringIpsecPostExecute(r ApiV2MonitoringIpsecPostRequest) (*V2MonitoringIpsecPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringIpsecPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringIpsecPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringIpsecPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringIpsecPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringIpsecPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringOspfPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringOspfPostRequest *V2MonitoringOspfPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringOspfPostRequest) Authorization(authorization string) ApiV2MonitoringOspfPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringOspfPostRequest) V2MonitoringOspfPostRequest(v2MonitoringOspfPostRequest V2MonitoringOspfPostRequest) ApiV2MonitoringOspfPostRequest {
	r.v2MonitoringOspfPostRequest = &v2MonitoringOspfPostRequest
	return r
}

func (r ApiV2MonitoringOspfPostRequest) Execute() (*V2MonitoringOspfPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringOspfPostExecute(r)
}

/*
V2MonitoringOspfPost Method for V2MonitoringOspfPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringOspfPostRequest
*/
func (a *DefaultAPIService) V2MonitoringOspfPost(ctx context.Context) ApiV2MonitoringOspfPostRequest {
	return ApiV2MonitoringOspfPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringOspfPostResponse
func (a *DefaultAPIService) V2MonitoringOspfPostExecute(r ApiV2MonitoringOspfPostRequest) (*V2MonitoringOspfPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringOspfPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringOspfPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/ospf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringOspfPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringOspfPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringOspfPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringPolicyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringPolicyPostRequest *V2MonitoringPolicyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringPolicyPostRequest) Authorization(authorization string) ApiV2MonitoringPolicyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringPolicyPostRequest) V2MonitoringPolicyPostRequest(v2MonitoringPolicyPostRequest V2MonitoringPolicyPostRequest) ApiV2MonitoringPolicyPostRequest {
	r.v2MonitoringPolicyPostRequest = &v2MonitoringPolicyPostRequest
	return r
}

func (r ApiV2MonitoringPolicyPostRequest) Execute() (*V2MonitoringPolicyPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringPolicyPostExecute(r)
}

/*
V2MonitoringPolicyPost Method for V2MonitoringPolicyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringPolicyPostRequest
*/
func (a *DefaultAPIService) V2MonitoringPolicyPost(ctx context.Context) ApiV2MonitoringPolicyPostRequest {
	return ApiV2MonitoringPolicyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringPolicyPostResponse
func (a *DefaultAPIService) V2MonitoringPolicyPostExecute(r ApiV2MonitoringPolicyPostRequest) (*V2MonitoringPolicyPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringPolicyPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringPolicyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringPolicyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringPolicyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringPolicyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringQueueInstantPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringQueueInstantPostRequest *V2MonitoringQueueInstantPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringQueueInstantPostRequest) Authorization(authorization string) ApiV2MonitoringQueueInstantPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringQueueInstantPostRequest) V2MonitoringQueueInstantPostRequest(v2MonitoringQueueInstantPostRequest V2MonitoringQueueInstantPostRequest) ApiV2MonitoringQueueInstantPostRequest {
	r.v2MonitoringQueueInstantPostRequest = &v2MonitoringQueueInstantPostRequest
	return r
}

func (r ApiV2MonitoringQueueInstantPostRequest) Execute() (*V2MonitoringQueueInstantPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringQueueInstantPostExecute(r)
}

/*
V2MonitoringQueueInstantPost Method for V2MonitoringQueueInstantPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringQueueInstantPostRequest
*/
func (a *DefaultAPIService) V2MonitoringQueueInstantPost(ctx context.Context) ApiV2MonitoringQueueInstantPostRequest {
	return ApiV2MonitoringQueueInstantPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringQueueInstantPostResponse
func (a *DefaultAPIService) V2MonitoringQueueInstantPostExecute(r ApiV2MonitoringQueueInstantPostRequest) (*V2MonitoringQueueInstantPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringQueueInstantPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringQueueInstantPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/queue-instant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringQueueInstantPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringQueueInstantPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringQueueInstantPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringQueuePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringQueuePostRequest *V2MonitoringQueuePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringQueuePostRequest) Authorization(authorization string) ApiV2MonitoringQueuePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringQueuePostRequest) V2MonitoringQueuePostRequest(v2MonitoringQueuePostRequest V2MonitoringQueuePostRequest) ApiV2MonitoringQueuePostRequest {
	r.v2MonitoringQueuePostRequest = &v2MonitoringQueuePostRequest
	return r
}

func (r ApiV2MonitoringQueuePostRequest) Execute() (*V2MonitoringQueuePostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringQueuePostExecute(r)
}

/*
V2MonitoringQueuePost Method for V2MonitoringQueuePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringQueuePostRequest
*/
func (a *DefaultAPIService) V2MonitoringQueuePost(ctx context.Context) ApiV2MonitoringQueuePostRequest {
	return ApiV2MonitoringQueuePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringQueuePostResponse
func (a *DefaultAPIService) V2MonitoringQueuePostExecute(r ApiV2MonitoringQueuePostRequest) (*V2MonitoringQueuePostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringQueuePostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringQueuePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringQueuePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringQueuePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringQueuePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSegmentRouteCountsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringSegmentRouteCountsPostRequest *V2MonitoringSegmentRouteCountsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSegmentRouteCountsPostRequest) Authorization(authorization string) ApiV2MonitoringSegmentRouteCountsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSegmentRouteCountsPostRequest) V2MonitoringSegmentRouteCountsPostRequest(v2MonitoringSegmentRouteCountsPostRequest V2MonitoringSegmentRouteCountsPostRequest) ApiV2MonitoringSegmentRouteCountsPostRequest {
	r.v2MonitoringSegmentRouteCountsPostRequest = &v2MonitoringSegmentRouteCountsPostRequest
	return r
}

func (r ApiV2MonitoringSegmentRouteCountsPostRequest) Execute() (*V2MonitoringSegmentRouteCountsPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringSegmentRouteCountsPostExecute(r)
}

/*
V2MonitoringSegmentRouteCountsPost Method for V2MonitoringSegmentRouteCountsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringSegmentRouteCountsPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSegmentRouteCountsPost(ctx context.Context) ApiV2MonitoringSegmentRouteCountsPostRequest {
	return ApiV2MonitoringSegmentRouteCountsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringSegmentRouteCountsPostResponse
func (a *DefaultAPIService) V2MonitoringSegmentRouteCountsPostExecute(r ApiV2MonitoringSegmentRouteCountsPostRequest) (*V2MonitoringSegmentRouteCountsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSegmentRouteCountsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSegmentRouteCountsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/segment-route-counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringSegmentRouteCountsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSegmentRouteCountsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSegmentRouteCountsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest *V2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) Authorization(authorization string) ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) V2MonitoringSiteCircuitsBandwidthSiteIdPostRequest(v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest V2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest {
	r.v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest = &v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
	return r
}

func (r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) Execute() (*V2MonitoringSiteCircuitsBandwidthSiteIdPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringSiteCircuitsBandwidthSiteIdPostExecute(r)
}

/*
V2MonitoringSiteCircuitsBandwidthSiteIdPost Method for V2MonitoringSiteCircuitsBandwidthSiteIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSiteCircuitsBandwidthSiteIdPost(ctx context.Context, siteId int64) ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest {
	return ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2MonitoringSiteCircuitsBandwidthSiteIdPostResponse
func (a *DefaultAPIService) V2MonitoringSiteCircuitsBandwidthSiteIdPostExecute(r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) (*V2MonitoringSiteCircuitsBandwidthSiteIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSiteCircuitsBandwidthSiteIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSiteCircuitsBandwidthSiteIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/site-circuits/bandwidth/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.siteId < 0 {
		return localVarReturnValue, nil, reportError("siteId must be greater than 0")
	}
	if r.v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSiteTwampSiteIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2MonitoringSiteTwampSiteIdPostRequest *V2MonitoringSiteTwampSiteIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSiteTwampSiteIdPostRequest) Authorization(authorization string) ApiV2MonitoringSiteTwampSiteIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSiteTwampSiteIdPostRequest) V2MonitoringSiteTwampSiteIdPostRequest(v2MonitoringSiteTwampSiteIdPostRequest V2MonitoringSiteTwampSiteIdPostRequest) ApiV2MonitoringSiteTwampSiteIdPostRequest {
	r.v2MonitoringSiteTwampSiteIdPostRequest = &v2MonitoringSiteTwampSiteIdPostRequest
	return r
}

func (r ApiV2MonitoringSiteTwampSiteIdPostRequest) Execute() (*V2MonitoringSiteTwampSiteIdPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringSiteTwampSiteIdPostExecute(r)
}

/*
V2MonitoringSiteTwampSiteIdPost Method for V2MonitoringSiteTwampSiteIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2MonitoringSiteTwampSiteIdPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSiteTwampSiteIdPost(ctx context.Context, siteId int64) ApiV2MonitoringSiteTwampSiteIdPostRequest {
	return ApiV2MonitoringSiteTwampSiteIdPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2MonitoringSiteTwampSiteIdPostResponse
func (a *DefaultAPIService) V2MonitoringSiteTwampSiteIdPostExecute(r ApiV2MonitoringSiteTwampSiteIdPostRequest) (*V2MonitoringSiteTwampSiteIdPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSiteTwampSiteIdPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSiteTwampSiteIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/site-twamp/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.siteId < 0 {
		return localVarReturnValue, nil, reportError("siteId must be greater than 0")
	}
	if r.v2MonitoringSiteTwampSiteIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSiteTwampSiteIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSiteTwampSiteIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSystemGenericPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringSystemGenericPostRequest *V2MonitoringSystemGenericPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSystemGenericPostRequest) Authorization(authorization string) ApiV2MonitoringSystemGenericPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSystemGenericPostRequest) V2MonitoringSystemGenericPostRequest(v2MonitoringSystemGenericPostRequest V2MonitoringSystemGenericPostRequest) ApiV2MonitoringSystemGenericPostRequest {
	r.v2MonitoringSystemGenericPostRequest = &v2MonitoringSystemGenericPostRequest
	return r
}

func (r ApiV2MonitoringSystemGenericPostRequest) Execute() (*V2MonitoringSystemGenericPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringSystemGenericPostExecute(r)
}

/*
V2MonitoringSystemGenericPost Method for V2MonitoringSystemGenericPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringSystemGenericPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSystemGenericPost(ctx context.Context) ApiV2MonitoringSystemGenericPostRequest {
	return ApiV2MonitoringSystemGenericPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringSystemGenericPostResponse
func (a *DefaultAPIService) V2MonitoringSystemGenericPostExecute(r ApiV2MonitoringSystemGenericPostRequest) (*V2MonitoringSystemGenericPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSystemGenericPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSystemGenericPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/system/generic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringSystemGenericPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSystemGenericPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSystemGenericPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSystemPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringSystemPostRequest *V2MonitoringSystemPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSystemPostRequest) Authorization(authorization string) ApiV2MonitoringSystemPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSystemPostRequest) V2MonitoringSystemPostRequest(v2MonitoringSystemPostRequest V2MonitoringSystemPostRequest) ApiV2MonitoringSystemPostRequest {
	r.v2MonitoringSystemPostRequest = &v2MonitoringSystemPostRequest
	return r
}

func (r ApiV2MonitoringSystemPostRequest) Execute() (*V2MonitoringSystemPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringSystemPostExecute(r)
}

/*
V2MonitoringSystemPost Method for V2MonitoringSystemPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringSystemPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSystemPost(ctx context.Context) ApiV2MonitoringSystemPostRequest {
	return ApiV2MonitoringSystemPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringSystemPostResponse
func (a *DefaultAPIService) V2MonitoringSystemPostExecute(r ApiV2MonitoringSystemPostRequest) (*V2MonitoringSystemPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSystemPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSystemPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringSystemPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSystemPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSystemPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringTwampPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringTwampPostRequest *V2MonitoringTwampPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringTwampPostRequest) Authorization(authorization string) ApiV2MonitoringTwampPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringTwampPostRequest) V2MonitoringTwampPostRequest(v2MonitoringTwampPostRequest V2MonitoringTwampPostRequest) ApiV2MonitoringTwampPostRequest {
	r.v2MonitoringTwampPostRequest = &v2MonitoringTwampPostRequest
	return r
}

func (r ApiV2MonitoringTwampPostRequest) Execute() (*V2MonitoringTwampPostResponse, *http.Response, error) {
	return r.ApiService.V2MonitoringTwampPostExecute(r)
}

/*
V2MonitoringTwampPost Method for V2MonitoringTwampPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringTwampPostRequest
*/
func (a *DefaultAPIService) V2MonitoringTwampPost(ctx context.Context) ApiV2MonitoringTwampPostRequest {
	return ApiV2MonitoringTwampPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringTwampPostResponse
func (a *DefaultAPIService) V2MonitoringTwampPostExecute(r ApiV2MonitoringTwampPostRequest) (*V2MonitoringTwampPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringTwampPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringTwampPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/twamp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringTwampPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringTwampPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringTwampPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationCreatePostRequest *V2NotificationCreatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationCreatePostRequest) Authorization(authorization string) ApiV2NotificationCreatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationCreatePostRequest) V2NotificationCreatePostRequest(v2NotificationCreatePostRequest V2NotificationCreatePostRequest) ApiV2NotificationCreatePostRequest {
	r.v2NotificationCreatePostRequest = &v2NotificationCreatePostRequest
	return r
}

func (r ApiV2NotificationCreatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationCreatePostExecute(r)
}

/*
V2NotificationCreatePost Method for V2NotificationCreatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationCreatePostRequest
*/
func (a *DefaultAPIService) V2NotificationCreatePost(ctx context.Context) ApiV2NotificationCreatePostRequest {
	return ApiV2NotificationCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationCreatePostExecute(r ApiV2NotificationCreatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationCreatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationCreatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationCreatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationDeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationDeletePostRequest *V2NotificationDeletePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationDeletePostRequest) Authorization(authorization string) ApiV2NotificationDeletePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationDeletePostRequest) V2NotificationDeletePostRequest(v2NotificationDeletePostRequest V2NotificationDeletePostRequest) ApiV2NotificationDeletePostRequest {
	r.v2NotificationDeletePostRequest = &v2NotificationDeletePostRequest
	return r
}

func (r ApiV2NotificationDeletePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationDeletePostExecute(r)
}

/*
V2NotificationDeletePost Method for V2NotificationDeletePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationDeletePostRequest
*/
func (a *DefaultAPIService) V2NotificationDeletePost(ctx context.Context) ApiV2NotificationDeletePostRequest {
	return ApiV2NotificationDeletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationDeletePostExecute(r ApiV2NotificationDeletePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationDeletePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationDeletePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationDeletePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationEnabledisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationEnabledisablePostRequest *V2NotificationEnabledisablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationEnabledisablePostRequest) Authorization(authorization string) ApiV2NotificationEnabledisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationEnabledisablePostRequest) V2NotificationEnabledisablePostRequest(v2NotificationEnabledisablePostRequest V2NotificationEnabledisablePostRequest) ApiV2NotificationEnabledisablePostRequest {
	r.v2NotificationEnabledisablePostRequest = &v2NotificationEnabledisablePostRequest
	return r
}

func (r ApiV2NotificationEnabledisablePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationEnabledisablePostExecute(r)
}

/*
V2NotificationEnabledisablePost Method for V2NotificationEnabledisablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationEnabledisablePostRequest
*/
func (a *DefaultAPIService) V2NotificationEnabledisablePost(ctx context.Context) ApiV2NotificationEnabledisablePostRequest {
	return ApiV2NotificationEnabledisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationEnabledisablePostExecute(r ApiV2NotificationEnabledisablePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationEnabledisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/enabledisable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationEnabledisablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationEnabledisablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationEnabledisablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationUpdatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationUpdatePostRequest *V2NotificationUpdatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationUpdatePostRequest) Authorization(authorization string) ApiV2NotificationUpdatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationUpdatePostRequest) V2NotificationUpdatePostRequest(v2NotificationUpdatePostRequest V2NotificationUpdatePostRequest) ApiV2NotificationUpdatePostRequest {
	r.v2NotificationUpdatePostRequest = &v2NotificationUpdatePostRequest
	return r
}

func (r ApiV2NotificationUpdatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationUpdatePostExecute(r)
}

/*
V2NotificationUpdatePost Method for V2NotificationUpdatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationUpdatePostRequest
*/
func (a *DefaultAPIService) V2NotificationUpdatePost(ctx context.Context) ApiV2NotificationUpdatePostRequest {
	return ApiV2NotificationUpdatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationUpdatePostExecute(r ApiV2NotificationUpdatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationUpdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationUpdatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationUpdatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationUpdatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationlistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationlistPostRequest) Authorization(authorization string) ApiV2NotificationlistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationlistPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2NotificationlistPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2NotificationlistPostRequest) Execute() (*V2NotificationlistPostResponse, *http.Response, error) {
	return r.ApiService.V2NotificationlistPostExecute(r)
}

/*
V2NotificationlistPost Method for V2NotificationlistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationlistPostRequest
*/
func (a *DefaultAPIService) V2NotificationlistPost(ctx context.Context) ApiV2NotificationlistPostRequest {
	return ApiV2NotificationlistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2NotificationlistPostResponse
func (a *DefaultAPIService) V2NotificationlistPostExecute(r ApiV2NotificationlistPostRequest) (*V2NotificationlistPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2NotificationlistPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationlistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationmutelistCreatePostRequest *V2NotificationmutelistCreatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistCreatePostRequest) Authorization(authorization string) ApiV2NotificationmutelistCreatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistCreatePostRequest) V2NotificationmutelistCreatePostRequest(v2NotificationmutelistCreatePostRequest V2NotificationmutelistCreatePostRequest) ApiV2NotificationmutelistCreatePostRequest {
	r.v2NotificationmutelistCreatePostRequest = &v2NotificationmutelistCreatePostRequest
	return r
}

func (r ApiV2NotificationmutelistCreatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistCreatePostExecute(r)
}

/*
V2NotificationmutelistCreatePost Method for V2NotificationmutelistCreatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationmutelistCreatePostRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistCreatePost(ctx context.Context) ApiV2NotificationmutelistCreatePostRequest {
	return ApiV2NotificationmutelistCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationmutelistCreatePostExecute(r ApiV2NotificationmutelistCreatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationmutelistCreatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationmutelistCreatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationmutelistCreatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	alertId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest) Authorization(authorization string) ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistDeletebyalertidAlertIdDeleteExecute(r)
}

/*
V2NotificationmutelistDeletebyalertidAlertIdDelete Method for V2NotificationmutelistDeletebyalertidAlertIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertId Alert id of the alert to delete allowlist/mutelist for
 @return ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistDeletebyalertidAlertIdDelete(ctx context.Context, alertId string) ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest {
	return ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		alertId: alertId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationmutelistDeletebyalertidAlertIdDeleteExecute(r ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistDeletebyalertidAlertIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/deletebyalertid/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	entityId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest) Authorization(authorization string) ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistDeletebyentityidEntityIdDeleteExecute(r)
}

/*
V2NotificationmutelistDeletebyentityidEntityIdDelete Method for V2NotificationmutelistDeletebyentityidEntityIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityId Entity id of the alert to delete allowlist/mutelist for
 @return ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistDeletebyentityidEntityIdDelete(ctx context.Context, entityId string) ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest {
	return ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		entityId: entityId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationmutelistDeletebyentityidEntityIdDeleteExecute(r ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistDeletebyentityidEntityIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/deletebyentityid/{entityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", url.PathEscape(parameterValueToString(r.entityId, "entityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistRuleIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	ruleId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistRuleIdGetRequest) Authorization(authorization string) ApiV2NotificationmutelistRuleIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistRuleIdGetRequest) Execute() (*V2NotificationmutelistRuleIdGetResponse, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistRuleIdGetExecute(r)
}

/*
V2NotificationmutelistRuleIdGet Method for V2NotificationmutelistRuleIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleId Alert id of the alert to retrieve allowlist/mutelist for
 @return ApiV2NotificationmutelistRuleIdGetRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistRuleIdGet(ctx context.Context, ruleId string) ApiV2NotificationmutelistRuleIdGetRequest {
	return ApiV2NotificationmutelistRuleIdGetRequest{
		ApiService: a,
		ctx: ctx,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return V2NotificationmutelistRuleIdGetResponse
func (a *DefaultAPIService) V2NotificationmutelistRuleIdGetExecute(r ApiV2NotificationmutelistRuleIdGetRequest) (*V2NotificationmutelistRuleIdGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2NotificationmutelistRuleIdGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistRuleIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ParentalertlistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ParentalertlistPostRequest *V2ParentalertlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ParentalertlistPostRequest) Authorization(authorization string) ApiV2ParentalertlistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ParentalertlistPostRequest) V2ParentalertlistPostRequest(v2ParentalertlistPostRequest V2ParentalertlistPostRequest) ApiV2ParentalertlistPostRequest {
	r.v2ParentalertlistPostRequest = &v2ParentalertlistPostRequest
	return r
}

func (r ApiV2ParentalertlistPostRequest) Execute() (*V2ParentalertlistPostResponse, *http.Response, error) {
	return r.ApiService.V2ParentalertlistPostExecute(r)
}

/*
V2ParentalertlistPost Method for V2ParentalertlistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ParentalertlistPostRequest
*/
func (a *DefaultAPIService) V2ParentalertlistPost(ctx context.Context) ApiV2ParentalertlistPostRequest {
	return ApiV2ParentalertlistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ParentalertlistPostResponse
func (a *DefaultAPIService) V2ParentalertlistPostExecute(r ApiV2ParentalertlistPostRequest) (*V2ParentalertlistPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ParentalertlistPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ParentalertlistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/parentalertlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ParentalertlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ParentalertlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ParentalertlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2RuleEnabledisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2RuleEnabledisablePostRequest *V2RuleEnabledisablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2RuleEnabledisablePostRequest) Authorization(authorization string) ApiV2RuleEnabledisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2RuleEnabledisablePostRequest) V2RuleEnabledisablePostRequest(v2RuleEnabledisablePostRequest V2RuleEnabledisablePostRequest) ApiV2RuleEnabledisablePostRequest {
	r.v2RuleEnabledisablePostRequest = &v2RuleEnabledisablePostRequest
	return r
}

func (r ApiV2RuleEnabledisablePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2RuleEnabledisablePostExecute(r)
}

/*
V2RuleEnabledisablePost Method for V2RuleEnabledisablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2RuleEnabledisablePostRequest
*/
func (a *DefaultAPIService) V2RuleEnabledisablePost(ctx context.Context) ApiV2RuleEnabledisablePostRequest {
	return ApiV2RuleEnabledisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2RuleEnabledisablePostExecute(r ApiV2RuleEnabledisablePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2RuleEnabledisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/rule/enabledisable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2RuleEnabledisablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleEnabledisablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2RuleEnabledisablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2RulelistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2RulelistPostRequest) Authorization(authorization string) ApiV2RulelistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2RulelistPostRequest) Body(body map[string]interface{}) ApiV2RulelistPostRequest {
	r.body = &body
	return r
}

func (r ApiV2RulelistPostRequest) Execute() (*V2RulelistPostResponse, *http.Response, error) {
	return r.ApiService.V2RulelistPostExecute(r)
}

/*
V2RulelistPost Method for V2RulelistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2RulelistPostRequest
*/
func (a *DefaultAPIService) V2RulelistPost(ctx context.Context) ApiV2RulelistPostRequest {
	return ApiV2RulelistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2RulelistPostResponse
func (a *DefaultAPIService) V2RulelistPostExecute(r ApiV2RulelistPostRequest) (*V2RulelistPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RulelistPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2RulelistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/rulelist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2SiteSiteIdDetailPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2SiteSiteIdDetailPostRequest *V2SiteSiteIdDetailPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2SiteSiteIdDetailPostRequest) Authorization(authorization string) ApiV2SiteSiteIdDetailPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2SiteSiteIdDetailPostRequest) V2SiteSiteIdDetailPostRequest(v2SiteSiteIdDetailPostRequest V2SiteSiteIdDetailPostRequest) ApiV2SiteSiteIdDetailPostRequest {
	r.v2SiteSiteIdDetailPostRequest = &v2SiteSiteIdDetailPostRequest
	return r
}

func (r ApiV2SiteSiteIdDetailPostRequest) Execute() (*V2SiteSiteIdDetailPostResponse, *http.Response, error) {
	return r.ApiService.V2SiteSiteIdDetailPostExecute(r)
}

/*
V2SiteSiteIdDetailPost Method for V2SiteSiteIdDetailPost

Get site by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2SiteSiteIdDetailPostRequest
*/
func (a *DefaultAPIService) V2SiteSiteIdDetailPost(ctx context.Context, siteId int64) ApiV2SiteSiteIdDetailPostRequest {
	return ApiV2SiteSiteIdDetailPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2SiteSiteIdDetailPostResponse
func (a *DefaultAPIService) V2SiteSiteIdDetailPostExecute(r ApiV2SiteSiteIdDetailPostRequest) (*V2SiteSiteIdDetailPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SiteSiteIdDetailPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2SiteSiteIdDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/site/{siteId}/detail"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2SiteSiteIdDetailPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2SiteSiteIdDetailPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2SiteSiteIdDetailPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2SiteSiteIdLanSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2SiteSiteIdLanSegmentsPostRequest *V2SiteSiteIdLanSegmentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2SiteSiteIdLanSegmentsPostRequest) Authorization(authorization string) ApiV2SiteSiteIdLanSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2SiteSiteIdLanSegmentsPostRequest) V2SiteSiteIdLanSegmentsPostRequest(v2SiteSiteIdLanSegmentsPostRequest V2SiteSiteIdLanSegmentsPostRequest) ApiV2SiteSiteIdLanSegmentsPostRequest {
	r.v2SiteSiteIdLanSegmentsPostRequest = &v2SiteSiteIdLanSegmentsPostRequest
	return r
}

func (r ApiV2SiteSiteIdLanSegmentsPostRequest) Execute() (*V2SiteSiteIdLanSegmentsPostResponse, *http.Response, error) {
	return r.ApiService.V2SiteSiteIdLanSegmentsPostExecute(r)
}

/*
V2SiteSiteIdLanSegmentsPost Method for V2SiteSiteIdLanSegmentsPost

Get route count for all the LAN Segments in a site

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2SiteSiteIdLanSegmentsPostRequest
*/
func (a *DefaultAPIService) V2SiteSiteIdLanSegmentsPost(ctx context.Context, siteId int64) ApiV2SiteSiteIdLanSegmentsPostRequest {
	return ApiV2SiteSiteIdLanSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2SiteSiteIdLanSegmentsPostResponse
func (a *DefaultAPIService) V2SiteSiteIdLanSegmentsPostExecute(r ApiV2SiteSiteIdLanSegmentsPostRequest) (*V2SiteSiteIdLanSegmentsPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SiteSiteIdLanSegmentsPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2SiteSiteIdLanSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/site/{siteId}/lan-segments"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2SiteSiteIdLanSegmentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2SiteSiteIdLanSegmentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2SiteSiteIdLanSegmentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2SiteSiteIdTopologyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2SiteSiteIdTopologyPostRequest *V2SiteSiteIdTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2SiteSiteIdTopologyPostRequest) Authorization(authorization string) ApiV2SiteSiteIdTopologyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2SiteSiteIdTopologyPostRequest) V2SiteSiteIdTopologyPostRequest(v2SiteSiteIdTopologyPostRequest V2SiteSiteIdTopologyPostRequest) ApiV2SiteSiteIdTopologyPostRequest {
	r.v2SiteSiteIdTopologyPostRequest = &v2SiteSiteIdTopologyPostRequest
	return r
}

func (r ApiV2SiteSiteIdTopologyPostRequest) Execute() (*V2SiteSiteIdTopologyPostResponse, *http.Response, error) {
	return r.ApiService.V2SiteSiteIdTopologyPostExecute(r)
}

/*
V2SiteSiteIdTopologyPost Method for V2SiteSiteIdTopologyPost

Get the site topology

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2SiteSiteIdTopologyPostRequest
*/
func (a *DefaultAPIService) V2SiteSiteIdTopologyPost(ctx context.Context, siteId int64) ApiV2SiteSiteIdTopologyPostRequest {
	return ApiV2SiteSiteIdTopologyPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2SiteSiteIdTopologyPostResponse
func (a *DefaultAPIService) V2SiteSiteIdTopologyPostExecute(r ApiV2SiteSiteIdTopologyPostRequest) (*V2SiteSiteIdTopologyPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SiteSiteIdTopologyPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2SiteSiteIdTopologyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/site/{siteId}/topology"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2SiteSiteIdTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2SiteSiteIdTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2SiteSiteIdTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2VersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2VersionPostRequest) Authorization(authorization string) ApiV2VersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2VersionPostRequest) Body(body map[string]interface{}) ApiV2VersionPostRequest {
	r.body = &body
	return r
}

func (r ApiV2VersionPostRequest) Execute() (*V2VersionPostResponse, *http.Response, error) {
	return r.ApiService.V2VersionPostExecute(r)
}

/*
V2VersionPost Method for V2VersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2VersionPostRequest
*/
func (a *DefaultAPIService) V2VersionPost(ctx context.Context) ApiV2VersionPostRequest {
	return ApiV2VersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2VersionPostResponse
func (a *DefaultAPIService) V2VersionPostExecute(r ApiV2VersionPostRequest) (*V2VersionPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2VersionPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2VersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
