/*
Graphiant APIs

Graphiant API documentation.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package graphiant_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiV1AccountEmailPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountEmailPatchRequest *V1AccountEmailPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountEmailPatchRequest) Authorization(authorization string) ApiV1AccountEmailPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountEmailPatchRequest) V1AccountEmailPatchRequest(v1AccountEmailPatchRequest V1AccountEmailPatchRequest) ApiV1AccountEmailPatchRequest {
	r.v1AccountEmailPatchRequest = &v1AccountEmailPatchRequest
	return r
}

func (r ApiV1AccountEmailPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AccountEmailPatchExecute(r)
}

/*
V1AccountEmailPatch Method for V1AccountEmailPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountEmailPatchRequest
*/
func (a *DefaultAPIService) V1AccountEmailPatch(ctx context.Context) ApiV1AccountEmailPatchRequest {
	return ApiV1AccountEmailPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AccountEmailPatchExecute(r ApiV1AccountEmailPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountEmailPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountEmailPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountEmailPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountEmailPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountInfoPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountInfoPatchRequest *V1AccountInfoPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountInfoPatchRequest) Authorization(authorization string) ApiV1AccountInfoPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountInfoPatchRequest) V1AccountInfoPatchRequest(v1AccountInfoPatchRequest V1AccountInfoPatchRequest) ApiV1AccountInfoPatchRequest {
	r.v1AccountInfoPatchRequest = &v1AccountInfoPatchRequest
	return r
}

func (r ApiV1AccountInfoPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AccountInfoPatchExecute(r)
}

/*
V1AccountInfoPatch Method for V1AccountInfoPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountInfoPatchRequest
*/
func (a *DefaultAPIService) V1AccountInfoPatch(ctx context.Context) ApiV1AccountInfoPatchRequest {
	return ApiV1AccountInfoPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AccountInfoPatchExecute(r ApiV1AccountInfoPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountInfoPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountInfoPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountInfoPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountInfoPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountMfaConfirmationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountMfaConfirmationPostRequest *V1AccountMfaConfirmationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaConfirmationPostRequest) Authorization(authorization string) ApiV1AccountMfaConfirmationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaConfirmationPostRequest) V1AccountMfaConfirmationPostRequest(v1AccountMfaConfirmationPostRequest V1AccountMfaConfirmationPostRequest) ApiV1AccountMfaConfirmationPostRequest {
	r.v1AccountMfaConfirmationPostRequest = &v1AccountMfaConfirmationPostRequest
	return r
}

func (r ApiV1AccountMfaConfirmationPostRequest) Execute() (*V1AccountMfaConfirmationPost200Response, *http.Response, error) {
	return r.ApiService.V1AccountMfaConfirmationPostExecute(r)
}

/*
V1AccountMfaConfirmationPost Method for V1AccountMfaConfirmationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaConfirmationPostRequest
*/
func (a *DefaultAPIService) V1AccountMfaConfirmationPost(ctx context.Context) ApiV1AccountMfaConfirmationPostRequest {
	return ApiV1AccountMfaConfirmationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AccountMfaConfirmationPost200Response
func (a *DefaultAPIService) V1AccountMfaConfirmationPostExecute(r ApiV1AccountMfaConfirmationPostRequest) (*V1AccountMfaConfirmationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AccountMfaConfirmationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaConfirmationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa/confirmation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountMfaConfirmationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountMfaConfirmationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountMfaConfirmationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountMfaDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaDeleteRequest) Authorization(authorization string) ApiV1AccountMfaDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AccountMfaDeleteExecute(r)
}

/*
V1AccountMfaDelete Method for V1AccountMfaDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaDeleteRequest
*/
func (a *DefaultAPIService) V1AccountMfaDelete(ctx context.Context) ApiV1AccountMfaDeleteRequest {
	return ApiV1AccountMfaDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AccountMfaDeleteExecute(r ApiV1AccountMfaDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountMfaGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaGetRequest) Authorization(authorization string) ApiV1AccountMfaGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaGetRequest) Execute() (*V1AccountMfaGet200Response, *http.Response, error) {
	return r.ApiService.V1AccountMfaGetExecute(r)
}

/*
V1AccountMfaGet Method for V1AccountMfaGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaGetRequest
*/
func (a *DefaultAPIService) V1AccountMfaGet(ctx context.Context) ApiV1AccountMfaGetRequest {
	return ApiV1AccountMfaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AccountMfaGet200Response
func (a *DefaultAPIService) V1AccountMfaGetExecute(r ApiV1AccountMfaGetRequest) (*V1AccountMfaGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AccountMfaGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountMfaPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountMfaPutRequest *V1AccountMfaPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountMfaPutRequest) Authorization(authorization string) ApiV1AccountMfaPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountMfaPutRequest) V1AccountMfaPutRequest(v1AccountMfaPutRequest V1AccountMfaPutRequest) ApiV1AccountMfaPutRequest {
	r.v1AccountMfaPutRequest = &v1AccountMfaPutRequest
	return r
}

func (r ApiV1AccountMfaPutRequest) Execute() (*V1AccountMfaPut200Response, *http.Response, error) {
	return r.ApiService.V1AccountMfaPutExecute(r)
}

/*
V1AccountMfaPut Method for V1AccountMfaPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountMfaPutRequest
*/
func (a *DefaultAPIService) V1AccountMfaPut(ctx context.Context) ApiV1AccountMfaPutRequest {
	return ApiV1AccountMfaPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AccountMfaPut200Response
func (a *DefaultAPIService) V1AccountMfaPutExecute(r ApiV1AccountMfaPutRequest) (*V1AccountMfaPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AccountMfaPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountMfaPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountMfaPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountMfaPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountMfaPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountPasswordPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AccountPasswordPatchRequest *V1AccountPasswordPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AccountPasswordPatchRequest) Authorization(authorization string) ApiV1AccountPasswordPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AccountPasswordPatchRequest) V1AccountPasswordPatchRequest(v1AccountPasswordPatchRequest V1AccountPasswordPatchRequest) ApiV1AccountPasswordPatchRequest {
	r.v1AccountPasswordPatchRequest = &v1AccountPasswordPatchRequest
	return r
}

func (r ApiV1AccountPasswordPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AccountPasswordPatchExecute(r)
}

/*
V1AccountPasswordPatch Method for V1AccountPasswordPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AccountPasswordPatchRequest
*/
func (a *DefaultAPIService) V1AccountPasswordPatch(ctx context.Context) ApiV1AccountPasswordPatchRequest {
	return ApiV1AccountPasswordPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AccountPasswordPatchExecute(r ApiV1AccountPasswordPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AccountPasswordPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AccountPasswordPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1AccountPasswordPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AccountPasswordPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ActivityLogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ActivityLogsPostRequest *V1ActivityLogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ActivityLogsPostRequest) Authorization(authorization string) ApiV1ActivityLogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ActivityLogsPostRequest) V1ActivityLogsPostRequest(v1ActivityLogsPostRequest V1ActivityLogsPostRequest) ApiV1ActivityLogsPostRequest {
	r.v1ActivityLogsPostRequest = &v1ActivityLogsPostRequest
	return r
}

func (r ApiV1ActivityLogsPostRequest) Execute() (*V1ActivityLogsPost200Response, *http.Response, error) {
	return r.ApiService.V1ActivityLogsPostExecute(r)
}

/*
V1ActivityLogsPost Method for V1ActivityLogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ActivityLogsPostRequest
*/
func (a *DefaultAPIService) V1ActivityLogsPost(ctx context.Context) ApiV1ActivityLogsPostRequest {
	return ApiV1ActivityLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ActivityLogsPost200Response
func (a *DefaultAPIService) V1ActivityLogsPostExecute(r ApiV1ActivityLogsPostRequest) (*V1ActivityLogsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ActivityLogsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ActivityLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/activity/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ActivityLogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ActivityLogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ActivityLogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmHistoryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmHistoryGetRequest) Authorization(authorization string) ApiV1AlarmHistoryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmHistoryGetRequest) Execute() (*V1AlarmHistoryGet200Response, *http.Response, error) {
	return r.ApiService.V1AlarmHistoryGetExecute(r)
}

/*
V1AlarmHistoryGet Method for V1AlarmHistoryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AlarmHistoryGetRequest
*/
func (a *DefaultAPIService) V1AlarmHistoryGet(ctx context.Context) ApiV1AlarmHistoryGetRequest {
	return ApiV1AlarmHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AlarmHistoryGet200Response
func (a *DefaultAPIService) V1AlarmHistoryGetExecute(r ApiV1AlarmHistoryGetRequest) (*V1AlarmHistoryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AlarmHistoryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarm-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmMuteAlarmIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	alarmId int64
	v1AlarmMuteAlarmIdPutRequest *V1AlarmMuteAlarmIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmMuteAlarmIdPutRequest) Authorization(authorization string) ApiV1AlarmMuteAlarmIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmMuteAlarmIdPutRequest) V1AlarmMuteAlarmIdPutRequest(v1AlarmMuteAlarmIdPutRequest V1AlarmMuteAlarmIdPutRequest) ApiV1AlarmMuteAlarmIdPutRequest {
	r.v1AlarmMuteAlarmIdPutRequest = &v1AlarmMuteAlarmIdPutRequest
	return r
}

func (r ApiV1AlarmMuteAlarmIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AlarmMuteAlarmIdPutExecute(r)
}

/*
V1AlarmMuteAlarmIdPut Method for V1AlarmMuteAlarmIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alarmId Unique ID for an alarm.
 @return ApiV1AlarmMuteAlarmIdPutRequest
*/
func (a *DefaultAPIService) V1AlarmMuteAlarmIdPut(ctx context.Context, alarmId int64) ApiV1AlarmMuteAlarmIdPutRequest {
	return ApiV1AlarmMuteAlarmIdPutRequest{
		ApiService: a,
		ctx: ctx,
		alarmId: alarmId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AlarmMuteAlarmIdPutExecute(r ApiV1AlarmMuteAlarmIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmMuteAlarmIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarm-mute/{alarmId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alarmId"+"}", url.PathEscape(parameterValueToString(r.alarmId, "alarmId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AlarmMuteAlarmIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1AlarmMuteAlarmIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AlarmMuteAlarmIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmsEventsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmsEventsGetRequest) Authorization(authorization string) ApiV1AlarmsEventsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmsEventsGetRequest) Execute() (*V1AlarmsEventsGet200Response, *http.Response, error) {
	return r.ApiService.V1AlarmsEventsGetExecute(r)
}

/*
V1AlarmsEventsGet Method for V1AlarmsEventsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AlarmsEventsGetRequest
*/
func (a *DefaultAPIService) V1AlarmsEventsGet(ctx context.Context) ApiV1AlarmsEventsGetRequest {
	return ApiV1AlarmsEventsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AlarmsEventsGet200Response
func (a *DefaultAPIService) V1AlarmsEventsGetExecute(r ApiV1AlarmsEventsGetRequest) (*V1AlarmsEventsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AlarmsEventsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmsEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarms-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AlarmsListGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AlarmsListGetRequest) Authorization(authorization string) ApiV1AlarmsListGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AlarmsListGetRequest) Execute() (*V1AlarmsListGet200Response, *http.Response, error) {
	return r.ApiService.V1AlarmsListGetExecute(r)
}

/*
V1AlarmsListGet Method for V1AlarmsListGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AlarmsListGetRequest
*/
func (a *DefaultAPIService) V1AlarmsListGet(ctx context.Context) ApiV1AlarmsListGetRequest {
	return ApiV1AlarmsListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AlarmsListGet200Response
func (a *DefaultAPIService) V1AlarmsListGetExecute(r ApiV1AlarmsListGetRequest) (*V1AlarmsListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AlarmsListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AlarmsListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/alarms-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsAppSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AppsAppSummaryPostRequest *V1AppsAppSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsAppSummaryPostRequest) Authorization(authorization string) ApiV1AppsAppSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsAppSummaryPostRequest) V1AppsAppSummaryPostRequest(v1AppsAppSummaryPostRequest V1AppsAppSummaryPostRequest) ApiV1AppsAppSummaryPostRequest {
	r.v1AppsAppSummaryPostRequest = &v1AppsAppSummaryPostRequest
	return r
}

func (r ApiV1AppsAppSummaryPostRequest) Execute() (*V1AppsAppSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1AppsAppSummaryPostExecute(r)
}

/*
V1AppsAppSummaryPost Method for V1AppsAppSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AppsAppSummaryPostRequest
*/
func (a *DefaultAPIService) V1AppsAppSummaryPost(ctx context.Context) ApiV1AppsAppSummaryPostRequest {
	return ApiV1AppsAppSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AppsAppSummaryPost200Response
func (a *DefaultAPIService) V1AppsAppSummaryPostExecute(r ApiV1AppsAppSummaryPostRequest) (*V1AppsAppSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsAppSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsAppSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/app-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsAppSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsAppSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsAppSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsBandwidthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AppsBandwidthPostRequest *V1AppsBandwidthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsBandwidthPostRequest) Authorization(authorization string) ApiV1AppsBandwidthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsBandwidthPostRequest) V1AppsBandwidthPostRequest(v1AppsBandwidthPostRequest V1AppsBandwidthPostRequest) ApiV1AppsBandwidthPostRequest {
	r.v1AppsBandwidthPostRequest = &v1AppsBandwidthPostRequest
	return r
}

func (r ApiV1AppsBandwidthPostRequest) Execute() (*V1AppsBandwidthPost200Response, *http.Response, error) {
	return r.ApiService.V1AppsBandwidthPostExecute(r)
}

/*
V1AppsBandwidthPost Method for V1AppsBandwidthPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AppsBandwidthPostRequest
*/
func (a *DefaultAPIService) V1AppsBandwidthPost(ctx context.Context) ApiV1AppsBandwidthPostRequest {
	return ApiV1AppsBandwidthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AppsBandwidthPost200Response
func (a *DefaultAPIService) V1AppsBandwidthPostExecute(r ApiV1AppsBandwidthPostRequest) (*V1AppsBandwidthPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsBandwidthPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsBandwidthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsBandwidthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsBandwidthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsBandwidthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsDeviceDeviceIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1AppsDeviceDeviceIdTopPostRequest *V1AppsDeviceDeviceIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsDeviceDeviceIdTopPostRequest) Authorization(authorization string) ApiV1AppsDeviceDeviceIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsDeviceDeviceIdTopPostRequest) V1AppsDeviceDeviceIdTopPostRequest(v1AppsDeviceDeviceIdTopPostRequest V1AppsDeviceDeviceIdTopPostRequest) ApiV1AppsDeviceDeviceIdTopPostRequest {
	r.v1AppsDeviceDeviceIdTopPostRequest = &v1AppsDeviceDeviceIdTopPostRequest
	return r
}

func (r ApiV1AppsDeviceDeviceIdTopPostRequest) Execute() (*V1AppsDeviceDeviceIdTopPost200Response, *http.Response, error) {
	return r.ApiService.V1AppsDeviceDeviceIdTopPostExecute(r)
}

/*
V1AppsDeviceDeviceIdTopPost Method for V1AppsDeviceDeviceIdTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1AppsDeviceDeviceIdTopPostRequest
*/
func (a *DefaultAPIService) V1AppsDeviceDeviceIdTopPost(ctx context.Context, deviceId int64) ApiV1AppsDeviceDeviceIdTopPostRequest {
	return ApiV1AppsDeviceDeviceIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1AppsDeviceDeviceIdTopPost200Response
func (a *DefaultAPIService) V1AppsDeviceDeviceIdTopPostExecute(r ApiV1AppsDeviceDeviceIdTopPostRequest) (*V1AppsDeviceDeviceIdTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsDeviceDeviceIdTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsDeviceDeviceIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/device/{deviceId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsDeviceDeviceIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsDeviceDeviceIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsDeviceDeviceIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsSiteSiteIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v1AppsDeviceDeviceIdTopPostRequest *V1AppsDeviceDeviceIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsSiteSiteIdTopPostRequest) Authorization(authorization string) ApiV1AppsSiteSiteIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsSiteSiteIdTopPostRequest) V1AppsDeviceDeviceIdTopPostRequest(v1AppsDeviceDeviceIdTopPostRequest V1AppsDeviceDeviceIdTopPostRequest) ApiV1AppsSiteSiteIdTopPostRequest {
	r.v1AppsDeviceDeviceIdTopPostRequest = &v1AppsDeviceDeviceIdTopPostRequest
	return r
}

func (r ApiV1AppsSiteSiteIdTopPostRequest) Execute() (*V1AppsDeviceDeviceIdTopPost200Response, *http.Response, error) {
	return r.ApiService.V1AppsSiteSiteIdTopPostExecute(r)
}

/*
V1AppsSiteSiteIdTopPost Method for V1AppsSiteSiteIdTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1AppsSiteSiteIdTopPostRequest
*/
func (a *DefaultAPIService) V1AppsSiteSiteIdTopPost(ctx context.Context, siteId int64) ApiV1AppsSiteSiteIdTopPostRequest {
	return ApiV1AppsSiteSiteIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1AppsDeviceDeviceIdTopPost200Response
func (a *DefaultAPIService) V1AppsSiteSiteIdTopPostExecute(r ApiV1AppsSiteSiteIdTopPostRequest) (*V1AppsDeviceDeviceIdTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsDeviceDeviceIdTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsSiteSiteIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/site/{siteId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsDeviceDeviceIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsDeviceDeviceIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsDeviceDeviceIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AppsVisualizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AppsVisualizationPostRequest *V1AppsVisualizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AppsVisualizationPostRequest) Authorization(authorization string) ApiV1AppsVisualizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AppsVisualizationPostRequest) V1AppsVisualizationPostRequest(v1AppsVisualizationPostRequest V1AppsVisualizationPostRequest) ApiV1AppsVisualizationPostRequest {
	r.v1AppsVisualizationPostRequest = &v1AppsVisualizationPostRequest
	return r
}

func (r ApiV1AppsVisualizationPostRequest) Execute() (*V1AppsVisualizationPost200Response, *http.Response, error) {
	return r.ApiService.V1AppsVisualizationPostExecute(r)
}

/*
V1AppsVisualizationPost Method for V1AppsVisualizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AppsVisualizationPostRequest
*/
func (a *DefaultAPIService) V1AppsVisualizationPost(ctx context.Context) ApiV1AppsVisualizationPostRequest {
	return ApiV1AppsVisualizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AppsVisualizationPost200Response
func (a *DefaultAPIService) V1AppsVisualizationPostExecute(r ApiV1AppsVisualizationPostRequest) (*V1AppsVisualizationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AppsVisualizationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AppsVisualizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/visualization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AppsVisualizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AppsVisualizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AppsVisualizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuditLogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuditLogsPostRequest *V1AuditLogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuditLogsPostRequest) Authorization(authorization string) ApiV1AuditLogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuditLogsPostRequest) V1AuditLogsPostRequest(v1AuditLogsPostRequest V1AuditLogsPostRequest) ApiV1AuditLogsPostRequest {
	r.v1AuditLogsPostRequest = &v1AuditLogsPostRequest
	return r
}

func (r ApiV1AuditLogsPostRequest) Execute() (*V1AuditLogsPost200Response, *http.Response, error) {
	return r.ApiService.V1AuditLogsPostExecute(r)
}

/*
V1AuditLogsPost Method for V1AuditLogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuditLogsPostRequest
*/
func (a *DefaultAPIService) V1AuditLogsPost(ctx context.Context) ApiV1AuditLogsPostRequest {
	return ApiV1AuditLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuditLogsPost200Response
func (a *DefaultAPIService) V1AuditLogsPostExecute(r ApiV1AuditLogsPostRequest) (*V1AuditLogsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuditLogsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuditLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/audit/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuditLogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuditLogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuditLogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthDeleteRequest) Authorization(authorization string) ApiV1AuthDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthDeleteRequest) Execute() (*V1AuthPut204Response, *http.Response, error) {
	return r.ApiService.V1AuthDeleteExecute(r)
}

/*
V1AuthDelete Method for V1AuthDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthDeleteRequest
*/
func (a *DefaultAPIService) V1AuthDelete(ctx context.Context) ApiV1AuthDeleteRequest {
	return ApiV1AuthDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthPut204Response
func (a *DefaultAPIService) V1AuthDeleteExecute(r ApiV1AuthDeleteRequest) (*V1AuthPut204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthPut204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthGetRequest) Authorization(authorization string) ApiV1AuthGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthGetRequest) Execute() (*V1AuthGet200Response, *http.Response, error) {
	return r.ApiService.V1AuthGetExecute(r)
}

/*
V1AuthGet Method for V1AuthGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthGetRequest
*/
func (a *DefaultAPIService) V1AuthGet(ctx context.Context) ApiV1AuthGetRequest {
	return ApiV1AuthGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthGet200Response
func (a *DefaultAPIService) V1AuthGetExecute(r ApiV1AuthGetRequest) (*V1AuthGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthLoginPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1AuthLoginPostRequest *V1AuthLoginPostRequest
}

func (r ApiV1AuthLoginPostRequest) V1AuthLoginPostRequest(v1AuthLoginPostRequest V1AuthLoginPostRequest) ApiV1AuthLoginPostRequest {
	r.v1AuthLoginPostRequest = &v1AuthLoginPostRequest
	return r
}

func (r ApiV1AuthLoginPostRequest) Execute() (*V1AuthLoginPost200Response, *http.Response, error) {
	return r.ApiService.V1AuthLoginPostExecute(r)
}

/*
V1AuthLoginPost Authenticate user and return token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginPostRequest
*/
func (a *DefaultAPIService) V1AuthLoginPost(ctx context.Context) ApiV1AuthLoginPostRequest {
	return ApiV1AuthLoginPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPost200Response
func (a *DefaultAPIService) V1AuthLoginPostExecute(r ApiV1AuthLoginPostRequest) (*V1AuthLoginPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1AuthLoginPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1AuthLoginPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AuthLoginPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthLoginPreGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiV1AuthLoginPreGetRequest) Execute() (*V1AuthLoginPreGet200Response, *http.Response, error) {
	return r.ApiService.V1AuthLoginPreGetExecute(r)
}

/*
V1AuthLoginPreGet Pre-login endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthLoginPreGetRequest
*/
func (a *DefaultAPIService) V1AuthLoginPreGet(ctx context.Context) ApiV1AuthLoginPreGetRequest {
	return ApiV1AuthLoginPreGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthLoginPreGet200Response
func (a *DefaultAPIService) V1AuthLoginPreGetExecute(r ApiV1AuthLoginPreGetRequest) (*V1AuthLoginPreGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthLoginPreGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthLoginPreGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/login/pre"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthMfaDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthMfaDeleteRequest) Authorization(authorization string) ApiV1AuthMfaDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthMfaDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AuthMfaDeleteExecute(r)
}

/*
V1AuthMfaDelete Method for V1AuthMfaDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaDeleteRequest
*/
func (a *DefaultAPIService) V1AuthMfaDelete(ctx context.Context) ApiV1AuthMfaDeleteRequest {
	return ApiV1AuthMfaDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AuthMfaDeleteExecute(r ApiV1AuthMfaDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthMfaPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthMfaPatchRequest) Authorization(authorization string) ApiV1AuthMfaPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthMfaPatchRequest) Body(body map[string]interface{}) ApiV1AuthMfaPatchRequest {
	r.body = &body
	return r
}

func (r ApiV1AuthMfaPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AuthMfaPatchExecute(r)
}

/*
V1AuthMfaPatch Method for V1AuthMfaPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthMfaPatchRequest
*/
func (a *DefaultAPIService) V1AuthMfaPatch(ctx context.Context) ApiV1AuthMfaPatchRequest {
	return ApiV1AuthMfaPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1AuthMfaPatchExecute(r ApiV1AuthMfaPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthMfaPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/mfa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuthGet200Response *V1AuthGet200Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthPatchRequest) Authorization(authorization string) ApiV1AuthPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthPatchRequest) V1AuthGet200Response(v1AuthGet200Response V1AuthGet200Response) ApiV1AuthPatchRequest {
	r.v1AuthGet200Response = &v1AuthGet200Response
	return r
}

func (r ApiV1AuthPatchRequest) Execute() (*V1AuthPut204Response, *http.Response, error) {
	return r.ApiService.V1AuthPatchExecute(r)
}

/*
V1AuthPatch Method for V1AuthPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthPatchRequest
*/
func (a *DefaultAPIService) V1AuthPatch(ctx context.Context) ApiV1AuthPatchRequest {
	return ApiV1AuthPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthPut204Response
func (a *DefaultAPIService) V1AuthPatchExecute(r ApiV1AuthPatchRequest) (*V1AuthPut204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthPut204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuthGet200Response == nil {
		return localVarReturnValue, nil, reportError("v1AuthGet200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuthGet200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1AuthGet200Response *V1AuthGet200Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1AuthPutRequest) Authorization(authorization string) ApiV1AuthPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1AuthPutRequest) V1AuthGet200Response(v1AuthGet200Response V1AuthGet200Response) ApiV1AuthPutRequest {
	r.v1AuthGet200Response = &v1AuthGet200Response
	return r
}

func (r ApiV1AuthPutRequest) Execute() (*V1AuthPut204Response, *http.Response, error) {
	return r.ApiService.V1AuthPutExecute(r)
}

/*
V1AuthPut Method for V1AuthPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthPutRequest
*/
func (a *DefaultAPIService) V1AuthPut(ctx context.Context) ApiV1AuthPutRequest {
	return ApiV1AuthPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthPut204Response
func (a *DefaultAPIService) V1AuthPutExecute(r ApiV1AuthPutRequest) (*V1AuthPut204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthPut204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1AuthGet200Response == nil {
		return localVarReturnValue, nil, reportError("v1AuthGet200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1AuthGet200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AuthUserGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiV1AuthUserGetRequest) Execute() (*V1AuthUserGet200Response, *http.Response, error) {
	return r.ApiService.V1AuthUserGetExecute(r)
}

/*
V1AuthUserGet Get authenticated user information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1AuthUserGetRequest
*/
func (a *DefaultAPIService) V1AuthUserGet(ctx context.Context) ApiV1AuthUserGetRequest {
	return ApiV1AuthUserGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthUserGet200Response
func (a *DefaultAPIService) V1AuthUserGetExecute(r ApiV1AuthUserGetRequest) (*V1AuthUserGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthUserGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1AuthUserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/auth/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthDeviceDeviceIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthDeviceDeviceIdPostRequest) Authorization(authorization string) ApiV1BackboneHealthDeviceDeviceIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthDeviceDeviceIdPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV1BackboneHealthDeviceDeviceIdPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV1BackboneHealthDeviceDeviceIdPostRequest) Execute() (*V1BackboneHealthDeviceDeviceIdPost200Response, *http.Response, error) {
	return r.ApiService.V1BackboneHealthDeviceDeviceIdPostExecute(r)
}

/*
V1BackboneHealthDeviceDeviceIdPost Method for V1BackboneHealthDeviceDeviceIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1BackboneHealthDeviceDeviceIdPostRequest
*/
func (a *DefaultAPIService) V1BackboneHealthDeviceDeviceIdPost(ctx context.Context, deviceId int64) ApiV1BackboneHealthDeviceDeviceIdPostRequest {
	return ApiV1BackboneHealthDeviceDeviceIdPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1BackboneHealthDeviceDeviceIdPost200Response
func (a *DefaultAPIService) V1BackboneHealthDeviceDeviceIdPostExecute(r ApiV1BackboneHealthDeviceDeviceIdPostRequest) (*V1BackboneHealthDeviceDeviceIdPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthDeviceDeviceIdPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthDeviceDeviceIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/device/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthEtWanMatrixGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthEtWanMatrixGetRequest) Authorization(authorization string) ApiV1BackboneHealthEtWanMatrixGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthEtWanMatrixGetRequest) Execute() (*V1BackboneHealthEtWanMatrixGet200Response, *http.Response, error) {
	return r.ApiService.V1BackboneHealthEtWanMatrixGetExecute(r)
}

/*
V1BackboneHealthEtWanMatrixGet Method for V1BackboneHealthEtWanMatrixGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthEtWanMatrixGetRequest
*/
func (a *DefaultAPIService) V1BackboneHealthEtWanMatrixGet(ctx context.Context) ApiV1BackboneHealthEtWanMatrixGetRequest {
	return ApiV1BackboneHealthEtWanMatrixGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthEtWanMatrixGet200Response
func (a *DefaultAPIService) V1BackboneHealthEtWanMatrixGetExecute(r ApiV1BackboneHealthEtWanMatrixGetRequest) (*V1BackboneHealthEtWanMatrixGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthEtWanMatrixGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthEtWanMatrixGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/et-wan-matrix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthEtetSlaMatrixGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthEtetSlaMatrixGetRequest) Authorization(authorization string) ApiV1BackboneHealthEtetSlaMatrixGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthEtetSlaMatrixGetRequest) Execute() (*V1BackboneHealthEtetSlaMatrixGet200Response, *http.Response, error) {
	return r.ApiService.V1BackboneHealthEtetSlaMatrixGetExecute(r)
}

/*
V1BackboneHealthEtetSlaMatrixGet Method for V1BackboneHealthEtetSlaMatrixGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthEtetSlaMatrixGetRequest
*/
func (a *DefaultAPIService) V1BackboneHealthEtetSlaMatrixGet(ctx context.Context) ApiV1BackboneHealthEtetSlaMatrixGetRequest {
	return ApiV1BackboneHealthEtetSlaMatrixGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthEtetSlaMatrixGet200Response
func (a *DefaultAPIService) V1BackboneHealthEtetSlaMatrixGetExecute(r ApiV1BackboneHealthEtetSlaMatrixGetRequest) (*V1BackboneHealthEtetSlaMatrixGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthEtetSlaMatrixGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthEtetSlaMatrixGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/etet-sla-matrix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthFilterGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthFilterGetRequest) Authorization(authorization string) ApiV1BackboneHealthFilterGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthFilterGetRequest) Execute() (*V1BackboneHealthFilterGet200Response, *http.Response, error) {
	return r.ApiService.V1BackboneHealthFilterGetExecute(r)
}

/*
V1BackboneHealthFilterGet Method for V1BackboneHealthFilterGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthFilterGetRequest
*/
func (a *DefaultAPIService) V1BackboneHealthFilterGet(ctx context.Context) ApiV1BackboneHealthFilterGetRequest {
	return ApiV1BackboneHealthFilterGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthFilterGet200Response
func (a *DefaultAPIService) V1BackboneHealthFilterGetExecute(r ApiV1BackboneHealthFilterGetRequest) (*V1BackboneHealthFilterGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthFilterGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthFilterGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BackboneHealthOverviewPostRequest *V1BackboneHealthOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthOverviewPostRequest) Authorization(authorization string) ApiV1BackboneHealthOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthOverviewPostRequest) V1BackboneHealthOverviewPostRequest(v1BackboneHealthOverviewPostRequest V1BackboneHealthOverviewPostRequest) ApiV1BackboneHealthOverviewPostRequest {
	r.v1BackboneHealthOverviewPostRequest = &v1BackboneHealthOverviewPostRequest
	return r
}

func (r ApiV1BackboneHealthOverviewPostRequest) Execute() (*V1BackboneHealthOverviewPost200Response, *http.Response, error) {
	return r.ApiService.V1BackboneHealthOverviewPostExecute(r)
}

/*
V1BackboneHealthOverviewPost Method for V1BackboneHealthOverviewPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthOverviewPostRequest
*/
func (a *DefaultAPIService) V1BackboneHealthOverviewPost(ctx context.Context) ApiV1BackboneHealthOverviewPostRequest {
	return ApiV1BackboneHealthOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthOverviewPost200Response
func (a *DefaultAPIService) V1BackboneHealthOverviewPostExecute(r ApiV1BackboneHealthOverviewPostRequest) (*V1BackboneHealthOverviewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthOverviewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BackboneHealthOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BackboneHealthOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BackboneHealthOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BackboneHealthTopDevicesByAlertsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BackboneHealthTopDevicesByAlertsPostRequest *V1BackboneHealthTopDevicesByAlertsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) Authorization(authorization string) ApiV1BackboneHealthTopDevicesByAlertsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) V1BackboneHealthTopDevicesByAlertsPostRequest(v1BackboneHealthTopDevicesByAlertsPostRequest V1BackboneHealthTopDevicesByAlertsPostRequest) ApiV1BackboneHealthTopDevicesByAlertsPostRequest {
	r.v1BackboneHealthTopDevicesByAlertsPostRequest = &v1BackboneHealthTopDevicesByAlertsPostRequest
	return r
}

func (r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) Execute() (*V1BackboneHealthTopDevicesByAlertsPost200Response, *http.Response, error) {
	return r.ApiService.V1BackboneHealthTopDevicesByAlertsPostExecute(r)
}

/*
V1BackboneHealthTopDevicesByAlertsPost Method for V1BackboneHealthTopDevicesByAlertsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BackboneHealthTopDevicesByAlertsPostRequest
*/
func (a *DefaultAPIService) V1BackboneHealthTopDevicesByAlertsPost(ctx context.Context) ApiV1BackboneHealthTopDevicesByAlertsPostRequest {
	return ApiV1BackboneHealthTopDevicesByAlertsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthTopDevicesByAlertsPost200Response
func (a *DefaultAPIService) V1BackboneHealthTopDevicesByAlertsPostExecute(r ApiV1BackboneHealthTopDevicesByAlertsPostRequest) (*V1BackboneHealthTopDevicesByAlertsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthTopDevicesByAlertsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BackboneHealthTopDevicesByAlertsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/backbone-health/top-devices-by-alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BackboneHealthTopDevicesByAlertsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BackboneHealthTopDevicesByAlertsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BackboneHealthTopDevicesByAlertsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerEnterpriseCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerEnterpriseCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerEnterpriseCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerEnterpriseCsvPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV1BwtrackerEnterpriseCsvPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV1BwtrackerEnterpriseCsvPostRequest) Execute() (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerEnterpriseCsvPostExecute(r)
}

/*
V1BwtrackerEnterpriseCsvPost Method for V1BwtrackerEnterpriseCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerEnterpriseCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerEnterpriseCsvPost(ctx context.Context) ApiV1BwtrackerEnterpriseCsvPostRequest {
	return ApiV1BwtrackerEnterpriseCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseCsvPost200Response
func (a *DefaultAPIService) V1BwtrackerEnterpriseCsvPostExecute(r ApiV1BwtrackerEnterpriseCsvPostRequest) (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseCsvPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerEnterpriseCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/enterprise/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerEnterpriseDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerEnterpriseDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerEnterpriseDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerEnterpriseDetailsPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV1BwtrackerEnterpriseDetailsPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV1BwtrackerEnterpriseDetailsPostRequest) Execute() (*V1BwtrackerEnterpriseDetailsPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerEnterpriseDetailsPostExecute(r)
}

/*
V1BwtrackerEnterpriseDetailsPost Method for V1BwtrackerEnterpriseDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerEnterpriseDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerEnterpriseDetailsPost(ctx context.Context) ApiV1BwtrackerEnterpriseDetailsPostRequest {
	return ApiV1BwtrackerEnterpriseDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseDetailsPost200Response
func (a *DefaultAPIService) V1BwtrackerEnterpriseDetailsPostExecute(r ApiV1BwtrackerEnterpriseDetailsPostRequest) (*V1BwtrackerEnterpriseDetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseDetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerEnterpriseDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/enterprise/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerEnterpriseSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerEnterpriseSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerEnterpriseSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerEnterpriseSummaryPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV1BwtrackerEnterpriseSummaryPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV1BwtrackerEnterpriseSummaryPostRequest) Execute() (*V1BwtrackerEnterpriseSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerEnterpriseSummaryPostExecute(r)
}

/*
V1BwtrackerEnterpriseSummaryPost Method for V1BwtrackerEnterpriseSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerEnterpriseSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerEnterpriseSummaryPost(ctx context.Context) ApiV1BwtrackerEnterpriseSummaryPostRequest {
	return ApiV1BwtrackerEnterpriseSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseSummaryPost200Response
func (a *DefaultAPIService) V1BwtrackerEnterpriseSummaryPostExecute(r ApiV1BwtrackerEnterpriseSummaryPostRequest) (*V1BwtrackerEnterpriseSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerEnterpriseSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/enterprise/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionCloudChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionCloudChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionCloudChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionCloudChartPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionCloudChartPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionCloudChartPostRequest) Execute() (*V1BwtrackerRegionCloudChartPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionCloudChartPostExecute(r)
}

/*
V1BwtrackerRegionCloudChartPost Method for V1BwtrackerRegionCloudChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionCloudChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionCloudChartPost(ctx context.Context) ApiV1BwtrackerRegionCloudChartPostRequest {
	return ApiV1BwtrackerRegionCloudChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudChartPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionCloudChartPostExecute(r ApiV1BwtrackerRegionCloudChartPostRequest) (*V1BwtrackerRegionCloudChartPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudChartPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionCloudChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/cloud/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionCloudCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionCloudCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionCloudCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionCloudCsvPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionCloudCsvPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionCloudCsvPostRequest) Execute() (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionCloudCsvPostExecute(r)
}

/*
V1BwtrackerRegionCloudCsvPost Method for V1BwtrackerRegionCloudCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionCloudCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionCloudCsvPost(ctx context.Context) ApiV1BwtrackerRegionCloudCsvPostRequest {
	return ApiV1BwtrackerRegionCloudCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseCsvPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionCloudCsvPostExecute(r ApiV1BwtrackerRegionCloudCsvPostRequest) (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseCsvPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionCloudCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/cloud/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionCloudSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionCloudSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionCloudSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionCloudSummaryPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionCloudSummaryPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionCloudSummaryPostRequest) Execute() (*V1BwtrackerRegionCloudSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionCloudSummaryPostExecute(r)
}

/*
V1BwtrackerRegionCloudSummaryPost Method for V1BwtrackerRegionCloudSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionCloudSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionCloudSummaryPost(ctx context.Context) ApiV1BwtrackerRegionCloudSummaryPostRequest {
	return ApiV1BwtrackerRegionCloudSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudSummaryPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionCloudSummaryPostExecute(r ApiV1BwtrackerRegionCloudSummaryPostRequest) (*V1BwtrackerRegionCloudSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionCloudSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/cloud/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeChartPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionEdgeChartPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeChartPostRequest) Execute() (*V1BwtrackerRegionCloudChartPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeChartPostExecute(r)
}

/*
V1BwtrackerRegionEdgeChartPost Method for V1BwtrackerRegionEdgeChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeChartPost(ctx context.Context) ApiV1BwtrackerRegionEdgeChartPostRequest {
	return ApiV1BwtrackerRegionEdgeChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudChartPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionEdgeChartPostExecute(r ApiV1BwtrackerRegionEdgeChartPostRequest) (*V1BwtrackerRegionCloudChartPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudChartPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeCsvPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionEdgeCsvPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeCsvPostRequest) Execute() (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeCsvPostExecute(r)
}

/*
V1BwtrackerRegionEdgeCsvPost Method for V1BwtrackerRegionEdgeCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeCsvPost(ctx context.Context) ApiV1BwtrackerRegionEdgeCsvPostRequest {
	return ApiV1BwtrackerRegionEdgeCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseCsvPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionEdgeCsvPostExecute(r ApiV1BwtrackerRegionEdgeCsvPostRequest) (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseCsvPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeDetailsPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionEdgeDetailsPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeDetailsPostRequest) Execute() (*V1BwtrackerRegionEdgeDetailsPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeDetailsPostExecute(r)
}

/*
V1BwtrackerRegionEdgeDetailsPost Method for V1BwtrackerRegionEdgeDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeDetailsPost(ctx context.Context) ApiV1BwtrackerRegionEdgeDetailsPostRequest {
	return ApiV1BwtrackerRegionEdgeDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionEdgeDetailsPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionEdgeDetailsPostExecute(r ApiV1BwtrackerRegionEdgeDetailsPostRequest) (*V1BwtrackerRegionEdgeDetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionEdgeDetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionEdgeSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionCloudChartPostRequest *V1BwtrackerRegionCloudChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionEdgeSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionEdgeSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionEdgeSummaryPostRequest) V1BwtrackerRegionCloudChartPostRequest(v1BwtrackerRegionCloudChartPostRequest V1BwtrackerRegionCloudChartPostRequest) ApiV1BwtrackerRegionEdgeSummaryPostRequest {
	r.v1BwtrackerRegionCloudChartPostRequest = &v1BwtrackerRegionCloudChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionEdgeSummaryPostRequest) Execute() (*V1BwtrackerRegionEdgeSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionEdgeSummaryPostExecute(r)
}

/*
V1BwtrackerRegionEdgeSummaryPost Method for V1BwtrackerRegionEdgeSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionEdgeSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionEdgeSummaryPost(ctx context.Context) ApiV1BwtrackerRegionEdgeSummaryPostRequest {
	return ApiV1BwtrackerRegionEdgeSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionEdgeSummaryPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionEdgeSummaryPostExecute(r ApiV1BwtrackerRegionEdgeSummaryPostRequest) (*V1BwtrackerRegionEdgeSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionEdgeSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionEdgeSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/edge/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionCloudChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionCloudChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionCloudChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteChartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteChartPostRequest *V1BwtrackerRegionSiteChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteChartPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteChartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteChartPostRequest) V1BwtrackerRegionSiteChartPostRequest(v1BwtrackerRegionSiteChartPostRequest V1BwtrackerRegionSiteChartPostRequest) ApiV1BwtrackerRegionSiteChartPostRequest {
	r.v1BwtrackerRegionSiteChartPostRequest = &v1BwtrackerRegionSiteChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteChartPostRequest) Execute() (*V1BwtrackerRegionCloudChartPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteChartPostExecute(r)
}

/*
V1BwtrackerRegionSiteChartPost Method for V1BwtrackerRegionSiteChartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteChartPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteChartPost(ctx context.Context) ApiV1BwtrackerRegionSiteChartPostRequest {
	return ApiV1BwtrackerRegionSiteChartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionCloudChartPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionSiteChartPostExecute(r ApiV1BwtrackerRegionSiteChartPostRequest) (*V1BwtrackerRegionCloudChartPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionCloudChartPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteChartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/chart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteChartPostRequest *V1BwtrackerRegionSiteChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteDetailsPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteDetailsPostRequest) V1BwtrackerRegionSiteChartPostRequest(v1BwtrackerRegionSiteChartPostRequest V1BwtrackerRegionSiteChartPostRequest) ApiV1BwtrackerRegionSiteDetailsPostRequest {
	r.v1BwtrackerRegionSiteChartPostRequest = &v1BwtrackerRegionSiteChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteDetailsPostRequest) Execute() (*V1BwtrackerRegionSiteDetailsPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteDetailsPostExecute(r)
}

/*
V1BwtrackerRegionSiteDetailsPost Method for V1BwtrackerRegionSiteDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteDetailsPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteDetailsPost(ctx context.Context) ApiV1BwtrackerRegionSiteDetailsPostRequest {
	return ApiV1BwtrackerRegionSiteDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteDetailsPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionSiteDetailsPostExecute(r ApiV1BwtrackerRegionSiteDetailsPostRequest) (*V1BwtrackerRegionSiteDetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteDetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerRegionSiteSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteChartPostRequest *V1BwtrackerRegionSiteChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerRegionSiteSummaryPostRequest) Authorization(authorization string) ApiV1BwtrackerRegionSiteSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerRegionSiteSummaryPostRequest) V1BwtrackerRegionSiteChartPostRequest(v1BwtrackerRegionSiteChartPostRequest V1BwtrackerRegionSiteChartPostRequest) ApiV1BwtrackerRegionSiteSummaryPostRequest {
	r.v1BwtrackerRegionSiteChartPostRequest = &v1BwtrackerRegionSiteChartPostRequest
	return r
}

func (r ApiV1BwtrackerRegionSiteSummaryPostRequest) Execute() (*V1BwtrackerRegionSiteSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerRegionSiteSummaryPostExecute(r)
}

/*
V1BwtrackerRegionSiteSummaryPost Method for V1BwtrackerRegionSiteSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerRegionSiteSummaryPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerRegionSiteSummaryPost(ctx context.Context) ApiV1BwtrackerRegionSiteSummaryPostRequest {
	return ApiV1BwtrackerRegionSiteSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerRegionSiteSummaryPost200Response
func (a *DefaultAPIService) V1BwtrackerRegionSiteSummaryPostExecute(r ApiV1BwtrackerRegionSiteSummaryPostRequest) (*V1BwtrackerRegionSiteSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerRegionSiteSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerRegionSiteSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/region/site/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1BwtrackerSiteCsvPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BwtrackerRegionSiteChartPostRequest *V1BwtrackerRegionSiteChartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1BwtrackerSiteCsvPostRequest) Authorization(authorization string) ApiV1BwtrackerSiteCsvPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1BwtrackerSiteCsvPostRequest) V1BwtrackerRegionSiteChartPostRequest(v1BwtrackerRegionSiteChartPostRequest V1BwtrackerRegionSiteChartPostRequest) ApiV1BwtrackerSiteCsvPostRequest {
	r.v1BwtrackerRegionSiteChartPostRequest = &v1BwtrackerRegionSiteChartPostRequest
	return r
}

func (r ApiV1BwtrackerSiteCsvPostRequest) Execute() (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	return r.ApiService.V1BwtrackerSiteCsvPostExecute(r)
}

/*
V1BwtrackerSiteCsvPost Method for V1BwtrackerSiteCsvPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1BwtrackerSiteCsvPostRequest
*/
func (a *DefaultAPIService) V1BwtrackerSiteCsvPost(ctx context.Context) ApiV1BwtrackerSiteCsvPostRequest {
	return ApiV1BwtrackerSiteCsvPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BwtrackerEnterpriseCsvPost200Response
func (a *DefaultAPIService) V1BwtrackerSiteCsvPostExecute(r ApiV1BwtrackerSiteCsvPostRequest) (*V1BwtrackerEnterpriseCsvPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BwtrackerEnterpriseCsvPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1BwtrackerSiteCsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/bwtracker/site/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BwtrackerRegionSiteChartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BwtrackerRegionSiteChartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BwtrackerRegionSiteChartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	bucketAppName string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest) Execute() (*V1DataAssuranceAssurancesApplicationsBucketAppNameGet200Response, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesApplicationsBucketAppNameGetExecute(r)
}

/*
V1DataAssuranceAssurancesApplicationsBucketAppNameGet Method for V1DataAssuranceAssurancesApplicationsBucketAppNameGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketAppName 
 @return ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesApplicationsBucketAppNameGet(ctx context.Context, bucketAppName string) ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest {
	return ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest{
		ApiService: a,
		ctx: ctx,
		bucketAppName: bucketAppName,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesApplicationsBucketAppNameGet200Response
func (a *DefaultAPIService) V1DataAssuranceAssurancesApplicationsBucketAppNameGetExecute(r ApiV1DataAssuranceAssurancesApplicationsBucketAppNameGetRequest) (*V1DataAssuranceAssurancesApplicationsBucketAppNameGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesApplicationsBucketAppNameGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesApplicationsBucketAppNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/applications/{bucketAppName}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucketAppName"+"}", url.PathEscape(parameterValueToString(r.bucketAppName, "bucketAppName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalGetRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalGetRequest) Execute() (*V1DataAssuranceAssurancesGlobalGet200Response, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalGetExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalGet Method for V1DataAssuranceAssurancesGlobalGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DataAssuranceAssurancesGlobalGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalGet(ctx context.Context) ApiV1DataAssuranceAssurancesGlobalGetRequest {
	return ApiV1DataAssuranceAssurancesGlobalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalGet200Response
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalGetExecute(r ApiV1DataAssuranceAssurancesGlobalGetRequest) (*V1DataAssuranceAssurancesGlobalGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalIdDeleteExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalIdDelete Method for V1DataAssuranceAssurancesGlobalIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdDelete(ctx context.Context, id int64) ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest {
	return ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdDeleteExecute(r ApiV1DataAssuranceAssurancesGlobalIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalIdGetRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdGetRequest) Execute() (*V1DataAssuranceAssurancesGlobalPostRequest, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalIdGetExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalIdGet Method for V1DataAssuranceAssurancesGlobalIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1DataAssuranceAssurancesGlobalIdGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdGet(ctx context.Context, id int64) ApiV1DataAssuranceAssurancesGlobalIdGetRequest {
	return ApiV1DataAssuranceAssurancesGlobalIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalPostRequest
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdGetExecute(r ApiV1DataAssuranceAssurancesGlobalIdGetRequest) (*V1DataAssuranceAssurancesGlobalPostRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalPostRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1DataAssuranceAssurancesGlobalIdPutRequest *V1DataAssuranceAssurancesGlobalIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) V1DataAssuranceAssurancesGlobalIdPutRequest(v1DataAssuranceAssurancesGlobalIdPutRequest V1DataAssuranceAssurancesGlobalIdPutRequest) ApiV1DataAssuranceAssurancesGlobalIdPutRequest {
	r.v1DataAssuranceAssurancesGlobalIdPutRequest = &v1DataAssuranceAssurancesGlobalIdPutRequest
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) Execute() (*V1DataAssuranceAssurancesGlobalIdPut200Response, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalIdPutExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalIdPut Method for V1DataAssuranceAssurancesGlobalIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1DataAssuranceAssurancesGlobalIdPutRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdPut(ctx context.Context, id int64) ApiV1DataAssuranceAssurancesGlobalIdPutRequest {
	return ApiV1DataAssuranceAssurancesGlobalIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalIdPut200Response
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalIdPutExecute(r ApiV1DataAssuranceAssurancesGlobalIdPutRequest) (*V1DataAssuranceAssurancesGlobalIdPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalIdPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DataAssuranceAssurancesGlobalIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DataAssuranceAssurancesGlobalIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DataAssuranceAssurancesGlobalIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceAssurancesGlobalPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DataAssuranceAssurancesGlobalPostRequest *V1DataAssuranceAssurancesGlobalPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceAssurancesGlobalPostRequest) Authorization(authorization string) ApiV1DataAssuranceAssurancesGlobalPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalPostRequest) V1DataAssuranceAssurancesGlobalPostRequest(v1DataAssuranceAssurancesGlobalPostRequest V1DataAssuranceAssurancesGlobalPostRequest) ApiV1DataAssuranceAssurancesGlobalPostRequest {
	r.v1DataAssuranceAssurancesGlobalPostRequest = &v1DataAssuranceAssurancesGlobalPostRequest
	return r
}

func (r ApiV1DataAssuranceAssurancesGlobalPostRequest) Execute() (*V1DataAssuranceAssurancesGlobalPost200Response, *http.Response, error) {
	return r.ApiService.V1DataAssuranceAssurancesGlobalPostExecute(r)
}

/*
V1DataAssuranceAssurancesGlobalPost Method for V1DataAssuranceAssurancesGlobalPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DataAssuranceAssurancesGlobalPostRequest
*/
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalPost(ctx context.Context) ApiV1DataAssuranceAssurancesGlobalPostRequest {
	return ApiV1DataAssuranceAssurancesGlobalPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DataAssuranceAssurancesGlobalPost200Response
func (a *DefaultAPIService) V1DataAssuranceAssurancesGlobalPostExecute(r ApiV1DataAssuranceAssurancesGlobalPostRequest) (*V1DataAssuranceAssurancesGlobalPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceAssurancesGlobalPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceAssurancesGlobalPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/assurances/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DataAssuranceAssurancesGlobalPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DataAssuranceAssurancesGlobalPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DataAssuranceAssurancesGlobalPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DataAssuranceFlexAlgosGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DataAssuranceFlexAlgosGetRequest) Authorization(authorization string) ApiV1DataAssuranceFlexAlgosGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DataAssuranceFlexAlgosGetRequest) Execute() (*V1DataAssuranceFlexAlgosGet200Response, *http.Response, error) {
	return r.ApiService.V1DataAssuranceFlexAlgosGetExecute(r)
}

/*
V1DataAssuranceFlexAlgosGet Method for V1DataAssuranceFlexAlgosGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DataAssuranceFlexAlgosGetRequest
*/
func (a *DefaultAPIService) V1DataAssuranceFlexAlgosGet(ctx context.Context) ApiV1DataAssuranceFlexAlgosGetRequest {
	return ApiV1DataAssuranceFlexAlgosGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DataAssuranceFlexAlgosGet200Response
func (a *DefaultAPIService) V1DataAssuranceFlexAlgosGetExecute(r ApiV1DataAssuranceFlexAlgosGetRequest) (*V1DataAssuranceFlexAlgosGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DataAssuranceFlexAlgosGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DataAssuranceFlexAlgosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/data-assurance/flex-algos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrStatsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	afiName *string
	deviceId *int64
	instanceName *string
	nbrAddress *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured BGP AfiSafi
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) AfiName(afiName string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.afiName = &afiName
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured BGP Instance name
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.instanceName = &instanceName
	return r
}

// Valid configured BGP Nbr address
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) NbrAddress(nbrAddress string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.nbrAddress = &nbrAddress
	return r
}

// 
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) Last(last int32) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingBgpNbrStatsGetRequest) Execute() (*V1DeviceRoutingBgpNbrStatsGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrStatsGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrStatsGet Method for V1DeviceRoutingBgpNbrStatsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrStatsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrStatsGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrStatsGetRequest {
	return ApiV1DeviceRoutingBgpNbrStatsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrStatsGet200Response
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrStatsGetExecute(r ApiV1DeviceRoutingBgpNbrStatsGetRequest) (*V1DeviceRoutingBgpNbrStatsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrStatsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrStatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbr/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.afiName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afiName", r.afiName, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.nbrAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nbrAddress", r.nbrAddress, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// 
func (r ApiV1DeviceRoutingBgpNbridGetRequest) Last(last int32) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingBgpNbridGetRequest) Execute() (*V1DeviceRoutingBgpNbridGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbridGetExecute(r)
}

/*
V1DeviceRoutingBgpNbridGet Method for V1DeviceRoutingBgpNbridGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbridGet(ctx context.Context) ApiV1DeviceRoutingBgpNbridGetRequest {
	return ApiV1DeviceRoutingBgpNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbridGet200Response
func (a *DefaultAPIService) V1DeviceRoutingBgpNbridGetExecute(r ApiV1DeviceRoutingBgpNbridGetRequest) (*V1DeviceRoutingBgpNbridGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbridGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrsCountersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrsCountersGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrsCountersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceRoutingBgpNbrsCountersGetRequest) Execute() (*V1DeviceRoutingBgpNbrsCountersGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrsCountersGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrsCountersGet Method for V1DeviceRoutingBgpNbrsCountersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrsCountersGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsCountersGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrsCountersGetRequest {
	return ApiV1DeviceRoutingBgpNbrsCountersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrsCountersGet200Response
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsCountersGetExecute(r ApiV1DeviceRoutingBgpNbrsCountersGetRequest) (*V1DeviceRoutingBgpNbrsCountersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrsCountersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrsCountersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrs/counters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrsDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	address *string
	deviceId *int64
	interface_ *string
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.authorization = &authorization
	return r
}

// BGP Nbr address
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Address(address string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.address = &address
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Interface name. Used in case of link local address
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Interface_(interface_ string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.interface_ = &interface_
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) Execute() (*V1DeviceRoutingBgpNbrsDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrsDetailsGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrsDetailsGet Method for V1DeviceRoutingBgpNbrsDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrsDetailsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsDetailsGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrsDetailsGetRequest {
	return ApiV1DeviceRoutingBgpNbrsDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrsDetailsGet200Response
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsDetailsGetExecute(r ApiV1DeviceRoutingBgpNbrsDetailsGetRequest) (*V1DeviceRoutingBgpNbrsDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrsDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrsDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrs/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.interface_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface", r.interface_, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	address *string
	deviceId *int64
	interface_ *string
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Authorization(authorization string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.authorization = &authorization
	return r
}

// BGP Nbr address
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Address(address string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.address = &address
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.deviceId = &deviceId
	return r
}

// Interface name. Used in case of link local address
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Interface_(interface_ string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.interface_ = &interface_
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) Execute() (*V1DeviceRoutingBgpNbrsPerAfiPrefixGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingBgpNbrsPerAfiPrefixGetExecute(r)
}

/*
V1DeviceRoutingBgpNbrsPerAfiPrefixGet Method for V1DeviceRoutingBgpNbrsPerAfiPrefixGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsPerAfiPrefixGet(ctx context.Context) ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest {
	return ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbrsPerAfiPrefixGet200Response
func (a *DefaultAPIService) V1DeviceRoutingBgpNbrsPerAfiPrefixGetExecute(r ApiV1DeviceRoutingBgpNbrsPerAfiPrefixGetRequest) (*V1DeviceRoutingBgpNbrsPerAfiPrefixGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbrsPerAfiPrefixGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingBgpNbrsPerAfiPrefixGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/bgp/nbrs/per-afi-prefix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.interface_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface", r.interface_, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOdpNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOdpNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOdpNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// 
func (r ApiV1DeviceRoutingOdpNbridGetRequest) Last(last int32) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOdpNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOdpNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOdpNbridGetRequest) Execute() (*V1DeviceRoutingBgpNbridGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOdpNbridGetExecute(r)
}

/*
V1DeviceRoutingOdpNbridGet Method for V1DeviceRoutingOdpNbridGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOdpNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOdpNbridGet(ctx context.Context) ApiV1DeviceRoutingOdpNbridGetRequest {
	return ApiV1DeviceRoutingOdpNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingBgpNbridGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOdpNbridGetExecute(r ApiV1DeviceRoutingOdpNbridGetRequest) (*V1DeviceRoutingBgpNbridGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingBgpNbridGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOdpNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/odp/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaInterfaceGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaInterfaceGet Method for V1DeviceRoutingOspfv2AreaInterfaceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceGetExecute(r ApiV1DeviceRoutingOspfv2AreaInterfaceGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaInterfaceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	interfaceId *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.instanceName = &instanceName
	return r
}

// Valid configured Interface name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) InterfaceId(interfaceId string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.interfaceId = &interfaceId
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaInterfaceNbridGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaInterfaceNbridGet Method for V1DeviceRoutingOspfv2AreaInterfaceNbridGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceNbridGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceNbridGetExecute(r ApiV1DeviceRoutingOspfv2AreaInterfaceNbridGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaInterfaceNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/interface/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.interfaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceId", r.interfaceId, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceidGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaInterfaceidGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaInterfaceidGet Method for V1DeviceRoutingOspfv2AreaInterfaceidGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceidGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceidGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaInterfaceidGetExecute(r ApiV1DeviceRoutingOspfv2AreaInterfaceidGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaInterfaceidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/interfaceid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaLsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaLsdbGet Method for V1DeviceRoutingOspfv2AreaLsdbGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaLsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaLsdbGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaLsdbGetExecute(r ApiV1DeviceRoutingOspfv2AreaLsdbGetRequest) (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaLsdbGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaLsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaNbrGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaNbrGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaNbrGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaNbrGet Method for V1DeviceRoutingOspfv2AreaNbrGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaNbrGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaNbrGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaNbrGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaNbrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaNbrGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaNbrGetExecute(r ApiV1DeviceRoutingOspfv2AreaNbrGetRequest) (*V1DeviceRoutingOspfv2AreaNbrGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaNbrGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaNbrGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/area/nbr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2AreaidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2AreaidGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaidGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2AreaidGetExecute(r)
}

/*
V1DeviceRoutingOspfv2AreaidGet Method for V1DeviceRoutingOspfv2AreaidGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2AreaidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaidGet(ctx context.Context) ApiV1DeviceRoutingOspfv2AreaidGetRequest {
	return ApiV1DeviceRoutingOspfv2AreaidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaidGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2AreaidGetExecute(r ApiV1DeviceRoutingOspfv2AreaidGetRequest) (*V1DeviceRoutingOspfv2AreaidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2AreaidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/areaid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2LsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2LsdbGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2LsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv2LsdbGet Method for V1DeviceRoutingOspfv2LsdbGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2LsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2LsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv2LsdbGetRequest {
	return ApiV1DeviceRoutingOspfv2LsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaLsdbGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2LsdbGetExecute(r ApiV1DeviceRoutingOspfv2LsdbGetRequest) (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaLsdbGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2LsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2RibGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	instanceName *string
	before *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Before(before string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.before = &before
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2RibGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv2RibGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv2RibGetRequest) Execute() (*V1DeviceRoutingOspfv2RibGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2RibGetExecute(r)
}

/*
V1DeviceRoutingOspfv2RibGet Method for V1DeviceRoutingOspfv2RibGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2RibGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2RibGet(ctx context.Context) ApiV1DeviceRoutingOspfv2RibGetRequest {
	return ApiV1DeviceRoutingOspfv2RibGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2RibGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2RibGetExecute(r ApiV1DeviceRoutingOspfv2RibGetRequest) (*V1DeviceRoutingOspfv2RibGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2RibGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2RibGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/rib"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv2StatisticsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfNames *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) VrfNames(vrfNames []string) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	r.vrfNames = &vrfNames
	return r
}

func (r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) Execute() (*V1DeviceRoutingOspfv2StatisticsGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv2StatisticsGetExecute(r)
}

/*
V1DeviceRoutingOspfv2StatisticsGet Method for V1DeviceRoutingOspfv2StatisticsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv2StatisticsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv2StatisticsGet(ctx context.Context) ApiV1DeviceRoutingOspfv2StatisticsGetRequest {
	return ApiV1DeviceRoutingOspfv2StatisticsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2StatisticsGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv2StatisticsGetExecute(r ApiV1DeviceRoutingOspfv2StatisticsGetRequest) (*V1DeviceRoutingOspfv2StatisticsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2StatisticsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv2StatisticsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv2/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.vrfNames != nil {
		t := *r.vrfNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaInterfaceGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaInterfaceGet Method for V1DeviceRoutingOspfv3AreaInterfaceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceGetExecute(r ApiV1DeviceRoutingOspfv3AreaInterfaceGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaInterfaceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	interfaceId *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.instanceName = &instanceName
	return r
}

// Valid configured Interface name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) InterfaceId(interfaceId string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.interfaceId = &interfaceId
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaInterfaceNbridGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaInterfaceNbridGet Method for V1DeviceRoutingOspfv3AreaInterfaceNbridGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceNbridGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceNbridGetExecute(r ApiV1DeviceRoutingOspfv3AreaInterfaceNbridGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceNbridGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaInterfaceNbridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/interface/nbrid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.interfaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interfaceId", r.interfaceId, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaInterfaceidGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaInterfaceidGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaInterfaceidGet Method for V1DeviceRoutingOspfv3AreaInterfaceidGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceidGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaInterfaceidGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaInterfaceidGetExecute(r ApiV1DeviceRoutingOspfv3AreaInterfaceidGetRequest) (*V1DeviceRoutingOspfv2AreaInterfaceidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaInterfaceidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaInterfaceidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/interfaceid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaLsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaLsdbGet Method for V1DeviceRoutingOspfv3AreaLsdbGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaLsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaLsdbGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaLsdbGetExecute(r ApiV1DeviceRoutingOspfv3AreaLsdbGetRequest) (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaLsdbGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaLsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaNbrGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	areaId *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured Area ID
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) AreaId(areaId string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.areaId = &areaId
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaNbrGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaNbrGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaNbrGet Method for V1DeviceRoutingOspfv3AreaNbrGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaNbrGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaNbrGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaNbrGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaNbrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaNbrGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaNbrGetExecute(r ApiV1DeviceRoutingOspfv3AreaNbrGetRequest) (*V1DeviceRoutingOspfv2AreaNbrGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaNbrGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaNbrGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/area/nbr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "areaId", r.areaId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3AreaidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3AreaidGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaidGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3AreaidGetExecute(r)
}

/*
V1DeviceRoutingOspfv3AreaidGet Method for V1DeviceRoutingOspfv3AreaidGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3AreaidGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaidGet(ctx context.Context) ApiV1DeviceRoutingOspfv3AreaidGetRequest {
	return ApiV1DeviceRoutingOspfv3AreaidGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaidGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3AreaidGetExecute(r ApiV1DeviceRoutingOspfv3AreaidGetRequest) (*V1DeviceRoutingOspfv2AreaidGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaidGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3AreaidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/areaid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3LsdbGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	instanceName *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3LsdbGetRequest) Execute() (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3LsdbGetExecute(r)
}

/*
V1DeviceRoutingOspfv3LsdbGet Method for V1DeviceRoutingOspfv3LsdbGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3LsdbGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3LsdbGet(ctx context.Context) ApiV1DeviceRoutingOspfv3LsdbGetRequest {
	return ApiV1DeviceRoutingOspfv3LsdbGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2AreaLsdbGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3LsdbGetExecute(r ApiV1DeviceRoutingOspfv3LsdbGetRequest) (*V1DeviceRoutingOspfv2AreaLsdbGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2AreaLsdbGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3LsdbGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/lsdb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3RibGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	instanceName *string
	before *string
	last *int32
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured OSPF Instance name
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) InstanceName(instanceName string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.instanceName = &instanceName
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) Before(before string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.before = &before
	return r
}

// 
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) Last(last int32) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.last = &last
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3RibGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingOspfv3RibGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingOspfv3RibGetRequest) Execute() (*V1DeviceRoutingOspfv2RibGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3RibGetExecute(r)
}

/*
V1DeviceRoutingOspfv3RibGet Method for V1DeviceRoutingOspfv3RibGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3RibGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3RibGet(ctx context.Context) ApiV1DeviceRoutingOspfv3RibGetRequest {
	return ApiV1DeviceRoutingOspfv3RibGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2RibGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3RibGetExecute(r ApiV1DeviceRoutingOspfv3RibGetRequest) (*V1DeviceRoutingOspfv2RibGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2RibGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3RibGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/rib"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceName", r.instanceName, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.last != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last", r.last, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingOspfv3StatisticsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfNames *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) Authorization(authorization string) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF name
func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) VrfNames(vrfNames []string) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	r.vrfNames = &vrfNames
	return r
}

func (r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) Execute() (*V1DeviceRoutingOspfv2StatisticsGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingOspfv3StatisticsGetExecute(r)
}

/*
V1DeviceRoutingOspfv3StatisticsGet Method for V1DeviceRoutingOspfv3StatisticsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingOspfv3StatisticsGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingOspfv3StatisticsGet(ctx context.Context) ApiV1DeviceRoutingOspfv3StatisticsGetRequest {
	return ApiV1DeviceRoutingOspfv3StatisticsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingOspfv2StatisticsGet200Response
func (a *DefaultAPIService) V1DeviceRoutingOspfv3StatisticsGetExecute(r ApiV1DeviceRoutingOspfv3StatisticsGetRequest) (*V1DeviceRoutingOspfv2StatisticsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingOspfv2StatisticsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingOspfv3StatisticsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/ospfv3/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.vrfNames != nil {
		t := *r.vrfNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfNames", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingRibRouteCountPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
	deviceId *int64
	vrfName *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingRibRouteCountPostRequest) Authorization(authorization string) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceRoutingRibRouteCountPostRequest) Body(body map[string]interface{}) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.body = &body
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingRibRouteCountPostRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF names
func (r ApiV1DeviceRoutingRibRouteCountPostRequest) VrfName(vrfName []string) ApiV1DeviceRoutingRibRouteCountPostRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingRibRouteCountPostRequest) Execute() (*V1DeviceRoutingVrfBgpRouteCountPost200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingRibRouteCountPostExecute(r)
}

/*
V1DeviceRoutingRibRouteCountPost Method for V1DeviceRoutingRibRouteCountPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingRibRouteCountPostRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingRibRouteCountPost(ctx context.Context) ApiV1DeviceRoutingRibRouteCountPostRequest {
	return ApiV1DeviceRoutingRibRouteCountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpRouteCountPost200Response
func (a *DefaultAPIService) V1DeviceRoutingRibRouteCountPostExecute(r ApiV1DeviceRoutingRibRouteCountPostRequest) (*V1DeviceRoutingVrfBgpRouteCountPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpRouteCountPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingRibRouteCountPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/rib/route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.vrfName != nil {
		t := *r.vrfName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) Authorization(authorization string) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF names
func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) Execute() (*V1DeviceRoutingVrfBgpEibgpRouteCountGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingVrfBgpEibgpRouteCountGetExecute(r)
}

/*
V1DeviceRoutingVrfBgpEibgpRouteCountGet Method for V1DeviceRoutingVrfBgpEibgpRouteCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpEibgpRouteCountGet(ctx context.Context) ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest {
	return ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpEibgpRouteCountGet200Response
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpEibgpRouteCountGetExecute(r ApiV1DeviceRoutingVrfBgpEibgpRouteCountGetRequest) (*V1DeviceRoutingVrfBgpEibgpRouteCountGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpEibgpRouteCountGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingVrfBgpEibgpRouteCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/vrf/bgp/eibgp-route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) Authorization(authorization string) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) DeviceId(deviceId int64) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	r.deviceId = &deviceId
	return r
}

// Valid configured VRF names
func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) VrfName(vrfName string) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) Execute() (*V1DeviceRoutingVrfBgpGraphiantEirouteCountGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingVrfBgpGraphiantEirouteCountGetExecute(r)
}

/*
V1DeviceRoutingVrfBgpGraphiantEirouteCountGet Method for V1DeviceRoutingVrfBgpGraphiantEirouteCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpGraphiantEirouteCountGet(ctx context.Context) ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest {
	return ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpGraphiantEirouteCountGet200Response
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpGraphiantEirouteCountGetExecute(r ApiV1DeviceRoutingVrfBgpGraphiantEirouteCountGetRequest) (*V1DeviceRoutingVrfBgpGraphiantEirouteCountGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpGraphiantEirouteCountGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingVrfBgpGraphiantEirouteCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/vrf/bgp/graphiant-eiroute-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceRoutingVrfBgpRouteCountPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceRoutingVrfBgpRouteCountPostRequest *V1DeviceRoutingVrfBgpRouteCountPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) Authorization(authorization string) ApiV1DeviceRoutingVrfBgpRouteCountPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) V1DeviceRoutingVrfBgpRouteCountPostRequest(v1DeviceRoutingVrfBgpRouteCountPostRequest V1DeviceRoutingVrfBgpRouteCountPostRequest) ApiV1DeviceRoutingVrfBgpRouteCountPostRequest {
	r.v1DeviceRoutingVrfBgpRouteCountPostRequest = &v1DeviceRoutingVrfBgpRouteCountPostRequest
	return r
}

func (r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) Execute() (*V1DeviceRoutingVrfBgpRouteCountPost200Response, *http.Response, error) {
	return r.ApiService.V1DeviceRoutingVrfBgpRouteCountPostExecute(r)
}

/*
V1DeviceRoutingVrfBgpRouteCountPost Method for V1DeviceRoutingVrfBgpRouteCountPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceRoutingVrfBgpRouteCountPostRequest
*/
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpRouteCountPost(ctx context.Context) ApiV1DeviceRoutingVrfBgpRouteCountPostRequest {
	return ApiV1DeviceRoutingVrfBgpRouteCountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceRoutingVrfBgpRouteCountPost200Response
func (a *DefaultAPIService) V1DeviceRoutingVrfBgpRouteCountPostExecute(r ApiV1DeviceRoutingVrfBgpRouteCountPostRequest) (*V1DeviceRoutingVrfBgpRouteCountPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceRoutingVrfBgpRouteCountPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceRoutingVrfBgpRouteCountPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/routing/vrf/bgp/route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceRoutingVrfBgpRouteCountPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceRoutingVrfBgpRouteCountPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceRoutingVrfBgpRouteCountPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotDeviceIdGetRequest) Authorization(authorization string) ApiV1DeviceSnapshotDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotDeviceIdGetRequest) Execute() (*V1DeviceSnapshotDeviceIdGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotDeviceIdGetExecute(r)
}

/*
V1DeviceSnapshotDeviceIdGet Method for V1DeviceSnapshotDeviceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DeviceSnapshotDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DeviceSnapshotDeviceIdGetRequest {
	return ApiV1DeviceSnapshotDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DeviceSnapshotDeviceIdGet200Response
func (a *DefaultAPIService) V1DeviceSnapshotDeviceIdGetExecute(r ApiV1DeviceSnapshotDeviceIdGetRequest) (*V1DeviceSnapshotDeviceIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceSnapshotDeviceIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotGetRequest) Authorization(authorization string) ApiV1DeviceSnapshotGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotGetRequest) Execute() (*V1DeviceSnapshotGet200Response, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotGetExecute(r)
}

/*
V1DeviceSnapshotGet Method for V1DeviceSnapshotGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceSnapshotGetRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotGet(ctx context.Context) ApiV1DeviceSnapshotGetRequest {
	return ApiV1DeviceSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceSnapshotGet200Response
func (a *DefaultAPIService) V1DeviceSnapshotGetExecute(r ApiV1DeviceSnapshotGetRequest) (*V1DeviceSnapshotGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceSnapshotGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceSnapshotPostRequest *V1DeviceSnapshotPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotPostRequest) Authorization(authorization string) ApiV1DeviceSnapshotPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotPostRequest) V1DeviceSnapshotPostRequest(v1DeviceSnapshotPostRequest V1DeviceSnapshotPostRequest) ApiV1DeviceSnapshotPostRequest {
	r.v1DeviceSnapshotPostRequest = &v1DeviceSnapshotPostRequest
	return r
}

func (r ApiV1DeviceSnapshotPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotPostExecute(r)
}

/*
V1DeviceSnapshotPost Method for V1DeviceSnapshotPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceSnapshotPostRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotPost(ctx context.Context) ApiV1DeviceSnapshotPostRequest {
	return ApiV1DeviceSnapshotPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DeviceSnapshotPostExecute(r ApiV1DeviceSnapshotPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceSnapshotPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceSnapshotPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceSnapshotPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceSnapshotPutRequest *V1DeviceSnapshotPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotPutRequest) Authorization(authorization string) ApiV1DeviceSnapshotPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotPutRequest) V1DeviceSnapshotPutRequest(v1DeviceSnapshotPutRequest V1DeviceSnapshotPutRequest) ApiV1DeviceSnapshotPutRequest {
	r.v1DeviceSnapshotPutRequest = &v1DeviceSnapshotPutRequest
	return r
}

func (r ApiV1DeviceSnapshotPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotPutExecute(r)
}

/*
V1DeviceSnapshotPut Method for V1DeviceSnapshotPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceSnapshotPutRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotPut(ctx context.Context) ApiV1DeviceSnapshotPutRequest {
	return ApiV1DeviceSnapshotPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DeviceSnapshotPutExecute(r ApiV1DeviceSnapshotPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceSnapshotPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceSnapshotPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceSnapshotPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceSnapshotSnapshotIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	snapshotId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceSnapshotSnapshotIdDeleteRequest) Authorization(authorization string) ApiV1DeviceSnapshotSnapshotIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceSnapshotSnapshotIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DeviceSnapshotSnapshotIdDeleteExecute(r)
}

/*
V1DeviceSnapshotSnapshotIdDelete Method for V1DeviceSnapshotSnapshotIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param snapshotId 
 @return ApiV1DeviceSnapshotSnapshotIdDeleteRequest
*/
func (a *DefaultAPIService) V1DeviceSnapshotSnapshotIdDelete(ctx context.Context, snapshotId int64) ApiV1DeviceSnapshotSnapshotIdDeleteRequest {
	return ApiV1DeviceSnapshotSnapshotIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DeviceSnapshotSnapshotIdDeleteExecute(r ApiV1DeviceSnapshotSnapshotIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceSnapshotSnapshotIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device/snapshot/{snapshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceStatusHistoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceStatusHistoryPostRequest *V1DeviceStatusHistoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceStatusHistoryPostRequest) Authorization(authorization string) ApiV1DeviceStatusHistoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceStatusHistoryPostRequest) V1DeviceStatusHistoryPostRequest(v1DeviceStatusHistoryPostRequest V1DeviceStatusHistoryPostRequest) ApiV1DeviceStatusHistoryPostRequest {
	r.v1DeviceStatusHistoryPostRequest = &v1DeviceStatusHistoryPostRequest
	return r
}

func (r ApiV1DeviceStatusHistoryPostRequest) Execute() (*V1DeviceStatusHistoryPost200Response, *http.Response, error) {
	return r.ApiService.V1DeviceStatusHistoryPostExecute(r)
}

/*
V1DeviceStatusHistoryPost Method for V1DeviceStatusHistoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceStatusHistoryPostRequest
*/
func (a *DefaultAPIService) V1DeviceStatusHistoryPost(ctx context.Context) ApiV1DeviceStatusHistoryPostRequest {
	return ApiV1DeviceStatusHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceStatusHistoryPost200Response
func (a *DefaultAPIService) V1DeviceStatusHistoryPostExecute(r ApiV1DeviceStatusHistoryPostRequest) (*V1DeviceStatusHistoryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceStatusHistoryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceStatusHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device-status/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceStatusHistoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceStatusHistoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceStatusHistoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DeviceStatusPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DeviceStatusHistoryPostRequest *V1DeviceStatusHistoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DeviceStatusPostRequest) Authorization(authorization string) ApiV1DeviceStatusPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DeviceStatusPostRequest) V1DeviceStatusHistoryPostRequest(v1DeviceStatusHistoryPostRequest V1DeviceStatusHistoryPostRequest) ApiV1DeviceStatusPostRequest {
	r.v1DeviceStatusHistoryPostRequest = &v1DeviceStatusHistoryPostRequest
	return r
}

func (r ApiV1DeviceStatusPostRequest) Execute() (*V1DeviceStatusPost200Response, *http.Response, error) {
	return r.ApiService.V1DeviceStatusPostExecute(r)
}

/*
V1DeviceStatusPost Method for V1DeviceStatusPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DeviceStatusPostRequest
*/
func (a *DefaultAPIService) V1DeviceStatusPost(ctx context.Context) ApiV1DeviceStatusPostRequest {
	return ApiV1DeviceStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DeviceStatusPost200Response
func (a *DefaultAPIService) V1DeviceStatusPostExecute(r ApiV1DeviceStatusPostRequest) (*V1DeviceStatusPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceStatusPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DeviceStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/device-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DeviceStatusHistoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DeviceStatusHistoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DeviceStatusHistoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesBringupPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupPostRequest *V1DevicesBringupPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesBringupPostRequest) Authorization(authorization string) ApiV1DevicesBringupPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesBringupPostRequest) V1DevicesBringupPostRequest(v1DevicesBringupPostRequest V1DevicesBringupPostRequest) ApiV1DevicesBringupPostRequest {
	r.v1DevicesBringupPostRequest = &v1DevicesBringupPostRequest
	return r
}

func (r ApiV1DevicesBringupPostRequest) Execute() (*V1DevicesBringupPost200Response, *http.Response, error) {
	return r.ApiService.V1DevicesBringupPostExecute(r)
}

/*
V1DevicesBringupPost Method for V1DevicesBringupPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesBringupPostRequest
*/
func (a *DefaultAPIService) V1DevicesBringupPost(ctx context.Context) ApiV1DevicesBringupPostRequest {
	return ApiV1DevicesBringupPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesBringupPost200Response
func (a *DefaultAPIService) V1DevicesBringupPostExecute(r ApiV1DevicesBringupPostRequest) (*V1DevicesBringupPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesBringupPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesBringupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/bringup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesBringupPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesBringupPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupPutRequest *V1DevicesBringupPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesBringupPutRequest) Authorization(authorization string) ApiV1DevicesBringupPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesBringupPutRequest) V1DevicesBringupPutRequest(v1DevicesBringupPutRequest V1DevicesBringupPutRequest) ApiV1DevicesBringupPutRequest {
	r.v1DevicesBringupPutRequest = &v1DevicesBringupPutRequest
	return r
}

func (r ApiV1DevicesBringupPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesBringupPutExecute(r)
}

/*
V1DevicesBringupPut Method for V1DevicesBringupPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesBringupPutRequest
*/
func (a *DefaultAPIService) V1DevicesBringupPut(ctx context.Context) ApiV1DevicesBringupPutRequest {
	return ApiV1DevicesBringupPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesBringupPutExecute(r ApiV1DevicesBringupPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesBringupPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/bringup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesBringupPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesBringupTokenPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupTokenPostRequest *V1DevicesBringupTokenPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesBringupTokenPostRequest) Authorization(authorization string) ApiV1DevicesBringupTokenPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesBringupTokenPostRequest) V1DevicesBringupTokenPostRequest(v1DevicesBringupTokenPostRequest V1DevicesBringupTokenPostRequest) ApiV1DevicesBringupTokenPostRequest {
	r.v1DevicesBringupTokenPostRequest = &v1DevicesBringupTokenPostRequest
	return r
}

func (r ApiV1DevicesBringupTokenPostRequest) Execute() (*V1DevicesBringupTokenPost200Response, *http.Response, error) {
	return r.ApiService.V1DevicesBringupTokenPostExecute(r)
}

/*
V1DevicesBringupTokenPost Method for V1DevicesBringupTokenPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesBringupTokenPostRequest
*/
func (a *DefaultAPIService) V1DevicesBringupTokenPost(ctx context.Context) ApiV1DevicesBringupTokenPostRequest {
	return ApiV1DevicesBringupTokenPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesBringupTokenPost200Response
func (a *DefaultAPIService) V1DevicesBringupTokenPostExecute(r ApiV1DevicesBringupTokenPostRequest) (*V1DevicesBringupTokenPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesBringupTokenPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesBringupTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/bringup/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupTokenPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesBringupTokenPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupTokenPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesClearNewFlagPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesClearNewFlagPostRequest) Authorization(authorization string) ApiV1DevicesClearNewFlagPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesClearNewFlagPostRequest) Body(body map[string]interface{}) ApiV1DevicesClearNewFlagPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DevicesClearNewFlagPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesClearNewFlagPostExecute(r)
}

/*
V1DevicesClearNewFlagPost Method for V1DevicesClearNewFlagPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesClearNewFlagPostRequest
*/
func (a *DefaultAPIService) V1DevicesClearNewFlagPost(ctx context.Context) ApiV1DevicesClearNewFlagPostRequest {
	return ApiV1DevicesClearNewFlagPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesClearNewFlagPostExecute(r ApiV1DevicesClearNewFlagPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesClearNewFlagPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/clear-new-flag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdArpGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdArpGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdArpGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdArpGetRequest) Execute() (*V1DevicesDeviceIdArpGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdArpGetExecute(r)
}

/*
V1DevicesDeviceIdArpGet Method for V1DevicesDeviceIdArpGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdArpGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdArpGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdArpGetRequest {
	return ApiV1DevicesDeviceIdArpGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdArpGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdArpGetExecute(r ApiV1DevicesDeviceIdArpGetRequest) (*V1DevicesDeviceIdArpGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdArpGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdArpGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/arp"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdCandidateCircuitsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdCandidateCircuitsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdCandidateCircuitsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdCandidateCircuitsGetRequest) Execute() (*V1DevicesDeviceIdCandidateCircuitsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdCandidateCircuitsGetExecute(r)
}

/*
V1DevicesDeviceIdCandidateCircuitsGet Method for V1DevicesDeviceIdCandidateCircuitsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdCandidateCircuitsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdCandidateCircuitsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdCandidateCircuitsGetRequest {
	return ApiV1DevicesDeviceIdCandidateCircuitsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdCandidateCircuitsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdCandidateCircuitsGetExecute(r ApiV1DevicesDeviceIdCandidateCircuitsGetRequest) (*V1DevicesDeviceIdCandidateCircuitsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdCandidateCircuitsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdCandidateCircuitsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/candidate-circuits"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest) Execute() (*V1DevicesDeviceIdCircuitsVrfAssociationsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdCircuitsVrfAssociationsGetExecute(r)
}

/*
V1DevicesDeviceIdCircuitsVrfAssociationsGet Method for V1DevicesDeviceIdCircuitsVrfAssociationsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdCircuitsVrfAssociationsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest {
	return ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdCircuitsVrfAssociationsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdCircuitsVrfAssociationsGetExecute(r ApiV1DevicesDeviceIdCircuitsVrfAssociationsGetRequest) (*V1DevicesDeviceIdCircuitsVrfAssociationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdCircuitsVrfAssociationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdCircuitsVrfAssociationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/circuits/vrf-associations"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdConfigPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DevicesDeviceIdConfigPutRequest *V1DevicesDeviceIdConfigPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdConfigPutRequest) Authorization(authorization string) ApiV1DevicesDeviceIdConfigPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdConfigPutRequest) V1DevicesDeviceIdConfigPutRequest(v1DevicesDeviceIdConfigPutRequest V1DevicesDeviceIdConfigPutRequest) ApiV1DevicesDeviceIdConfigPutRequest {
	r.v1DevicesDeviceIdConfigPutRequest = &v1DevicesDeviceIdConfigPutRequest
	return r
}

func (r ApiV1DevicesDeviceIdConfigPutRequest) Execute() (*V1DevicesDeviceIdConfigPut202Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdConfigPutExecute(r)
}

/*
V1DevicesDeviceIdConfigPut Method for V1DevicesDeviceIdConfigPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdConfigPutRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdConfigPut(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdConfigPutRequest {
	return ApiV1DevicesDeviceIdConfigPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdConfigPut202Response
func (a *DefaultAPIService) V1DevicesDeviceIdConfigPutExecute(r ApiV1DevicesDeviceIdConfigPutRequest) (*V1DevicesDeviceIdConfigPut202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdConfigPut202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdConfigPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesDeviceIdConfigPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesDeviceIdConfigPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesDeviceIdConfigPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdConnectivityGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdConnectivityGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdConnectivityGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdConnectivityGetRequest) Execute() (*V1DevicesDeviceIdConnectivityGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdConnectivityGetExecute(r)
}

/*
V1DevicesDeviceIdConnectivityGet Method for V1DevicesDeviceIdConnectivityGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdConnectivityGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdConnectivityGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdConnectivityGetRequest {
	return ApiV1DevicesDeviceIdConnectivityGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdConnectivityGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdConnectivityGetExecute(r ApiV1DevicesDeviceIdConnectivityGetRequest) (*V1DevicesDeviceIdConnectivityGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdConnectivityGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdConnectivityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/connectivity"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdControllerPeersPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DevicesDeviceIdControllerPeersPutRequest *V1DevicesDeviceIdControllerPeersPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdControllerPeersPutRequest) Authorization(authorization string) ApiV1DevicesDeviceIdControllerPeersPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdControllerPeersPutRequest) V1DevicesDeviceIdControllerPeersPutRequest(v1DevicesDeviceIdControllerPeersPutRequest V1DevicesDeviceIdControllerPeersPutRequest) ApiV1DevicesDeviceIdControllerPeersPutRequest {
	r.v1DevicesDeviceIdControllerPeersPutRequest = &v1DevicesDeviceIdControllerPeersPutRequest
	return r
}

func (r ApiV1DevicesDeviceIdControllerPeersPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdControllerPeersPutExecute(r)
}

/*
V1DevicesDeviceIdControllerPeersPut Method for V1DevicesDeviceIdControllerPeersPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdControllerPeersPutRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdControllerPeersPut(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdControllerPeersPutRequest {
	return ApiV1DevicesDeviceIdControllerPeersPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesDeviceIdControllerPeersPutExecute(r ApiV1DevicesDeviceIdControllerPeersPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdControllerPeersPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/controller-peers"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesDeviceIdControllerPeersPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesDeviceIdControllerPeersPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesDeviceIdControllerPeersPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest) Execute() (*V1DevicesDeviceIdDhcpServerLeasesGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDhcpServerLeasesGetExecute(r)
}

/*
V1DevicesDeviceIdDhcpServerLeasesGet Method for V1DevicesDeviceIdDhcpServerLeasesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDhcpServerLeasesGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest {
	return ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdDhcpServerLeasesGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdDhcpServerLeasesGetExecute(r ApiV1DevicesDeviceIdDhcpServerLeasesGetRequest) (*V1DevicesDeviceIdDhcpServerLeasesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdDhcpServerLeasesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDhcpServerLeasesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/dhcp-server/leases"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDraftDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDraftDeleteRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDraftDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDraftDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDraftDeleteExecute(r)
}

/*
V1DevicesDeviceIdDraftDelete Method for V1DevicesDeviceIdDraftDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDraftDeleteRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDraftDelete(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDraftDeleteRequest {
	return ApiV1DevicesDeviceIdDraftDeleteRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesDeviceIdDraftDeleteExecute(r ApiV1DevicesDeviceIdDraftDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDraftDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDraftGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDraftGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDraftGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDraftGetRequest) Execute() (*V1DevicesDeviceIdDraftGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDraftGetExecute(r)
}

/*
V1DevicesDeviceIdDraftGet Method for V1DevicesDeviceIdDraftGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDraftGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDraftGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDraftGetRequest {
	return ApiV1DevicesDeviceIdDraftGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdDraftGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdDraftGetExecute(r ApiV1DevicesDeviceIdDraftGetRequest) (*V1DevicesDeviceIdDraftGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdDraftGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDraftGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdDraftPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DevicesDeviceIdDraftPostRequest *V1DevicesDeviceIdDraftPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdDraftPostRequest) Authorization(authorization string) ApiV1DevicesDeviceIdDraftPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdDraftPostRequest) V1DevicesDeviceIdDraftPostRequest(v1DevicesDeviceIdDraftPostRequest V1DevicesDeviceIdDraftPostRequest) ApiV1DevicesDeviceIdDraftPostRequest {
	r.v1DevicesDeviceIdDraftPostRequest = &v1DevicesDeviceIdDraftPostRequest
	return r
}

func (r ApiV1DevicesDeviceIdDraftPostRequest) Execute() (*V1DevicesDeviceIdDraftPost201Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdDraftPostExecute(r)
}

/*
V1DevicesDeviceIdDraftPost Method for V1DevicesDeviceIdDraftPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdDraftPostRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdDraftPost(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdDraftPostRequest {
	return ApiV1DevicesDeviceIdDraftPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdDraftPost201Response
func (a *DefaultAPIService) V1DevicesDeviceIdDraftPostExecute(r ApiV1DevicesDeviceIdDraftPostRequest) (*V1DevicesDeviceIdDraftPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdDraftPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdDraftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesDeviceIdDraftPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesDeviceIdDraftPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesDeviceIdDraftPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdEdgesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdEdgesGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdEdgesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdEdgesGetRequest) Execute() (*V1DevicesDeviceIdEdgesGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdEdgesGetExecute(r)
}

/*
V1DevicesDeviceIdEdgesGet Method for V1DevicesDeviceIdEdgesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdEdgesGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdEdgesGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdEdgesGetRequest {
	return ApiV1DevicesDeviceIdEdgesGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdEdgesGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdEdgesGetExecute(r ApiV1DevicesDeviceIdEdgesGetRequest) (*V1DevicesDeviceIdEdgesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdEdgesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdEdgesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/edges"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdGetRequest) Execute() (*V1DevicesDeviceIdGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdGetExecute(r)
}

/*
V1DevicesDeviceIdGet Method for V1DevicesDeviceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdGetRequest {
	return ApiV1DevicesDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdGetExecute(r ApiV1DevicesDeviceIdGetRequest) (*V1DevicesDeviceIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdInterfacesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdInterfacesGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdInterfacesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdInterfacesGetRequest) Execute() (*V1DevicesDeviceIdInterfacesGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdInterfacesGetExecute(r)
}

/*
V1DevicesDeviceIdInterfacesGet Method for V1DevicesDeviceIdInterfacesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdInterfacesGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdInterfacesGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdInterfacesGetRequest {
	return ApiV1DevicesDeviceIdInterfacesGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdInterfacesGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdInterfacesGetExecute(r ApiV1DevicesDeviceIdInterfacesGetRequest) (*V1DevicesDeviceIdInterfacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdInterfacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdInterfacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdJobsJobIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	jobId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdJobsJobIdGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdJobsJobIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdJobsJobIdGetRequest) Execute() (*V1DevicesDeviceIdJobsJobIdGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdJobsJobIdGetExecute(r)
}

/*
V1DevicesDeviceIdJobsJobIdGet Method for V1DevicesDeviceIdJobsJobIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @param jobId id of the job as received from the Enqueue* calls.
 @return ApiV1DevicesDeviceIdJobsJobIdGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdJobsJobIdGet(ctx context.Context, deviceId int64, jobId int64) ApiV1DevicesDeviceIdJobsJobIdGetRequest {
	return ApiV1DevicesDeviceIdJobsJobIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdJobsJobIdGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdJobsJobIdGetExecute(r ApiV1DevicesDeviceIdJobsJobIdGetRequest) (*V1DevicesDeviceIdJobsJobIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdJobsJobIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdJobsJobIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdNdcacheGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdNdcacheGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdNdcacheGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdNdcacheGetRequest) Execute() (*V1DevicesDeviceIdNdcacheGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdNdcacheGetExecute(r)
}

/*
V1DevicesDeviceIdNdcacheGet Method for V1DevicesDeviceIdNdcacheGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdNdcacheGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdNdcacheGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdNdcacheGetRequest {
	return ApiV1DevicesDeviceIdNdcacheGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdNdcacheGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdNdcacheGetExecute(r ApiV1DevicesDeviceIdNdcacheGetRequest) (*V1DevicesDeviceIdNdcacheGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdNdcacheGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdNdcacheGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/ndcache"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest) Execute() (*V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdOspfv2DefaultOriginateGetExecute(r)
}

/*
V1DevicesDeviceIdOspfv2DefaultOriginateGet Method for V1DevicesDeviceIdOspfv2DefaultOriginateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv2DefaultOriginateGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest {
	return ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv2DefaultOriginateGetExecute(r ApiV1DevicesDeviceIdOspfv2DefaultOriginateGetRequest) (*V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdOspfv2DefaultOriginateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/ospfv2/defaultOriginate"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest) Execute() (*V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdOspfv3DefaultOriginateGetExecute(r)
}

/*
V1DevicesDeviceIdOspfv3DefaultOriginateGet Method for V1DevicesDeviceIdOspfv3DefaultOriginateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv3DefaultOriginateGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest {
	return ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdOspfv3DefaultOriginateGetExecute(r ApiV1DevicesDeviceIdOspfv3DefaultOriginateGetRequest) (*V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdOspfv2DefaultOriginateGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdOspfv3DefaultOriginateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/ospfv3/defaultOriginate"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdPolicyApplicationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdPolicyApplicationsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdPolicyApplicationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdPolicyApplicationsGetRequest) Execute() (*V1PolicyApplicationsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdPolicyApplicationsGetExecute(r)
}

/*
V1DevicesDeviceIdPolicyApplicationsGet Method for V1DevicesDeviceIdPolicyApplicationsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdPolicyApplicationsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyApplicationsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdPolicyApplicationsGetRequest {
	return ApiV1DevicesDeviceIdPolicyApplicationsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1PolicyApplicationsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyApplicationsGetExecute(r ApiV1DevicesDeviceIdPolicyApplicationsGetRequest) (*V1PolicyApplicationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyApplicationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdPolicyApplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/policy/applications"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest) Execute() (*V1PolicyApplicationsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdPolicyCustomapplicationsGetExecute(r)
}

/*
V1DevicesDeviceIdPolicyCustomapplicationsGet Method for V1DevicesDeviceIdPolicyCustomapplicationsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyCustomapplicationsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest {
	return ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1PolicyApplicationsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyCustomapplicationsGetExecute(r ApiV1DevicesDeviceIdPolicyCustomapplicationsGetRequest) (*V1PolicyApplicationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyApplicationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdPolicyCustomapplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/policy/customapplications"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdPolicyZonepairsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdPolicyZonepairsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdPolicyZonepairsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdPolicyZonepairsGetRequest) Execute() (*V1DevicesDeviceIdPolicyZonepairsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdPolicyZonepairsGetExecute(r)
}

/*
V1DevicesDeviceIdPolicyZonepairsGet Method for V1DevicesDeviceIdPolicyZonepairsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdPolicyZonepairsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyZonepairsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdPolicyZonepairsGetRequest {
	return ApiV1DevicesDeviceIdPolicyZonepairsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdPolicyZonepairsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdPolicyZonepairsGetExecute(r ApiV1DevicesDeviceIdPolicyZonepairsGetRequest) (*V1DevicesDeviceIdPolicyZonepairsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdPolicyZonepairsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdPolicyZonepairsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/policy/zonepairs"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdSlicePeersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdSlicePeersGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdSlicePeersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdSlicePeersGetRequest) Execute() (*V1DevicesDeviceIdSlicePeersGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdSlicePeersGetExecute(r)
}

/*
V1DevicesDeviceIdSlicePeersGet Method for V1DevicesDeviceIdSlicePeersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdSlicePeersGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdSlicePeersGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdSlicePeersGetRequest {
	return ApiV1DevicesDeviceIdSlicePeersGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdSlicePeersGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdSlicePeersGetExecute(r ApiV1DevicesDeviceIdSlicePeersGetRequest) (*V1DevicesDeviceIdSlicePeersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdSlicePeersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdSlicePeersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/slice/peers"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdTwampCoreGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdTwampCoreGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdTwampCoreGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdTwampCoreGetRequest) Execute() (*V1DevicesDeviceIdTwampCoreGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdTwampCoreGetExecute(r)
}

/*
V1DevicesDeviceIdTwampCoreGet Method for V1DevicesDeviceIdTwampCoreGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdTwampCoreGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdTwampCoreGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdTwampCoreGetRequest {
	return ApiV1DevicesDeviceIdTwampCoreGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdTwampCoreGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdTwampCoreGetExecute(r ApiV1DevicesDeviceIdTwampCoreGetRequest) (*V1DevicesDeviceIdTwampCoreGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdTwampCoreGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdTwampCoreGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/twamp/core"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVersionsCompareGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVersionsCompareGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVersionsCompareGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVersionsCompareGetRequest) Execute() (*V1DevicesDeviceIdVersionsCompareGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVersionsCompareGetExecute(r)
}

/*
V1DevicesDeviceIdVersionsCompareGet Method for V1DevicesDeviceIdVersionsCompareGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 16 bytes (base64 encoded) identifier for the device.
 @return ApiV1DevicesDeviceIdVersionsCompareGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsCompareGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVersionsCompareGetRequest {
	return ApiV1DevicesDeviceIdVersionsCompareGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVersionsCompareGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsCompareGetExecute(r ApiV1DevicesDeviceIdVersionsCompareGetRequest) (*V1DevicesDeviceIdVersionsCompareGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVersionsCompareGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVersionsCompareGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/versions/compare"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVersionsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVersionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVersionsGetRequest) Execute() (*V1DevicesDeviceIdVersionsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVersionsGetExecute(r)
}

/*
V1DevicesDeviceIdVersionsGet Method for V1DevicesDeviceIdVersionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 16 bytes (base64 encoded) identifier for the device.
 @return ApiV1DevicesDeviceIdVersionsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVersionsGetRequest {
	return ApiV1DevicesDeviceIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVersionsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsGetExecute(r ApiV1DevicesDeviceIdVersionsGetRequest) (*V1DevicesDeviceIdVersionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVersionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVersionsVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	version int32
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVersionsVersionGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVersionsVersionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVersionsVersionGetRequest) Execute() (*V1DevicesDeviceIdVersionsVersionGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVersionsVersionGetExecute(r)
}

/*
V1DevicesDeviceIdVersionsVersionGet Method for V1DevicesDeviceIdVersionsVersionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 16 bytes (base64 encoded) identifier for the device.
 @param version 8 bytes (base32 encoded) version number.
 @return ApiV1DevicesDeviceIdVersionsVersionGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsVersionGet(ctx context.Context, deviceId int64, version int32) ApiV1DevicesDeviceIdVersionsVersionGetRequest {
	return ApiV1DevicesDeviceIdVersionsVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
		version: version,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVersionsVersionGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdVersionsVersionGetExecute(r ApiV1DevicesDeviceIdVersionsVersionGetRequest) (*V1DevicesDeviceIdVersionsVersionGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVersionsVersionGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVersionsVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.version < 0 {
		return localVarReturnValue, nil, reportError("version must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVrfBgpAsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVrfBgpAsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVrfBgpAsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVrfBgpAsGetRequest) Execute() (*V1DevicesDeviceIdVrfBgpAsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVrfBgpAsGetExecute(r)
}

/*
V1DevicesDeviceIdVrfBgpAsGet Method for V1DevicesDeviceIdVrfBgpAsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdVrfBgpAsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVrfBgpAsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVrfBgpAsGetRequest {
	return ApiV1DevicesDeviceIdVrfBgpAsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVrfBgpAsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdVrfBgpAsGetExecute(r ApiV1DevicesDeviceIdVrfBgpAsGetRequest) (*V1DevicesDeviceIdVrfBgpAsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVrfBgpAsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVrfBgpAsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/vrf/bgp/as"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVrfProtocolsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVrfProtocolsGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVrfProtocolsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVrfProtocolsGetRequest) Execute() (*V1DevicesDeviceIdVrfProtocolsGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVrfProtocolsGetExecute(r)
}

/*
V1DevicesDeviceIdVrfProtocolsGet Method for V1DevicesDeviceIdVrfProtocolsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdVrfProtocolsGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVrfProtocolsGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVrfProtocolsGetRequest {
	return ApiV1DevicesDeviceIdVrfProtocolsGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVrfProtocolsGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdVrfProtocolsGetExecute(r ApiV1DevicesDeviceIdVrfProtocolsGetRequest) (*V1DevicesDeviceIdVrfProtocolsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVrfProtocolsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVrfProtocolsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/vrf/protocols"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesDeviceIdVrrpGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesDeviceIdVrrpGetRequest) Authorization(authorization string) ApiV1DevicesDeviceIdVrrpGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesDeviceIdVrrpGetRequest) Execute() (*V1DevicesDeviceIdVrrpGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesDeviceIdVrrpGetExecute(r)
}

/*
V1DevicesDeviceIdVrrpGet Method for V1DevicesDeviceIdVrrpGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1DevicesDeviceIdVrrpGetRequest
*/
func (a *DefaultAPIService) V1DevicesDeviceIdVrrpGet(ctx context.Context, deviceId int64) ApiV1DevicesDeviceIdVrrpGetRequest {
	return ApiV1DevicesDeviceIdVrrpGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdVrrpGet200Response
func (a *DefaultAPIService) V1DevicesDeviceIdVrrpGetExecute(r ApiV1DevicesDeviceIdVrrpGetRequest) (*V1DevicesDeviceIdVrrpGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdVrrpGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesDeviceIdVrrpGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/{deviceId}/vrrp"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesGetRequest) Authorization(authorization string) ApiV1DevicesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesGetRequest) Execute() (*V1DevicesDeviceIdEdgesGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesGetExecute(r)
}

/*
V1DevicesGet Method for V1DevicesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesGetRequest
*/
func (a *DefaultAPIService) V1DevicesGet(ctx context.Context) ApiV1DevicesGetRequest {
	return ApiV1DevicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesDeviceIdEdgesGet200Response
func (a *DefaultAPIService) V1DevicesGetExecute(r ApiV1DevicesGetRequest) (*V1DevicesDeviceIdEdgesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesDeviceIdEdgesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryApproveReturnPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryApproveReturnPostRequest *V1DevicesInventoryApproveReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryApproveReturnPostRequest) Authorization(authorization string) ApiV1DevicesInventoryApproveReturnPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryApproveReturnPostRequest) V1DevicesInventoryApproveReturnPostRequest(v1DevicesInventoryApproveReturnPostRequest V1DevicesInventoryApproveReturnPostRequest) ApiV1DevicesInventoryApproveReturnPostRequest {
	r.v1DevicesInventoryApproveReturnPostRequest = &v1DevicesInventoryApproveReturnPostRequest
	return r
}

func (r ApiV1DevicesInventoryApproveReturnPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryApproveReturnPostExecute(r)
}

/*
V1DevicesInventoryApproveReturnPost Method for V1DevicesInventoryApproveReturnPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryApproveReturnPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryApproveReturnPost(ctx context.Context) ApiV1DevicesInventoryApproveReturnPostRequest {
	return ApiV1DevicesInventoryApproveReturnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryApproveReturnPostExecute(r ApiV1DevicesInventoryApproveReturnPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryApproveReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/approve-return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryApproveReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryApproveReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryApproveReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryClearNewFlagPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryClearNewFlagPostRequest) Authorization(authorization string) ApiV1DevicesInventoryClearNewFlagPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryClearNewFlagPostRequest) Body(body map[string]interface{}) ApiV1DevicesInventoryClearNewFlagPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DevicesInventoryClearNewFlagPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryClearNewFlagPostExecute(r)
}

/*
V1DevicesInventoryClearNewFlagPost Method for V1DevicesInventoryClearNewFlagPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryClearNewFlagPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryClearNewFlagPost(ctx context.Context) ApiV1DevicesInventoryClearNewFlagPostRequest {
	return ApiV1DevicesInventoryClearNewFlagPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryClearNewFlagPostExecute(r ApiV1DevicesInventoryClearNewFlagPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryClearNewFlagPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/clear-new-flag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryClearReturnPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryApproveReturnPostRequest *V1DevicesInventoryApproveReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryClearReturnPostRequest) Authorization(authorization string) ApiV1DevicesInventoryClearReturnPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryClearReturnPostRequest) V1DevicesInventoryApproveReturnPostRequest(v1DevicesInventoryApproveReturnPostRequest V1DevicesInventoryApproveReturnPostRequest) ApiV1DevicesInventoryClearReturnPostRequest {
	r.v1DevicesInventoryApproveReturnPostRequest = &v1DevicesInventoryApproveReturnPostRequest
	return r
}

func (r ApiV1DevicesInventoryClearReturnPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryClearReturnPostExecute(r)
}

/*
V1DevicesInventoryClearReturnPost Method for V1DevicesInventoryClearReturnPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryClearReturnPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryClearReturnPost(ctx context.Context) ApiV1DevicesInventoryClearReturnPostRequest {
	return ApiV1DevicesInventoryClearReturnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryClearReturnPostExecute(r ApiV1DevicesInventoryClearReturnPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryClearReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/clear-return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryApproveReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryApproveReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryApproveReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryEnterprisePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryEnterprisePutRequest *V1DevicesInventoryEnterprisePutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryEnterprisePutRequest) Authorization(authorization string) ApiV1DevicesInventoryEnterprisePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryEnterprisePutRequest) V1DevicesInventoryEnterprisePutRequest(v1DevicesInventoryEnterprisePutRequest V1DevicesInventoryEnterprisePutRequest) ApiV1DevicesInventoryEnterprisePutRequest {
	r.v1DevicesInventoryEnterprisePutRequest = &v1DevicesInventoryEnterprisePutRequest
	return r
}

func (r ApiV1DevicesInventoryEnterprisePutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryEnterprisePutExecute(r)
}

/*
V1DevicesInventoryEnterprisePut Method for V1DevicesInventoryEnterprisePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryEnterprisePutRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryEnterprisePut(ctx context.Context) ApiV1DevicesInventoryEnterprisePutRequest {
	return ApiV1DevicesInventoryEnterprisePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryEnterprisePutExecute(r ApiV1DevicesInventoryEnterprisePutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryEnterprisePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryEnterprisePutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryEnterprisePutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryEnterprisePutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryGetRequest) Authorization(authorization string) ApiV1DevicesInventoryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryGetRequest) Execute() (*V1DevicesInventoryGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryGetExecute(r)
}

/*
V1DevicesInventoryGet Method for V1DevicesInventoryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryGetRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryGet(ctx context.Context) ApiV1DevicesInventoryGetRequest {
	return ApiV1DevicesInventoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesInventoryGet200Response
func (a *DefaultAPIService) V1DevicesInventoryGetExecute(r ApiV1DevicesInventoryGetRequest) (*V1DevicesInventoryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesInventoryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryPostRequest *V1DevicesInventoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryPostRequest) Authorization(authorization string) ApiV1DevicesInventoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryPostRequest) V1DevicesInventoryPostRequest(v1DevicesInventoryPostRequest V1DevicesInventoryPostRequest) ApiV1DevicesInventoryPostRequest {
	r.v1DevicesInventoryPostRequest = &v1DevicesInventoryPostRequest
	return r
}

func (r ApiV1DevicesInventoryPostRequest) Execute() (*V1DevicesInventoryPost200Response, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryPostExecute(r)
}

/*
V1DevicesInventoryPost Method for V1DevicesInventoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryPost(ctx context.Context) ApiV1DevicesInventoryPostRequest {
	return ApiV1DevicesInventoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesInventoryPost200Response
func (a *DefaultAPIService) V1DevicesInventoryPostExecute(r ApiV1DevicesInventoryPostRequest) (*V1DevicesInventoryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesInventoryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventoryRequestReturnPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryApproveReturnPostRequest *V1DevicesInventoryApproveReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventoryRequestReturnPostRequest) Authorization(authorization string) ApiV1DevicesInventoryRequestReturnPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventoryRequestReturnPostRequest) V1DevicesInventoryApproveReturnPostRequest(v1DevicesInventoryApproveReturnPostRequest V1DevicesInventoryApproveReturnPostRequest) ApiV1DevicesInventoryRequestReturnPostRequest {
	r.v1DevicesInventoryApproveReturnPostRequest = &v1DevicesInventoryApproveReturnPostRequest
	return r
}

func (r ApiV1DevicesInventoryRequestReturnPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventoryRequestReturnPostExecute(r)
}

/*
V1DevicesInventoryRequestReturnPost Method for V1DevicesInventoryRequestReturnPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventoryRequestReturnPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventoryRequestReturnPost(ctx context.Context) ApiV1DevicesInventoryRequestReturnPostRequest {
	return ApiV1DevicesInventoryRequestReturnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventoryRequestReturnPostExecute(r ApiV1DevicesInventoryRequestReturnPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventoryRequestReturnPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/request-return"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryApproveReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryApproveReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryApproveReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventorySerialNumDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceSerials *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventorySerialNumDeleteRequest) Authorization(authorization string) ApiV1DevicesInventorySerialNumDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1DevicesInventorySerialNumDeleteRequest) DeviceSerials(deviceSerials []string) ApiV1DevicesInventorySerialNumDeleteRequest {
	r.deviceSerials = &deviceSerials
	return r
}

func (r ApiV1DevicesInventorySerialNumDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesInventorySerialNumDeleteExecute(r)
}

/*
V1DevicesInventorySerialNumDelete Method for V1DevicesInventorySerialNumDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventorySerialNumDeleteRequest
*/
func (a *DefaultAPIService) V1DevicesInventorySerialNumDelete(ctx context.Context) ApiV1DevicesInventorySerialNumDeleteRequest {
	return ApiV1DevicesInventorySerialNumDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesInventorySerialNumDeleteExecute(r ApiV1DevicesInventorySerialNumDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventorySerialNumDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/serial-num"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceSerials != nil {
		t := *r.deviceSerials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceSerials", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceSerials", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesInventorySerialNumPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesInventoryApproveReturnPostRequest *V1DevicesInventoryApproveReturnPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesInventorySerialNumPostRequest) Authorization(authorization string) ApiV1DevicesInventorySerialNumPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesInventorySerialNumPostRequest) V1DevicesInventoryApproveReturnPostRequest(v1DevicesInventoryApproveReturnPostRequest V1DevicesInventoryApproveReturnPostRequest) ApiV1DevicesInventorySerialNumPostRequest {
	r.v1DevicesInventoryApproveReturnPostRequest = &v1DevicesInventoryApproveReturnPostRequest
	return r
}

func (r ApiV1DevicesInventorySerialNumPostRequest) Execute() (*V1DevicesInventorySerialNumPost200Response, *http.Response, error) {
	return r.ApiService.V1DevicesInventorySerialNumPostExecute(r)
}

/*
V1DevicesInventorySerialNumPost Method for V1DevicesInventorySerialNumPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesInventorySerialNumPostRequest
*/
func (a *DefaultAPIService) V1DevicesInventorySerialNumPost(ctx context.Context) ApiV1DevicesInventorySerialNumPostRequest {
	return ApiV1DevicesInventorySerialNumPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesInventorySerialNumPost200Response
func (a *DefaultAPIService) V1DevicesInventorySerialNumPostExecute(r ApiV1DevicesInventorySerialNumPostRequest) (*V1DevicesInventorySerialNumPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesInventorySerialNumPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesInventorySerialNumPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/inventory/serial-num"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesInventoryApproveReturnPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesInventoryApproveReturnPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesInventoryApproveReturnPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesOauthRedirectGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesOauthRedirectGetRequest) Authorization(authorization string) ApiV1DevicesOauthRedirectGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesOauthRedirectGetRequest) Execute() (*V1DevicesOauthRedirectGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesOauthRedirectGetExecute(r)
}

/*
V1DevicesOauthRedirectGet Method for V1DevicesOauthRedirectGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesOauthRedirectGetRequest
*/
func (a *DefaultAPIService) V1DevicesOauthRedirectGet(ctx context.Context) ApiV1DevicesOauthRedirectGetRequest {
	return ApiV1DevicesOauthRedirectGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesOauthRedirectGet200Response
func (a *DefaultAPIService) V1DevicesOauthRedirectGetExecute(r ApiV1DevicesOauthRedirectGetRequest) (*V1DevicesOauthRedirectGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesOauthRedirectGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesOauthRedirectGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "//v1/devices/oauth/redirect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesRmaPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesRmaPostRequest *V1DevicesRmaPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesRmaPostRequest) Authorization(authorization string) ApiV1DevicesRmaPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesRmaPostRequest) V1DevicesRmaPostRequest(v1DevicesRmaPostRequest V1DevicesRmaPostRequest) ApiV1DevicesRmaPostRequest {
	r.v1DevicesRmaPostRequest = &v1DevicesRmaPostRequest
	return r
}

func (r ApiV1DevicesRmaPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesRmaPostExecute(r)
}

/*
V1DevicesRmaPost Method for V1DevicesRmaPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesRmaPostRequest
*/
func (a *DefaultAPIService) V1DevicesRmaPost(ctx context.Context) ApiV1DevicesRmaPostRequest {
	return ApiV1DevicesRmaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesRmaPostExecute(r ApiV1DevicesRmaPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesRmaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/rma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesRmaPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesRmaPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesRmaPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId *int64
	protocols *[]string
	vrfName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) Authorization(authorization string) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.authorization = &authorization
	return r
}

// Valid configured device ID &gt; 0
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) DeviceId(deviceId int64) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.deviceId = &deviceId
	return r
}

// List of protocols names for which route count is needed
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) Protocols(protocols []string) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.protocols = &protocols
	return r
}

// Valid configured VRF names
func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) VrfName(vrfName string) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	r.vrfName = &vrfName
	return r
}

func (r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) Execute() (*V1DevicesRoutingVrfProtocolRouteCountGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesRoutingVrfProtocolRouteCountGetExecute(r)
}

/*
V1DevicesRoutingVrfProtocolRouteCountGet Method for V1DevicesRoutingVrfProtocolRouteCountGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest
*/
func (a *DefaultAPIService) V1DevicesRoutingVrfProtocolRouteCountGet(ctx context.Context) ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest {
	return ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesRoutingVrfProtocolRouteCountGet200Response
func (a *DefaultAPIService) V1DevicesRoutingVrfProtocolRouteCountGetExecute(r ApiV1DevicesRoutingVrfProtocolRouteCountGetRequest) (*V1DevicesRoutingVrfProtocolRouteCountGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesRoutingVrfProtocolRouteCountGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesRoutingVrfProtocolRouteCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/routing/vrf/protocol-route-count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.protocols != nil {
		t := *r.protocols
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocols", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocols", t, "form", "multi")
		}
	}
	if r.vrfName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vrfName", r.vrfName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesRunningVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesSessionStatusPostRequest *V1DevicesSessionStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesRunningVersionPostRequest) Authorization(authorization string) ApiV1DevicesRunningVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesRunningVersionPostRequest) V1DevicesSessionStatusPostRequest(v1DevicesSessionStatusPostRequest V1DevicesSessionStatusPostRequest) ApiV1DevicesRunningVersionPostRequest {
	r.v1DevicesSessionStatusPostRequest = &v1DevicesSessionStatusPostRequest
	return r
}

func (r ApiV1DevicesRunningVersionPostRequest) Execute() (*V1DevicesRunningVersionPost200Response, *http.Response, error) {
	return r.ApiService.V1DevicesRunningVersionPostExecute(r)
}

/*
V1DevicesRunningVersionPost Method for V1DevicesRunningVersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesRunningVersionPostRequest
*/
func (a *DefaultAPIService) V1DevicesRunningVersionPost(ctx context.Context) ApiV1DevicesRunningVersionPostRequest {
	return ApiV1DevicesRunningVersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesRunningVersionPost200Response
func (a *DefaultAPIService) V1DevicesRunningVersionPostExecute(r ApiV1DevicesRunningVersionPostRequest) (*V1DevicesRunningVersionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesRunningVersionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesRunningVersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/running/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesSessionStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesSessionStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesSessionStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesSessionStatusPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesSessionStatusPostRequest *V1DevicesSessionStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesSessionStatusPostRequest) Authorization(authorization string) ApiV1DevicesSessionStatusPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesSessionStatusPostRequest) V1DevicesSessionStatusPostRequest(v1DevicesSessionStatusPostRequest V1DevicesSessionStatusPostRequest) ApiV1DevicesSessionStatusPostRequest {
	r.v1DevicesSessionStatusPostRequest = &v1DevicesSessionStatusPostRequest
	return r
}

func (r ApiV1DevicesSessionStatusPostRequest) Execute() (*V1DevicesSessionStatusPost200Response, *http.Response, error) {
	return r.ApiService.V1DevicesSessionStatusPostExecute(r)
}

/*
V1DevicesSessionStatusPost Method for V1DevicesSessionStatusPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesSessionStatusPostRequest
*/
func (a *DefaultAPIService) V1DevicesSessionStatusPost(ctx context.Context) ApiV1DevicesSessionStatusPostRequest {
	return ApiV1DevicesSessionStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesSessionStatusPost200Response
func (a *DefaultAPIService) V1DevicesSessionStatusPostExecute(r ApiV1DevicesSessionStatusPostRequest) (*V1DevicesSessionStatusPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesSessionStatusPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesSessionStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/session-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesSessionStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesSessionStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesSessionStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesSummaryGetRequest) Authorization(authorization string) ApiV1DevicesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesSummaryGetRequest) Execute() (*V1DevicesSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1DevicesSummaryGetExecute(r)
}

/*
V1DevicesSummaryGet Method for V1DevicesSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesSummaryGetRequest
*/
func (a *DefaultAPIService) V1DevicesSummaryGet(ctx context.Context) ApiV1DevicesSummaryGetRequest {
	return ApiV1DevicesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DevicesSummaryGet200Response
func (a *DefaultAPIService) V1DevicesSummaryGetExecute(r ApiV1DevicesSummaryGetRequest) (*V1DevicesSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DevicesSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesUpgradeCancelPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesSessionStatusPostRequest *V1DevicesSessionStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesUpgradeCancelPutRequest) Authorization(authorization string) ApiV1DevicesUpgradeCancelPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesUpgradeCancelPutRequest) V1DevicesSessionStatusPostRequest(v1DevicesSessionStatusPostRequest V1DevicesSessionStatusPostRequest) ApiV1DevicesUpgradeCancelPutRequest {
	r.v1DevicesSessionStatusPostRequest = &v1DevicesSessionStatusPostRequest
	return r
}

func (r ApiV1DevicesUpgradeCancelPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesUpgradeCancelPutExecute(r)
}

/*
V1DevicesUpgradeCancelPut Method for V1DevicesUpgradeCancelPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesUpgradeCancelPutRequest
*/
func (a *DefaultAPIService) V1DevicesUpgradeCancelPut(ctx context.Context) ApiV1DevicesUpgradeCancelPutRequest {
	return ApiV1DevicesUpgradeCancelPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesUpgradeCancelPutExecute(r ApiV1DevicesUpgradeCancelPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesUpgradeCancelPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/upgrade/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesSessionStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesSessionStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesSessionStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DevicesUpgradeSchedulePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesUpgradeSchedulePutRequest *V1DevicesUpgradeSchedulePutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DevicesUpgradeSchedulePutRequest) Authorization(authorization string) ApiV1DevicesUpgradeSchedulePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DevicesUpgradeSchedulePutRequest) V1DevicesUpgradeSchedulePutRequest(v1DevicesUpgradeSchedulePutRequest V1DevicesUpgradeSchedulePutRequest) ApiV1DevicesUpgradeSchedulePutRequest {
	r.v1DevicesUpgradeSchedulePutRequest = &v1DevicesUpgradeSchedulePutRequest
	return r
}

func (r ApiV1DevicesUpgradeSchedulePutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DevicesUpgradeSchedulePutExecute(r)
}

/*
V1DevicesUpgradeSchedulePut Method for V1DevicesUpgradeSchedulePut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DevicesUpgradeSchedulePutRequest
*/
func (a *DefaultAPIService) V1DevicesUpgradeSchedulePut(ctx context.Context) ApiV1DevicesUpgradeSchedulePutRequest {
	return ApiV1DevicesUpgradeSchedulePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DevicesUpgradeSchedulePutExecute(r ApiV1DevicesUpgradeSchedulePutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DevicesUpgradeSchedulePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/devices/upgrade/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesUpgradeSchedulePutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesUpgradeSchedulePutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesUpgradeSchedulePutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchiveCreateDeviceIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticArchiveCreateDeviceIdPostRequest *V1DiagnosticArchiveCreateDeviceIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) Authorization(authorization string) ApiV1DiagnosticArchiveCreateDeviceIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) V1DiagnosticArchiveCreateDeviceIdPostRequest(v1DiagnosticArchiveCreateDeviceIdPostRequest V1DiagnosticArchiveCreateDeviceIdPostRequest) ApiV1DiagnosticArchiveCreateDeviceIdPostRequest {
	r.v1DiagnosticArchiveCreateDeviceIdPostRequest = &v1DiagnosticArchiveCreateDeviceIdPostRequest
	return r
}

func (r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) Execute() (*V1DiagnosticArchiveCreateDeviceIdPost201Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticArchiveCreateDeviceIdPostExecute(r)
}

/*
V1DiagnosticArchiveCreateDeviceIdPost Method for V1DiagnosticArchiveCreateDeviceIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Valid Provisioned device ID
 @return ApiV1DiagnosticArchiveCreateDeviceIdPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchiveCreateDeviceIdPost(ctx context.Context, deviceId int64) ApiV1DiagnosticArchiveCreateDeviceIdPostRequest {
	return ApiV1DiagnosticArchiveCreateDeviceIdPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DiagnosticArchiveCreateDeviceIdPost201Response
func (a *DefaultAPIService) V1DiagnosticArchiveCreateDeviceIdPostExecute(r ApiV1DiagnosticArchiveCreateDeviceIdPostRequest) (*V1DiagnosticArchiveCreateDeviceIdPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticArchiveCreateDeviceIdPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchiveCreateDeviceIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archive-create/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticArchiveCreateDeviceIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticArchiveCreateDeviceIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticArchiveCreateDeviceIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	archiveId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest) Authorization(authorization string) ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticArchiveDeleteArchiveIdDeleteExecute(r)
}

/*
V1DiagnosticArchiveDeleteArchiveIdDelete Method for V1DiagnosticArchiveDeleteArchiveIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param archiveId Unique identifier for a specific archive
 @return ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchiveDeleteArchiveIdDelete(ctx context.Context, archiveId int64) ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest {
	return ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		archiveId: archiveId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticArchiveDeleteArchiveIdDeleteExecute(r ApiV1DiagnosticArchiveDeleteArchiveIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchiveDeleteArchiveIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archive-delete/{archiveId}"
	localVarPath = strings.Replace(localVarPath, "{"+"archiveId"+"}", url.PathEscape(parameterValueToString(r.archiveId, "archiveId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchiveEditArchiveIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	archiveId int64
	v1DiagnosticArchiveCreateDeviceIdPostRequest *V1DiagnosticArchiveCreateDeviceIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) Authorization(authorization string) ApiV1DiagnosticArchiveEditArchiveIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) V1DiagnosticArchiveCreateDeviceIdPostRequest(v1DiagnosticArchiveCreateDeviceIdPostRequest V1DiagnosticArchiveCreateDeviceIdPostRequest) ApiV1DiagnosticArchiveEditArchiveIdPutRequest {
	r.v1DiagnosticArchiveCreateDeviceIdPostRequest = &v1DiagnosticArchiveCreateDeviceIdPostRequest
	return r
}

func (r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticArchiveEditArchiveIdPutExecute(r)
}

/*
V1DiagnosticArchiveEditArchiveIdPut Method for V1DiagnosticArchiveEditArchiveIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param archiveId Unique identifier for a specific archive
 @return ApiV1DiagnosticArchiveEditArchiveIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchiveEditArchiveIdPut(ctx context.Context, archiveId int64) ApiV1DiagnosticArchiveEditArchiveIdPutRequest {
	return ApiV1DiagnosticArchiveEditArchiveIdPutRequest{
		ApiService: a,
		ctx: ctx,
		archiveId: archiveId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticArchiveEditArchiveIdPutExecute(r ApiV1DiagnosticArchiveEditArchiveIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchiveEditArchiveIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archive-edit/{archiveId}"
	localVarPath = strings.Replace(localVarPath, "{"+"archiveId"+"}", url.PathEscape(parameterValueToString(r.archiveId, "archiveId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticArchiveCreateDeviceIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticArchiveCreateDeviceIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticArchiveCreateDeviceIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticArchivesDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticArchivesDeviceIdGetRequest) Authorization(authorization string) ApiV1DiagnosticArchivesDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticArchivesDeviceIdGetRequest) Execute() (*V1DiagnosticArchivesDeviceIdGet200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticArchivesDeviceIdGetExecute(r)
}

/*
V1DiagnosticArchivesDeviceIdGet Method for V1DiagnosticArchivesDeviceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Valid Provisioned device ID
 @return ApiV1DiagnosticArchivesDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticArchivesDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DiagnosticArchivesDeviceIdGetRequest {
	return ApiV1DiagnosticArchivesDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DiagnosticArchivesDeviceIdGet200Response
func (a *DefaultAPIService) V1DiagnosticArchivesDeviceIdGetExecute(r ApiV1DiagnosticArchivesDeviceIdGetRequest) (*V1DiagnosticArchivesDeviceIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticArchivesDeviceIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticArchivesDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/archives/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticBgpResetDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticBgpResetDeviceIdPutRequest *V1DiagnosticBgpResetDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticBgpResetDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticBgpResetDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticBgpResetDeviceIdPutRequest) V1DiagnosticBgpResetDeviceIdPutRequest(v1DiagnosticBgpResetDeviceIdPutRequest V1DiagnosticBgpResetDeviceIdPutRequest) ApiV1DiagnosticBgpResetDeviceIdPutRequest {
	r.v1DiagnosticBgpResetDeviceIdPutRequest = &v1DiagnosticBgpResetDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticBgpResetDeviceIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticBgpResetDeviceIdPutExecute(r)
}

/*
V1DiagnosticBgpResetDeviceIdPut Method for V1DiagnosticBgpResetDeviceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticBgpResetDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticBgpResetDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticBgpResetDeviceIdPutRequest {
	return ApiV1DiagnosticBgpResetDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticBgpResetDeviceIdPutExecute(r ApiV1DiagnosticBgpResetDeviceIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticBgpResetDeviceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/bgp-reset/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticBgpResetDeviceIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticBgpResetDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticBgpResetDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticClearArpDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticClearArpDeviceIdPutRequest *V1DiagnosticClearArpDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticClearArpDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticClearArpDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticClearArpDeviceIdPutRequest) V1DiagnosticClearArpDeviceIdPutRequest(v1DiagnosticClearArpDeviceIdPutRequest V1DiagnosticClearArpDeviceIdPutRequest) ApiV1DiagnosticClearArpDeviceIdPutRequest {
	r.v1DiagnosticClearArpDeviceIdPutRequest = &v1DiagnosticClearArpDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticClearArpDeviceIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticClearArpDeviceIdPutExecute(r)
}

/*
V1DiagnosticClearArpDeviceIdPut Method for V1DiagnosticClearArpDeviceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticClearArpDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticClearArpDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticClearArpDeviceIdPutRequest {
	return ApiV1DiagnosticClearArpDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticClearArpDeviceIdPutExecute(r ApiV1DiagnosticClearArpDeviceIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticClearArpDeviceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/clear-arp/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticClearArpDeviceIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticClearArpDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticClearArpDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticGnmiPingGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticGnmiPingGetRequest) Authorization(authorization string) ApiV1DiagnosticGnmiPingGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticGnmiPingGetRequest) Execute() (*V1DiagnosticGnmiPingGet200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticGnmiPingGetExecute(r)
}

/*
V1DiagnosticGnmiPingGet Method for V1DiagnosticGnmiPingGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticGnmiPingGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticGnmiPingGet(ctx context.Context) ApiV1DiagnosticGnmiPingGetRequest {
	return ApiV1DiagnosticGnmiPingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticGnmiPingGet200Response
func (a *DefaultAPIService) V1DiagnosticGnmiPingGetExecute(r ApiV1DiagnosticGnmiPingGetRequest) (*V1DiagnosticGnmiPingGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticGnmiPingGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticGnmiPingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/gnmi-ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticInterfaceResetDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticInterfaceResetDeviceIdPutRequest *V1DiagnosticInterfaceResetDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticInterfaceResetDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) V1DiagnosticInterfaceResetDeviceIdPutRequest(v1DiagnosticInterfaceResetDeviceIdPutRequest V1DiagnosticInterfaceResetDeviceIdPutRequest) ApiV1DiagnosticInterfaceResetDeviceIdPutRequest {
	r.v1DiagnosticInterfaceResetDeviceIdPutRequest = &v1DiagnosticInterfaceResetDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticInterfaceResetDeviceIdPutExecute(r)
}

/*
V1DiagnosticInterfaceResetDeviceIdPut Method for V1DiagnosticInterfaceResetDeviceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticInterfaceResetDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticInterfaceResetDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticInterfaceResetDeviceIdPutRequest {
	return ApiV1DiagnosticInterfaceResetDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticInterfaceResetDeviceIdPutExecute(r ApiV1DiagnosticInterfaceResetDeviceIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticInterfaceResetDeviceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/interface-reset/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticInterfaceResetDeviceIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticInterfaceResetDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticInterfaceResetDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticOtpDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticOtpDeviceIdGetRequest) Authorization(authorization string) ApiV1DiagnosticOtpDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticOtpDeviceIdGetRequest) Execute() (*V1DiagnosticOtpDeviceIdGet200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticOtpDeviceIdGetExecute(r)
}

/*
V1DiagnosticOtpDeviceIdGet Method for V1DiagnosticOtpDeviceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticOtpDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticOtpDeviceIdGet(ctx context.Context, deviceId int64) ApiV1DiagnosticOtpDeviceIdGetRequest {
	return ApiV1DiagnosticOtpDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1DiagnosticOtpDeviceIdGet200Response
func (a *DefaultAPIService) V1DiagnosticOtpDeviceIdGetExecute(r ApiV1DiagnosticOtpDeviceIdGetRequest) (*V1DiagnosticOtpDeviceIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticOtpDeviceIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticOtpDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/otp/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPacketcapturePcapIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	pcapId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPacketcapturePcapIdGetRequest) Authorization(authorization string) ApiV1DiagnosticPacketcapturePcapIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPacketcapturePcapIdGetRequest) Execute() (*V1DiagnosticPacketcapturePcapIdGet200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticPacketcapturePcapIdGetExecute(r)
}

/*
V1DiagnosticPacketcapturePcapIdGet Method for V1DiagnosticPacketcapturePcapIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pcapId Unique identifier for a specific packet capture
 @return ApiV1DiagnosticPacketcapturePcapIdGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticPacketcapturePcapIdGet(ctx context.Context, pcapId int64) ApiV1DiagnosticPacketcapturePcapIdGetRequest {
	return ApiV1DiagnosticPacketcapturePcapIdGetRequest{
		ApiService: a,
		ctx: ctx,
		pcapId: pcapId,
	}
}

// Execute executes the request
//  @return V1DiagnosticPacketcapturePcapIdGet200Response
func (a *DefaultAPIService) V1DiagnosticPacketcapturePcapIdGetExecute(r ApiV1DiagnosticPacketcapturePcapIdGetRequest) (*V1DiagnosticPacketcapturePcapIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPacketcapturePcapIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPacketcapturePcapIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/packetcapture/{pcapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pcapId"+"}", url.PathEscape(parameterValueToString(r.pcapId, "pcapId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPacketcaptureStartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPacketcaptureStartPostRequest *V1DiagnosticPacketcaptureStartPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPacketcaptureStartPostRequest) Authorization(authorization string) ApiV1DiagnosticPacketcaptureStartPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPacketcaptureStartPostRequest) V1DiagnosticPacketcaptureStartPostRequest(v1DiagnosticPacketcaptureStartPostRequest V1DiagnosticPacketcaptureStartPostRequest) ApiV1DiagnosticPacketcaptureStartPostRequest {
	r.v1DiagnosticPacketcaptureStartPostRequest = &v1DiagnosticPacketcaptureStartPostRequest
	return r
}

func (r ApiV1DiagnosticPacketcaptureStartPostRequest) Execute() (*V1DiagnosticPacketcaptureStartPost201Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticPacketcaptureStartPostExecute(r)
}

/*
V1DiagnosticPacketcaptureStartPost Method for V1DiagnosticPacketcaptureStartPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPacketcaptureStartPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStartPost(ctx context.Context) ApiV1DiagnosticPacketcaptureStartPostRequest {
	return ApiV1DiagnosticPacketcaptureStartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticPacketcaptureStartPost201Response
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStartPostExecute(r ApiV1DiagnosticPacketcaptureStartPostRequest) (*V1DiagnosticPacketcaptureStartPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPacketcaptureStartPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPacketcaptureStartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/packetcapture-start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPacketcaptureStartPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPacketcaptureStartPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPacketcaptureStartPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPacketcaptureStopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPacketcaptureStartPost201Response *V1DiagnosticPacketcaptureStartPost201Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPacketcaptureStopPostRequest) Authorization(authorization string) ApiV1DiagnosticPacketcaptureStopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPacketcaptureStopPostRequest) V1DiagnosticPacketcaptureStartPost201Response(v1DiagnosticPacketcaptureStartPost201Response V1DiagnosticPacketcaptureStartPost201Response) ApiV1DiagnosticPacketcaptureStopPostRequest {
	r.v1DiagnosticPacketcaptureStartPost201Response = &v1DiagnosticPacketcaptureStartPost201Response
	return r
}

func (r ApiV1DiagnosticPacketcaptureStopPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticPacketcaptureStopPostExecute(r)
}

/*
V1DiagnosticPacketcaptureStopPost Method for V1DiagnosticPacketcaptureStopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPacketcaptureStopPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStopPost(ctx context.Context) ApiV1DiagnosticPacketcaptureStopPostRequest {
	return ApiV1DiagnosticPacketcaptureStopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticPacketcaptureStopPostExecute(r ApiV1DiagnosticPacketcaptureStopPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPacketcaptureStopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/packetcapture-stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPacketcaptureStartPost201Response == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPacketcaptureStartPost201Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPacketcaptureStartPost201Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPingPauseResumePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPingPauseResumePostRequest *V1DiagnosticPingPauseResumePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPingPauseResumePostRequest) Authorization(authorization string) ApiV1DiagnosticPingPauseResumePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPingPauseResumePostRequest) V1DiagnosticPingPauseResumePostRequest(v1DiagnosticPingPauseResumePostRequest V1DiagnosticPingPauseResumePostRequest) ApiV1DiagnosticPingPauseResumePostRequest {
	r.v1DiagnosticPingPauseResumePostRequest = &v1DiagnosticPingPauseResumePostRequest
	return r
}

func (r ApiV1DiagnosticPingPauseResumePostRequest) Execute() (*V1DiagnosticPingPauseResumePost204Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticPingPauseResumePostExecute(r)
}

/*
V1DiagnosticPingPauseResumePost Method for V1DiagnosticPingPauseResumePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPingPauseResumePostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPingPauseResumePost(ctx context.Context) ApiV1DiagnosticPingPauseResumePostRequest {
	return ApiV1DiagnosticPingPauseResumePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticPingPauseResumePost204Response
func (a *DefaultAPIService) V1DiagnosticPingPauseResumePostExecute(r ApiV1DiagnosticPingPauseResumePostRequest) (*V1DiagnosticPingPauseResumePost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPingPauseResumePost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPingPauseResumePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/ping-pause-resume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPingPauseResumePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPingPauseResumePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPingPauseResumePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPingPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPingPauseResumePostRequest *V1DiagnosticPingPauseResumePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPingPostRequest) Authorization(authorization string) ApiV1DiagnosticPingPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPingPostRequest) V1DiagnosticPingPauseResumePostRequest(v1DiagnosticPingPauseResumePostRequest V1DiagnosticPingPauseResumePostRequest) ApiV1DiagnosticPingPostRequest {
	r.v1DiagnosticPingPauseResumePostRequest = &v1DiagnosticPingPauseResumePostRequest
	return r
}

func (r ApiV1DiagnosticPingPostRequest) Execute() (*V1DiagnosticPingPauseResumePost204Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticPingPostExecute(r)
}

/*
V1DiagnosticPingPost Method for V1DiagnosticPingPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticPingPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPingPost(ctx context.Context) ApiV1DiagnosticPingPostRequest {
	return ApiV1DiagnosticPingPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticPingPauseResumePost204Response
func (a *DefaultAPIService) V1DiagnosticPingPostExecute(r ApiV1DiagnosticPingPostRequest) (*V1DiagnosticPingPauseResumePost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPingPauseResumePost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPingPauseResumePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPingPauseResumePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPingPauseResumePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticPingStopTokenPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	token string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticPingStopTokenPostRequest) Authorization(authorization string) ApiV1DiagnosticPingStopTokenPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticPingStopTokenPostRequest) Body(body map[string]interface{}) ApiV1DiagnosticPingStopTokenPostRequest {
	r.body = &body
	return r
}

func (r ApiV1DiagnosticPingStopTokenPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticPingStopTokenPostExecute(r)
}

/*
V1DiagnosticPingStopTokenPost Method for V1DiagnosticPingStopTokenPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Identifier which was received in initial response
 @return ApiV1DiagnosticPingStopTokenPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticPingStopTokenPost(ctx context.Context, token string) ApiV1DiagnosticPingStopTokenPostRequest {
	return ApiV1DiagnosticPingStopTokenPostRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticPingStopTokenPostExecute(r ApiV1DiagnosticPingStopTokenPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticPingStopTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/ping-stop/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticRebootDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticRebootDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticRebootDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticRebootDeviceIdPutRequest) Body(body map[string]interface{}) ApiV1DiagnosticRebootDeviceIdPutRequest {
	r.body = &body
	return r
}

func (r ApiV1DiagnosticRebootDeviceIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticRebootDeviceIdPutExecute(r)
}

/*
V1DiagnosticRebootDeviceIdPut Method for V1DiagnosticRebootDeviceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Valid Provisioned device ID
 @return ApiV1DiagnosticRebootDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticRebootDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticRebootDeviceIdPutRequest {
	return ApiV1DiagnosticRebootDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticRebootDeviceIdPutExecute(r ApiV1DiagnosticRebootDeviceIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticRebootDeviceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/reboot/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.deviceId < 0 {
		return localVarReturnValue, nil, reportError("deviceId must be greater than 0")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1DiagnosticResetIpsecSessionDeviceIdPutRequest *V1DiagnosticResetIpsecSessionDeviceIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) Authorization(authorization string) ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) V1DiagnosticResetIpsecSessionDeviceIdPutRequest(v1DiagnosticResetIpsecSessionDeviceIdPutRequest V1DiagnosticResetIpsecSessionDeviceIdPutRequest) ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest {
	r.v1DiagnosticResetIpsecSessionDeviceIdPutRequest = &v1DiagnosticResetIpsecSessionDeviceIdPutRequest
	return r
}

func (r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1DiagnosticResetIpsecSessionDeviceIdPutExecute(r)
}

/*
V1DiagnosticResetIpsecSessionDeviceIdPut Method for V1DiagnosticResetIpsecSessionDeviceIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Unique identifier for a specific device
 @return ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticResetIpsecSessionDeviceIdPut(ctx context.Context, deviceId int64) ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest {
	return ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1DiagnosticResetIpsecSessionDeviceIdPutExecute(r ApiV1DiagnosticResetIpsecSessionDeviceIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticResetIpsecSessionDeviceIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/reset-ipsec-session/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticResetIpsecSessionDeviceIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticResetIpsecSessionDeviceIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticResetIpsecSessionDeviceIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticSpeedtestPostRequest *V1DiagnosticSpeedtestPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestPostRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestPostRequest) V1DiagnosticSpeedtestPostRequest(v1DiagnosticSpeedtestPostRequest V1DiagnosticSpeedtestPostRequest) ApiV1DiagnosticSpeedtestPostRequest {
	r.v1DiagnosticSpeedtestPostRequest = &v1DiagnosticSpeedtestPostRequest
	return r
}

func (r ApiV1DiagnosticSpeedtestPostRequest) Execute() (*V1DiagnosticSpeedtestPost200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestPostExecute(r)
}

/*
V1DiagnosticSpeedtestPost Method for V1DiagnosticSpeedtestPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestPostRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestPost(ctx context.Context) ApiV1DiagnosticSpeedtestPostRequest {
	return ApiV1DiagnosticSpeedtestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestPost200Response
func (a *DefaultAPIService) V1DiagnosticSpeedtestPostExecute(r ApiV1DiagnosticSpeedtestPostRequest) (*V1DiagnosticSpeedtestPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticSpeedtestPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticSpeedtestPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticSpeedtestPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestProvidersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestProvidersGetRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestProvidersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestProvidersGetRequest) Execute() (*V1DiagnosticSpeedtestProvidersGet200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestProvidersGetExecute(r)
}

/*
V1DiagnosticSpeedtestProvidersGet Method for V1DiagnosticSpeedtestProvidersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestProvidersGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestProvidersGet(ctx context.Context) ApiV1DiagnosticSpeedtestProvidersGetRequest {
	return ApiV1DiagnosticSpeedtestProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestProvidersGet200Response
func (a *DefaultAPIService) V1DiagnosticSpeedtestProvidersGetExecute(r ApiV1DiagnosticSpeedtestProvidersGetRequest) (*V1DiagnosticSpeedtestProvidersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestProvidersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest-providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestReportPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticSpeedtestReportPutRequest *V1DiagnosticSpeedtestReportPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestReportPutRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestReportPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestReportPutRequest) V1DiagnosticSpeedtestReportPutRequest(v1DiagnosticSpeedtestReportPutRequest V1DiagnosticSpeedtestReportPutRequest) ApiV1DiagnosticSpeedtestReportPutRequest {
	r.v1DiagnosticSpeedtestReportPutRequest = &v1DiagnosticSpeedtestReportPutRequest
	return r
}

func (r ApiV1DiagnosticSpeedtestReportPutRequest) Execute() (*V1DiagnosticSpeedtestReportPut200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestReportPutExecute(r)
}

/*
V1DiagnosticSpeedtestReportPut Method for V1DiagnosticSpeedtestReportPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestReportPutRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestReportPut(ctx context.Context) ApiV1DiagnosticSpeedtestReportPutRequest {
	return ApiV1DiagnosticSpeedtestReportPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestReportPut200Response
func (a *DefaultAPIService) V1DiagnosticSpeedtestReportPutExecute(r ApiV1DiagnosticSpeedtestReportPutRequest) (*V1DiagnosticSpeedtestReportPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestReportPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestReportPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticSpeedtestReportPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticSpeedtestReportPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticSpeedtestReportPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticSpeedtestServersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticSpeedtestServersGetRequest) Authorization(authorization string) ApiV1DiagnosticSpeedtestServersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticSpeedtestServersGetRequest) Execute() (*V1DiagnosticSpeedtestServersGet200Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticSpeedtestServersGetExecute(r)
}

/*
V1DiagnosticSpeedtestServersGet Method for V1DiagnosticSpeedtestServersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticSpeedtestServersGetRequest
*/
func (a *DefaultAPIService) V1DiagnosticSpeedtestServersGet(ctx context.Context) ApiV1DiagnosticSpeedtestServersGetRequest {
	return ApiV1DiagnosticSpeedtestServersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticSpeedtestServersGet200Response
func (a *DefaultAPIService) V1DiagnosticSpeedtestServersGetExecute(r ApiV1DiagnosticSpeedtestServersGetRequest) (*V1DiagnosticSpeedtestServersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticSpeedtestServersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticSpeedtestServersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/speedtest-servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1DiagnosticTraceroutePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DiagnosticPingPauseResumePostRequest *V1DiagnosticPingPauseResumePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1DiagnosticTraceroutePostRequest) Authorization(authorization string) ApiV1DiagnosticTraceroutePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1DiagnosticTraceroutePostRequest) V1DiagnosticPingPauseResumePostRequest(v1DiagnosticPingPauseResumePostRequest V1DiagnosticPingPauseResumePostRequest) ApiV1DiagnosticTraceroutePostRequest {
	r.v1DiagnosticPingPauseResumePostRequest = &v1DiagnosticPingPauseResumePostRequest
	return r
}

func (r ApiV1DiagnosticTraceroutePostRequest) Execute() (*V1DiagnosticPingPauseResumePost204Response, *http.Response, error) {
	return r.ApiService.V1DiagnosticTraceroutePostExecute(r)
}

/*
V1DiagnosticTraceroutePost Method for V1DiagnosticTraceroutePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1DiagnosticTraceroutePostRequest
*/
func (a *DefaultAPIService) V1DiagnosticTraceroutePost(ctx context.Context) ApiV1DiagnosticTraceroutePostRequest {
	return ApiV1DiagnosticTraceroutePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1DiagnosticPingPauseResumePost204Response
func (a *DefaultAPIService) V1DiagnosticTraceroutePostExecute(r ApiV1DiagnosticTraceroutePostRequest) (*V1DiagnosticPingPauseResumePost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DiagnosticPingPauseResumePost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1DiagnosticTraceroutePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/diagnostic/traceroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DiagnosticPingPauseResumePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DiagnosticPingPauseResumePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DiagnosticPingPauseResumePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesHardwareAssignedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesHardwareAssignedGetRequest) Authorization(authorization string) ApiV1EdgesHardwareAssignedGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesHardwareAssignedGetRequest) Execute() (*V1EdgesHardwareAssignedGet200Response, *http.Response, error) {
	return r.ApiService.V1EdgesHardwareAssignedGetExecute(r)
}

/*
V1EdgesHardwareAssignedGet Method for V1EdgesHardwareAssignedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesHardwareAssignedGetRequest
*/
func (a *DefaultAPIService) V1EdgesHardwareAssignedGet(ctx context.Context) ApiV1EdgesHardwareAssignedGetRequest {
	return ApiV1EdgesHardwareAssignedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesHardwareAssignedGet200Response
func (a *DefaultAPIService) V1EdgesHardwareAssignedGetExecute(r ApiV1EdgesHardwareAssignedGetRequest) (*V1EdgesHardwareAssignedGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesHardwareAssignedGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesHardwareAssignedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-hardware/assigned"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesHardwareUnassignedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesHardwareUnassignedGetRequest) Authorization(authorization string) ApiV1EdgesHardwareUnassignedGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesHardwareUnassignedGetRequest) Execute() (*V1EdgesHardwareUnassignedGet200Response, *http.Response, error) {
	return r.ApiService.V1EdgesHardwareUnassignedGetExecute(r)
}

/*
V1EdgesHardwareUnassignedGet Method for V1EdgesHardwareUnassignedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesHardwareUnassignedGetRequest
*/
func (a *DefaultAPIService) V1EdgesHardwareUnassignedGet(ctx context.Context) ApiV1EdgesHardwareUnassignedGetRequest {
	return ApiV1EdgesHardwareUnassignedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesHardwareUnassignedGet200Response
func (a *DefaultAPIService) V1EdgesHardwareUnassignedGetExecute(r ApiV1EdgesHardwareUnassignedGetRequest) (*V1EdgesHardwareUnassignedGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesHardwareUnassignedGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesHardwareUnassignedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-hardware/unassigned"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EdgesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EdgesSummaryGetRequest) Authorization(authorization string) ApiV1EdgesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EdgesSummaryGetRequest) Execute() (*V1EdgesSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1EdgesSummaryGetExecute(r)
}

/*
V1EdgesSummaryGet Method for V1EdgesSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EdgesSummaryGetRequest
*/
func (a *DefaultAPIService) V1EdgesSummaryGet(ctx context.Context) ApiV1EdgesSummaryGetRequest {
	return ApiV1EdgesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EdgesSummaryGet200Response
func (a *DefaultAPIService) V1EdgesSummaryGetExecute(r ApiV1EdgesSummaryGetRequest) (*V1EdgesSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EdgesSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EdgesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/edges-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseAllocationGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseAllocationGetRequest) Authorization(authorization string) ApiV1EnterpriseAllocationGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseAllocationGetRequest) Execute() (*V1EnterpriseAllocationGet200Response, *http.Response, error) {
	return r.ApiService.V1EnterpriseAllocationGetExecute(r)
}

/*
V1EnterpriseAllocationGet Method for V1EnterpriseAllocationGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseAllocationGetRequest
*/
func (a *DefaultAPIService) V1EnterpriseAllocationGet(ctx context.Context) ApiV1EnterpriseAllocationGetRequest {
	return ApiV1EnterpriseAllocationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterpriseAllocationGet200Response
func (a *DefaultAPIService) V1EnterpriseAllocationGetExecute(r ApiV1EnterpriseAllocationGetRequest) (*V1EnterpriseAllocationGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterpriseAllocationGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseAllocationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/allocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseConfigurationGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseConfigurationGetRequest) Authorization(authorization string) ApiV1EnterpriseConfigurationGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseConfigurationGetRequest) Execute() (*V1EnterpriseConfigurationGet200Response, *http.Response, error) {
	return r.ApiService.V1EnterpriseConfigurationGetExecute(r)
}

/*
V1EnterpriseConfigurationGet Method for V1EnterpriseConfigurationGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseConfigurationGetRequest
*/
func (a *DefaultAPIService) V1EnterpriseConfigurationGet(ctx context.Context) ApiV1EnterpriseConfigurationGetRequest {
	return ApiV1EnterpriseConfigurationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterpriseConfigurationGet200Response
func (a *DefaultAPIService) V1EnterpriseConfigurationGetExecute(r ApiV1EnterpriseConfigurationGetRequest) (*V1EnterpriseConfigurationGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterpriseConfigurationGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseConfigurationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseConfigurationPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterpriseConfigurationGet200Response *V1EnterpriseConfigurationGet200Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseConfigurationPutRequest) Authorization(authorization string) ApiV1EnterpriseConfigurationPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseConfigurationPutRequest) V1EnterpriseConfigurationGet200Response(v1EnterpriseConfigurationGet200Response V1EnterpriseConfigurationGet200Response) ApiV1EnterpriseConfigurationPutRequest {
	r.v1EnterpriseConfigurationGet200Response = &v1EnterpriseConfigurationGet200Response
	return r
}

func (r ApiV1EnterpriseConfigurationPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterpriseConfigurationPutExecute(r)
}

/*
V1EnterpriseConfigurationPut Method for V1EnterpriseConfigurationPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseConfigurationPutRequest
*/
func (a *DefaultAPIService) V1EnterpriseConfigurationPut(ctx context.Context) ApiV1EnterpriseConfigurationPutRequest {
	return ApiV1EnterpriseConfigurationPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterpriseConfigurationPutExecute(r ApiV1EnterpriseConfigurationPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseConfigurationPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterpriseConfigurationGet200Response == nil {
		return localVarReturnValue, nil, reportError("v1EnterpriseConfigurationGet200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterpriseConfigurationGet200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseContractPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterpriseContractPutRequest *V1EnterpriseContractPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseContractPutRequest) Authorization(authorization string) ApiV1EnterpriseContractPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseContractPutRequest) V1EnterpriseContractPutRequest(v1EnterpriseContractPutRequest V1EnterpriseContractPutRequest) ApiV1EnterpriseContractPutRequest {
	r.v1EnterpriseContractPutRequest = &v1EnterpriseContractPutRequest
	return r
}

func (r ApiV1EnterpriseContractPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterpriseContractPutExecute(r)
}

/*
V1EnterpriseContractPut Method for V1EnterpriseContractPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseContractPutRequest
*/
func (a *DefaultAPIService) V1EnterpriseContractPut(ctx context.Context) ApiV1EnterpriseContractPutRequest {
	return ApiV1EnterpriseContractPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterpriseContractPutExecute(r ApiV1EnterpriseContractPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseContractPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/contract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterpriseContractPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1EnterpriseContractPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterpriseContractPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterpriseSnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterpriseSnapshotGetRequest) Authorization(authorization string) ApiV1EnterpriseSnapshotGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterpriseSnapshotGetRequest) Execute() (*V1EnterpriseSnapshotGet200Response, *http.Response, error) {
	return r.ApiService.V1EnterpriseSnapshotGetExecute(r)
}

/*
V1EnterpriseSnapshotGet Method for V1EnterpriseSnapshotGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterpriseSnapshotGetRequest
*/
func (a *DefaultAPIService) V1EnterpriseSnapshotGet(ctx context.Context) ApiV1EnterpriseSnapshotGetRequest {
	return ApiV1EnterpriseSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterpriseSnapshotGet200Response
func (a *DefaultAPIService) V1EnterpriseSnapshotGetExecute(r ApiV1EnterpriseSnapshotGetRequest) (*V1EnterpriseSnapshotGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterpriseSnapshotGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterpriseSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprise/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEnterpriseIdAdminGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEnterpriseIdAdminGetRequest) Authorization(authorization string) ApiV1EnterprisesEnterpriseIdAdminGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEnterpriseIdAdminGetRequest) Execute() (*V1EnterprisesEnterpriseIdAdminGet200Response, *http.Response, error) {
	return r.ApiService.V1EnterprisesEnterpriseIdAdminGetExecute(r)
}

/*
V1EnterprisesEnterpriseIdAdminGet Method for V1EnterprisesEnterpriseIdAdminGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @return ApiV1EnterprisesEnterpriseIdAdminGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdAdminGet(ctx context.Context, enterpriseId int64) ApiV1EnterprisesEnterpriseIdAdminGetRequest {
	return ApiV1EnterprisesEnterpriseIdAdminGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V1EnterprisesEnterpriseIdAdminGet200Response
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdAdminGetExecute(r ApiV1EnterprisesEnterpriseIdAdminGetRequest) (*V1EnterprisesEnterpriseIdAdminGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesEnterpriseIdAdminGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEnterpriseIdAdminGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/{enterpriseId}/admin"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEnterpriseIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEnterpriseIdDeleteRequest) Authorization(authorization string) ApiV1EnterprisesEnterpriseIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEnterpriseIdDeleteRequest) Execute() (*V1AuthPut204Response, *http.Response, error) {
	return r.ApiService.V1EnterprisesEnterpriseIdDeleteExecute(r)
}

/*
V1EnterprisesEnterpriseIdDelete Method for V1EnterprisesEnterpriseIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @return ApiV1EnterprisesEnterpriseIdDeleteRequest
*/
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDelete(ctx context.Context, enterpriseId int64) ApiV1EnterprisesEnterpriseIdDeleteRequest {
	return ApiV1EnterprisesEnterpriseIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V1AuthPut204Response
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDeleteExecute(r ApiV1EnterprisesEnterpriseIdDeleteRequest) (*V1AuthPut204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthPut204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEnterpriseIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/{enterpriseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest) Authorization(authorization string) ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest) Execute() (*V1DeviceStatusPost200Response, *http.Response, error) {
	return r.ApiService.V1EnterprisesEnterpriseIdDeviceStatusGetExecute(r)
}

/*
V1EnterprisesEnterpriseIdDeviceStatusGet Method for V1EnterprisesEnterpriseIdDeviceStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @return ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDeviceStatusGet(ctx context.Context, enterpriseId int64) ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest {
	return ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V1DeviceStatusPost200Response
func (a *DefaultAPIService) V1EnterprisesEnterpriseIdDeviceStatusGetExecute(r ApiV1EnterprisesEnterpriseIdDeviceStatusGetRequest) (*V1DeviceStatusPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceStatusPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEnterpriseIdDeviceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/{enterpriseId}/device-status"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.enterpriseId < 0 {
		return localVarReturnValue, nil, reportError("enterpriseId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesEulaPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesEulaPostRequest) Authorization(authorization string) ApiV1EnterprisesEulaPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesEulaPostRequest) Body(body map[string]interface{}) ApiV1EnterprisesEulaPostRequest {
	r.body = &body
	return r
}

func (r ApiV1EnterprisesEulaPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterprisesEulaPostExecute(r)
}

/*
V1EnterprisesEulaPost Method for V1EnterprisesEulaPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesEulaPostRequest
*/
func (a *DefaultAPIService) V1EnterprisesEulaPost(ctx context.Context) ApiV1EnterprisesEulaPostRequest {
	return ApiV1EnterprisesEulaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterprisesEulaPostExecute(r ApiV1EnterprisesEulaPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesEulaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/eula"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseIds *[]int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesGetRequest) Authorization(authorization string) ApiV1EnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

// Lists enterprises
func (r ApiV1EnterprisesGetRequest) EnterpriseIds(enterpriseIds []int64) ApiV1EnterprisesGetRequest {
	r.enterpriseIds = &enterpriseIds
	return r
}

func (r ApiV1EnterprisesGetRequest) Execute() (*V1EnterprisesGet200Response, *http.Response, error) {
	return r.ApiService.V1EnterprisesGetExecute(r)
}

/*
V1EnterprisesGet Method for V1EnterprisesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesGet(ctx context.Context) ApiV1EnterprisesGetRequest {
	return ApiV1EnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterprisesGet200Response
func (a *DefaultAPIService) V1EnterprisesGetExecute(r ApiV1EnterprisesGetRequest) (*V1EnterprisesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.enterpriseIds != nil {
		t := *r.enterpriseIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enterpriseIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enterpriseIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesManagedGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	type_ *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesManagedGetRequest) Authorization(authorization string) ApiV1EnterprisesManagedGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1EnterprisesManagedGetRequest) Type_(type_ string) ApiV1EnterprisesManagedGetRequest {
	r.type_ = &type_
	return r
}

func (r ApiV1EnterprisesManagedGetRequest) Execute() (*V1EnterprisesManagedGet200Response, *http.Response, error) {
	return r.ApiService.V1EnterprisesManagedGetExecute(r)
}

/*
V1EnterprisesManagedGet Method for V1EnterprisesManagedGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesManagedGetRequest
*/
func (a *DefaultAPIService) V1EnterprisesManagedGet(ctx context.Context) ApiV1EnterprisesManagedGetRequest {
	return ApiV1EnterprisesManagedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EnterprisesManagedGet200Response
func (a *DefaultAPIService) V1EnterprisesManagedGetExecute(r ApiV1EnterprisesManagedGetRequest) (*V1EnterprisesManagedGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesManagedGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesManagedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/managed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterprisesPatchRequest *V1EnterprisesPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesPatchRequest) Authorization(authorization string) ApiV1EnterprisesPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesPatchRequest) V1EnterprisesPatchRequest(v1EnterprisesPatchRequest V1EnterprisesPatchRequest) ApiV1EnterprisesPatchRequest {
	r.v1EnterprisesPatchRequest = &v1EnterprisesPatchRequest
	return r
}

func (r ApiV1EnterprisesPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterprisesPatchExecute(r)
}

/*
V1EnterprisesPatch Method for V1EnterprisesPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesPatchRequest
*/
func (a *DefaultAPIService) V1EnterprisesPatch(ctx context.Context) ApiV1EnterprisesPatchRequest {
	return ApiV1EnterprisesPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterprisesPatchExecute(r ApiV1EnterprisesPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterprisesPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1EnterprisesPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterprisesPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EnterprisesPutRequest *V1EnterprisesPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesPutRequest) Authorization(authorization string) ApiV1EnterprisesPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesPutRequest) V1EnterprisesPutRequest(v1EnterprisesPutRequest V1EnterprisesPutRequest) ApiV1EnterprisesPutRequest {
	r.v1EnterprisesPutRequest = &v1EnterprisesPutRequest
	return r
}

func (r ApiV1EnterprisesPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EnterprisesPutExecute(r)
}

/*
V1EnterprisesPut Method for V1EnterprisesPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesPutRequest
*/
func (a *DefaultAPIService) V1EnterprisesPut(ctx context.Context) ApiV1EnterprisesPutRequest {
	return ApiV1EnterprisesPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EnterprisesPutExecute(r ApiV1EnterprisesPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EnterprisesPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1EnterprisesPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EnterprisesPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EnterprisesSelfDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EnterprisesSelfDeleteRequest) Authorization(authorization string) ApiV1EnterprisesSelfDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EnterprisesSelfDeleteRequest) Execute() (*V1AuthPut204Response, *http.Response, error) {
	return r.ApiService.V1EnterprisesSelfDeleteExecute(r)
}

/*
V1EnterprisesSelfDelete Method for V1EnterprisesSelfDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EnterprisesSelfDeleteRequest
*/
func (a *DefaultAPIService) V1EnterprisesSelfDelete(ctx context.Context) ApiV1EnterprisesSelfDeleteRequest {
	return ApiV1EnterprisesSelfDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1AuthPut204Response
func (a *DefaultAPIService) V1EnterprisesSelfDeleteExecute(r ApiV1EnterprisesSelfDeleteRequest) (*V1AuthPut204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1AuthPut204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EnterprisesSelfDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/enterprises/self"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventDeviceGetRequest) Authorization(authorization string) ApiV1EventDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventDeviceGetRequest) Execute() (*V1EventDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1EventDeviceGetExecute(r)
}

/*
V1EventDeviceGet Method for V1EventDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventDeviceGetRequest
*/
func (a *DefaultAPIService) V1EventDeviceGet(ctx context.Context) ApiV1EventDeviceGetRequest {
	return ApiV1EventDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EventDeviceGet200Response
func (a *DefaultAPIService) V1EventDeviceGetExecute(r ApiV1EventDeviceGetRequest) (*V1EventDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EventDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventEnterpriseGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventEnterpriseGetRequest) Authorization(authorization string) ApiV1EventEnterpriseGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventEnterpriseGetRequest) Execute() (*V1EventDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1EventEnterpriseGetExecute(r)
}

/*
V1EventEnterpriseGet Method for V1EventEnterpriseGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventEnterpriseGetRequest
*/
func (a *DefaultAPIService) V1EventEnterpriseGet(ctx context.Context) ApiV1EventEnterpriseGetRequest {
	return ApiV1EventEnterpriseGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EventDeviceGet200Response
func (a *DefaultAPIService) V1EventEnterpriseGetExecute(r ApiV1EventEnterpriseGetRequest) (*V1EventDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EventDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventEnterpriseGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventSystemAckPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1EventSystemAckPostRequest *V1EventSystemAckPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventSystemAckPostRequest) Authorization(authorization string) ApiV1EventSystemAckPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventSystemAckPostRequest) V1EventSystemAckPostRequest(v1EventSystemAckPostRequest V1EventSystemAckPostRequest) ApiV1EventSystemAckPostRequest {
	r.v1EventSystemAckPostRequest = &v1EventSystemAckPostRequest
	return r
}

func (r ApiV1EventSystemAckPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1EventSystemAckPostExecute(r)
}

/*
V1EventSystemAckPost Method for V1EventSystemAckPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventSystemAckPostRequest
*/
func (a *DefaultAPIService) V1EventSystemAckPost(ctx context.Context) ApiV1EventSystemAckPostRequest {
	return ApiV1EventSystemAckPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1EventSystemAckPostExecute(r ApiV1EventSystemAckPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventSystemAckPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/system/ack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1EventSystemAckPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1EventSystemAckPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1EventSystemAckPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1EventSystemGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1EventSystemGetRequest) Authorization(authorization string) ApiV1EventSystemGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1EventSystemGetRequest) Execute() (*V1EventDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1EventSystemGetExecute(r)
}

/*
V1EventSystemGet Method for V1EventSystemGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1EventSystemGetRequest
*/
func (a *DefaultAPIService) V1EventSystemGet(ctx context.Context) ApiV1EventSystemGetRequest {
	return ApiV1EventSystemGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1EventDeviceGet200Response
func (a *DefaultAPIService) V1EventSystemGetExecute(r ApiV1EventSystemGetRequest) (*V1EventDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EventDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1EventSystemGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetSitesUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetSitesUsagePostRequest *V1ExtranetSitesUsagePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetSitesUsagePostRequest) Authorization(authorization string) ApiV1ExtranetSitesUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetSitesUsagePostRequest) V1ExtranetSitesUsagePostRequest(v1ExtranetSitesUsagePostRequest V1ExtranetSitesUsagePostRequest) ApiV1ExtranetSitesUsagePostRequest {
	r.v1ExtranetSitesUsagePostRequest = &v1ExtranetSitesUsagePostRequest
	return r
}

func (r ApiV1ExtranetSitesUsagePostRequest) Execute() (*V1ExtranetSitesUsagePost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetSitesUsagePostExecute(r)
}

/*
V1ExtranetSitesUsagePost Method for V1ExtranetSitesUsagePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetSitesUsagePostRequest
*/
func (a *DefaultAPIService) V1ExtranetSitesUsagePost(ctx context.Context) ApiV1ExtranetSitesUsagePostRequest {
	return ApiV1ExtranetSitesUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetSitesUsagePost200Response
func (a *DefaultAPIService) V1ExtranetSitesUsagePostExecute(r ApiV1ExtranetSitesUsagePostRequest) (*V1ExtranetSitesUsagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetSitesUsagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetSitesUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet/sites-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetSitesUsagePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetSitesUsagePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetSitesUsagePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetSitesUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetSitesUsageTopPostRequest *V1ExtranetSitesUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetSitesUsageTopPostRequest) Authorization(authorization string) ApiV1ExtranetSitesUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetSitesUsageTopPostRequest) V1ExtranetSitesUsageTopPostRequest(v1ExtranetSitesUsageTopPostRequest V1ExtranetSitesUsageTopPostRequest) ApiV1ExtranetSitesUsageTopPostRequest {
	r.v1ExtranetSitesUsageTopPostRequest = &v1ExtranetSitesUsageTopPostRequest
	return r
}

func (r ApiV1ExtranetSitesUsageTopPostRequest) Execute() (*V1ExtranetSitesUsageTopPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetSitesUsageTopPostExecute(r)
}

/*
V1ExtranetSitesUsageTopPost Method for V1ExtranetSitesUsageTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetSitesUsageTopPostRequest
*/
func (a *DefaultAPIService) V1ExtranetSitesUsageTopPost(ctx context.Context) ApiV1ExtranetSitesUsageTopPostRequest {
	return ApiV1ExtranetSitesUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetSitesUsageTopPost200Response
func (a *DefaultAPIService) V1ExtranetSitesUsageTopPostExecute(r ApiV1ExtranetSitesUsageTopPostRequest) (*V1ExtranetSitesUsageTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetSitesUsageTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetSitesUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranet/sites-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetSitesUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetSitesUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetSitesUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest) Execute() (*V1ExtranetsB2bConsumerDeviceStatusIdGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerDeviceStatusIdGetExecute(r)
}

/*
V1ExtranetsB2bConsumerDeviceStatusIdGet Method for V1ExtranetsB2bConsumerDeviceStatusIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerDeviceStatusIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest {
	return ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerDeviceStatusIdGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bConsumerDeviceStatusIdGetExecute(r ApiV1ExtranetsB2bConsumerDeviceStatusIdGetRequest) (*V1ExtranetsB2bConsumerDeviceStatusIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerDeviceStatusIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerDeviceStatusIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer-device-status/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerIdDeleteExecute(r)
}

/*
V1ExtranetsB2bConsumerIdDelete Method for V1ExtranetsB2bConsumerIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bConsumerIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bConsumerIdDeleteRequest {
	return ApiV1ExtranetsB2bConsumerIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdDeleteExecute(r ApiV1ExtranetsB2bConsumerIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerIdGetRequest) Execute() (*V1ExtranetsB2bConsumerIdGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerIdGetExecute(r)
}

/*
V1ExtranetsB2bConsumerIdGet Method for V1ExtranetsB2bConsumerIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bConsumerIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bConsumerIdGetRequest {
	return ApiV1ExtranetsB2bConsumerIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerIdGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bConsumerIdGetExecute(r ApiV1ExtranetsB2bConsumerIdGetRequest) (*V1ExtranetsB2bConsumerIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bConsumerPostRequest *V1ExtranetsB2bConsumerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerPostRequest) V1ExtranetsB2bConsumerPostRequest(v1ExtranetsB2bConsumerPostRequest V1ExtranetsB2bConsumerPostRequest) ApiV1ExtranetsB2bConsumerPostRequest {
	r.v1ExtranetsB2bConsumerPostRequest = &v1ExtranetsB2bConsumerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bConsumerPostRequest) Execute() (*V1ExtranetsB2bConsumerPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerPostExecute(r)
}

/*
V1ExtranetsB2bConsumerPost Method for V1ExtranetsB2bConsumerPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bConsumerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerPost(ctx context.Context) ApiV1ExtranetsB2bConsumerPostRequest {
	return ApiV1ExtranetsB2bConsumerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerPost200Response
func (a *DefaultAPIService) V1ExtranetsB2bConsumerPostExecute(r ApiV1ExtranetsB2bConsumerPostRequest) (*V1ExtranetsB2bConsumerPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bConsumerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bConsumerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bConsumerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bConsumerSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bConsumerSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bConsumerSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bConsumerSummaryGetRequest) Execute() (*V1ExtranetsB2bConsumerSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bConsumerSummaryGetExecute(r)
}

/*
V1ExtranetsB2bConsumerSummaryGet Method for V1ExtranetsB2bConsumerSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bConsumerSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bConsumerSummaryGet(ctx context.Context) ApiV1ExtranetsB2bConsumerSummaryGetRequest {
	return ApiV1ExtranetsB2bConsumerSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bConsumerSummaryGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bConsumerSummaryGetExecute(r ApiV1ExtranetsB2bConsumerSummaryGetRequest) (*V1ExtranetsB2bConsumerSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bConsumerSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bConsumerSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/consumer-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bCustomerIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bCustomerIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bCustomerIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bCustomerIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bCustomerIdDeleteExecute(r)
}

/*
V1ExtranetsB2bCustomerIdDelete Method for V1ExtranetsB2bCustomerIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bCustomerIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bCustomerIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bCustomerIdDeleteRequest {
	return ApiV1ExtranetsB2bCustomerIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bCustomerIdDeleteExecute(r ApiV1ExtranetsB2bCustomerIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bCustomerIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/customer/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bCustomerInfoIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bCustomerInfoIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bCustomerInfoIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bCustomerInfoIdGetRequest) Execute() (*V1ExtranetsB2bCustomerInfoIdGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bCustomerInfoIdGetExecute(r)
}

/*
V1ExtranetsB2bCustomerInfoIdGet Method for V1ExtranetsB2bCustomerInfoIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bCustomerInfoIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bCustomerInfoIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bCustomerInfoIdGetRequest {
	return ApiV1ExtranetsB2bCustomerInfoIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bCustomerInfoIdGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bCustomerInfoIdGetExecute(r ApiV1ExtranetsB2bCustomerInfoIdGetRequest) (*V1ExtranetsB2bCustomerInfoIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bCustomerInfoIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bCustomerInfoIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/customer-info/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest) Body(body map[string]interface{}) ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest {
	r.body = &body
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdCustomerInviteRetryPostExecute(r)
}

/*
V1ExtranetsB2bIdCustomerInviteRetryPost Method for V1ExtranetsB2bIdCustomerInviteRetryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerInviteRetryPost(ctx context.Context, id int64) ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest {
	return ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerInviteRetryPostExecute(r ApiV1ExtranetsB2bIdCustomerInviteRetryPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdCustomerInviteRetryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/customer-invite/retry/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdCustomerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsB2bIdCustomerPostRequest *V1ExtranetsB2bIdCustomerPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdCustomerPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdCustomerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerPostRequest) V1ExtranetsB2bIdCustomerPostRequest(v1ExtranetsB2bIdCustomerPostRequest V1ExtranetsB2bIdCustomerPostRequest) ApiV1ExtranetsB2bIdCustomerPostRequest {
	r.v1ExtranetsB2bIdCustomerPostRequest = &v1ExtranetsB2bIdCustomerPostRequest
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerPostRequest) Execute() (*V1ExtranetsB2bIdCustomerPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdCustomerPostExecute(r)
}

/*
V1ExtranetsB2bIdCustomerPost Method for V1ExtranetsB2bIdCustomerPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdCustomerPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerPost(ctx context.Context, id int64) ApiV1ExtranetsB2bIdCustomerPostRequest {
	return ApiV1ExtranetsB2bIdCustomerPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bIdCustomerPost200Response
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerPostExecute(r ApiV1ExtranetsB2bIdCustomerPostRequest) (*V1ExtranetsB2bIdCustomerPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bIdCustomerPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdCustomerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/customer/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bIdCustomerPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bIdCustomerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bIdCustomerPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdCustomerSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdCustomerSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdCustomerSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdCustomerSummaryGetRequest) Execute() (*V1ExtranetsB2bIdCustomerSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdCustomerSummaryGetExecute(r)
}

/*
V1ExtranetsB2bIdCustomerSummaryGet Method for V1ExtranetsB2bIdCustomerSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdCustomerSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerSummaryGet(ctx context.Context, id int64) ApiV1ExtranetsB2bIdCustomerSummaryGetRequest {
	return ApiV1ExtranetsB2bIdCustomerSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bIdCustomerSummaryGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bIdCustomerSummaryGetExecute(r ApiV1ExtranetsB2bIdCustomerSummaryGetRequest) (*V1ExtranetsB2bIdCustomerSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bIdCustomerSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdCustomerSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/customer-summary"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdDeleteExecute(r)
}

/*
V1ExtranetsB2bIdDelete Method for V1ExtranetsB2bIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdDelete(ctx context.Context, id int64) ApiV1ExtranetsB2bIdDeleteRequest {
	return ApiV1ExtranetsB2bIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1ExtranetsB2bIdDeleteExecute(r ApiV1ExtranetsB2bIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdProducerGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdProducerGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdProducerGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdProducerGetRequest) Execute() (*V1ExtranetsB2bPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdProducerGetExecute(r)
}

/*
V1ExtranetsB2bIdProducerGet Method for V1ExtranetsB2bIdProducerGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdProducerGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdProducerGet(ctx context.Context, id int64) ApiV1ExtranetsB2bIdProducerGetRequest {
	return ApiV1ExtranetsB2bIdProducerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPost200Response
func (a *DefaultAPIService) V1ExtranetsB2bIdProducerGetExecute(r ApiV1ExtranetsB2bIdProducerGetRequest) (*V1ExtranetsB2bPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdProducerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}/producer"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsB2bIdPutRequest *V1ExtranetsB2bIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bIdPutRequest) Authorization(authorization string) ApiV1ExtranetsB2bIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bIdPutRequest) V1ExtranetsB2bIdPutRequest(v1ExtranetsB2bIdPutRequest V1ExtranetsB2bIdPutRequest) ApiV1ExtranetsB2bIdPutRequest {
	r.v1ExtranetsB2bIdPutRequest = &v1ExtranetsB2bIdPutRequest
	return r
}

func (r ApiV1ExtranetsB2bIdPutRequest) Execute() (*V1ExtranetsB2bPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bIdPutExecute(r)
}

/*
V1ExtranetsB2bIdPut Method for V1ExtranetsB2bIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bIdPutRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bIdPut(ctx context.Context, id int64) ApiV1ExtranetsB2bIdPutRequest {
	return ApiV1ExtranetsB2bIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPost200Response
func (a *DefaultAPIService) V1ExtranetsB2bIdPutExecute(r ApiV1ExtranetsB2bIdPutRequest) (*V1ExtranetsB2bPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsB2bPostRequest *V1ExtranetsB2bPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bPostRequest) Authorization(authorization string) ApiV1ExtranetsB2bPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bPostRequest) V1ExtranetsB2bPostRequest(v1ExtranetsB2bPostRequest V1ExtranetsB2bPostRequest) ApiV1ExtranetsB2bPostRequest {
	r.v1ExtranetsB2bPostRequest = &v1ExtranetsB2bPostRequest
	return r
}

func (r ApiV1ExtranetsB2bPostRequest) Execute() (*V1ExtranetsB2bPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bPostExecute(r)
}

/*
V1ExtranetsB2bPost Method for V1ExtranetsB2bPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bPost(ctx context.Context) ApiV1ExtranetsB2bPostRequest {
	return ApiV1ExtranetsB2bPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bPost200Response
func (a *DefaultAPIService) V1ExtranetsB2bPostExecute(r ApiV1ExtranetsB2bPostRequest) (*V1ExtranetsB2bPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsB2bPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsB2bPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsB2bPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest) Execute() (*V1ExtranetsB2bProducerDeviceStatusIdGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bProducerDeviceStatusIdGetExecute(r)
}

/*
V1ExtranetsB2bProducerDeviceStatusIdGet Method for V1ExtranetsB2bProducerDeviceStatusIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bProducerDeviceStatusIdGet(ctx context.Context, id int64) ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest {
	return ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bProducerDeviceStatusIdGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bProducerDeviceStatusIdGetExecute(r ApiV1ExtranetsB2bProducerDeviceStatusIdGetRequest) (*V1ExtranetsB2bProducerDeviceStatusIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bProducerDeviceStatusIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bProducerDeviceStatusIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/producer-device-status/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsB2bProducersSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsB2bProducersSummaryGetRequest) Authorization(authorization string) ApiV1ExtranetsB2bProducersSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsB2bProducersSummaryGetRequest) Execute() (*V1ExtranetsB2bProducersSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsB2bProducersSummaryGetExecute(r)
}

/*
V1ExtranetsB2bProducersSummaryGet Method for V1ExtranetsB2bProducersSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsB2bProducersSummaryGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsB2bProducersSummaryGet(ctx context.Context) ApiV1ExtranetsB2bProducersSummaryGetRequest {
	return ApiV1ExtranetsB2bProducersSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsB2bProducersSummaryGet200Response
func (a *DefaultAPIService) V1ExtranetsB2bProducersSummaryGetExecute(r ApiV1ExtranetsB2bProducersSummaryGetRequest) (*V1ExtranetsB2bProducersSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsB2bProducersSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsB2bProducersSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-b2b/producers-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsGetRequest) Authorization(authorization string) ApiV1ExtranetsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsGetRequest) Execute() (*V1ExtranetsGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsGetExecute(r)
}

/*
V1ExtranetsGet Method for V1ExtranetsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsGet(ctx context.Context) ApiV1ExtranetsGetRequest {
	return ApiV1ExtranetsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsGet200Response
func (a *DefaultAPIService) V1ExtranetsGetExecute(r ApiV1ExtranetsGetRequest) (*V1ExtranetsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdApplyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsIdApplyPostRequest *V1ExtranetsIdApplyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdApplyPostRequest) Authorization(authorization string) ApiV1ExtranetsIdApplyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdApplyPostRequest) V1ExtranetsIdApplyPostRequest(v1ExtranetsIdApplyPostRequest V1ExtranetsIdApplyPostRequest) ApiV1ExtranetsIdApplyPostRequest {
	r.v1ExtranetsIdApplyPostRequest = &v1ExtranetsIdApplyPostRequest
	return r
}

func (r ApiV1ExtranetsIdApplyPostRequest) Execute() (*V1ExtranetsIdApplyPost202Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdApplyPostExecute(r)
}

/*
V1ExtranetsIdApplyPost Method for V1ExtranetsIdApplyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdApplyPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdApplyPost(ctx context.Context, id int64) ApiV1ExtranetsIdApplyPostRequest {
	return ApiV1ExtranetsIdApplyPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdApplyPost202Response
func (a *DefaultAPIService) V1ExtranetsIdApplyPostExecute(r ApiV1ExtranetsIdApplyPostRequest) (*V1ExtranetsIdApplyPost202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdApplyPost202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdApplyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsIdApplyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsIdApplyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsIdApplyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdDeleteRequest) Authorization(authorization string) ApiV1ExtranetsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdDeleteRequest) Execute() (*V1ExtranetsIdDelete200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdDeleteExecute(r)
}

/*
V1ExtranetsIdDelete Method for V1ExtranetsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdDeleteRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdDelete(ctx context.Context, id int64) ApiV1ExtranetsIdDeleteRequest {
	return ApiV1ExtranetsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdDelete200Response
func (a *DefaultAPIService) V1ExtranetsIdDeleteExecute(r ApiV1ExtranetsIdDeleteRequest) (*V1ExtranetsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdGetRequest) Authorization(authorization string) ApiV1ExtranetsIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdGetRequest) Execute() (*V1ExtranetsPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdGetExecute(r)
}

/*
V1ExtranetsIdGet Method for V1ExtranetsIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdGet(ctx context.Context, id int64) ApiV1ExtranetsIdGetRequest {
	return ApiV1ExtranetsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsPost200Response
func (a *DefaultAPIService) V1ExtranetsIdGetExecute(r ApiV1ExtranetsIdGetRequest) (*V1ExtranetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1ExtranetsPostRequest *V1ExtranetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdPutRequest) Authorization(authorization string) ApiV1ExtranetsIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdPutRequest) V1ExtranetsPostRequest(v1ExtranetsPostRequest V1ExtranetsPostRequest) ApiV1ExtranetsIdPutRequest {
	r.v1ExtranetsPostRequest = &v1ExtranetsPostRequest
	return r
}

func (r ApiV1ExtranetsIdPutRequest) Execute() (*V1ExtranetsPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdPutExecute(r)
}

/*
V1ExtranetsIdPut Method for V1ExtranetsIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdPutRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdPut(ctx context.Context, id int64) ApiV1ExtranetsIdPutRequest {
	return ApiV1ExtranetsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsPost200Response
func (a *DefaultAPIService) V1ExtranetsIdPutExecute(r ApiV1ExtranetsIdPutRequest) (*V1ExtranetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsIdStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsIdStatusGetRequest) Authorization(authorization string) ApiV1ExtranetsIdStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsIdStatusGetRequest) Execute() (*V1ExtranetsIdDelete200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsIdStatusGetExecute(r)
}

/*
V1ExtranetsIdStatusGet Method for V1ExtranetsIdStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1ExtranetsIdStatusGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsIdStatusGet(ctx context.Context, id int64) ApiV1ExtranetsIdStatusGetRequest {
	return ApiV1ExtranetsIdStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1ExtranetsIdDelete200Response
func (a *DefaultAPIService) V1ExtranetsIdStatusGetExecute(r ApiV1ExtranetsIdStatusGetRequest) (*V1ExtranetsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsIdStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsMonitoringLanSegmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsMonitoringLanSegmentsGetRequest) Authorization(authorization string) ApiV1ExtranetsMonitoringLanSegmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsMonitoringLanSegmentsGetRequest) Execute() (*V1ExtranetsMonitoringLanSegmentsGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsMonitoringLanSegmentsGetExecute(r)
}

/*
V1ExtranetsMonitoringLanSegmentsGet Method for V1ExtranetsMonitoringLanSegmentsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsMonitoringLanSegmentsGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsMonitoringLanSegmentsGet(ctx context.Context) ApiV1ExtranetsMonitoringLanSegmentsGetRequest {
	return ApiV1ExtranetsMonitoringLanSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsMonitoringLanSegmentsGet200Response
func (a *DefaultAPIService) V1ExtranetsMonitoringLanSegmentsGetExecute(r ApiV1ExtranetsMonitoringLanSegmentsGetRequest) (*V1ExtranetsMonitoringLanSegmentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsMonitoringLanSegmentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsMonitoringLanSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-monitoring/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsMonitoringNatUsageGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsMonitoringNatUsageGetRequest) Authorization(authorization string) ApiV1ExtranetsMonitoringNatUsageGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsMonitoringNatUsageGetRequest) Execute() (*V1ExtranetsMonitoringNatUsageGet200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsMonitoringNatUsageGetExecute(r)
}

/*
V1ExtranetsMonitoringNatUsageGet Method for V1ExtranetsMonitoringNatUsageGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsMonitoringNatUsageGetRequest
*/
func (a *DefaultAPIService) V1ExtranetsMonitoringNatUsageGet(ctx context.Context) ApiV1ExtranetsMonitoringNatUsageGetRequest {
	return ApiV1ExtranetsMonitoringNatUsageGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsMonitoringNatUsageGet200Response
func (a *DefaultAPIService) V1ExtranetsMonitoringNatUsageGetExecute(r ApiV1ExtranetsMonitoringNatUsageGetRequest) (*V1ExtranetsMonitoringNatUsageGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsMonitoringNatUsageGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsMonitoringNatUsageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-monitoring/nat-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest *V1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) Authorization(authorization string) ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) V1ExtranetsMonitoringTrafficSecurityPolicyPostRequest(v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest V1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest {
	r.v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest = &v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
	return r
}

func (r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) Execute() (*V1ExtranetsMonitoringTrafficSecurityPolicyPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsMonitoringTrafficSecurityPolicyPostExecute(r)
}

/*
V1ExtranetsMonitoringTrafficSecurityPolicyPost Method for V1ExtranetsMonitoringTrafficSecurityPolicyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsMonitoringTrafficSecurityPolicyPost(ctx context.Context) ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest {
	return ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsMonitoringTrafficSecurityPolicyPost200Response
func (a *DefaultAPIService) V1ExtranetsMonitoringTrafficSecurityPolicyPostExecute(r ApiV1ExtranetsMonitoringTrafficSecurityPolicyPostRequest) (*V1ExtranetsMonitoringTrafficSecurityPolicyPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsMonitoringTrafficSecurityPolicyPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsMonitoringTrafficSecurityPolicyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets-monitoring/traffic-security-policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsMonitoringTrafficSecurityPolicyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsPostRequest *V1ExtranetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsPostRequest) Authorization(authorization string) ApiV1ExtranetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsPostRequest) V1ExtranetsPostRequest(v1ExtranetsPostRequest V1ExtranetsPostRequest) ApiV1ExtranetsPostRequest {
	r.v1ExtranetsPostRequest = &v1ExtranetsPostRequest
	return r
}

func (r ApiV1ExtranetsPostRequest) Execute() (*V1ExtranetsPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsPostExecute(r)
}

/*
V1ExtranetsPost Method for V1ExtranetsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsPost(ctx context.Context) ApiV1ExtranetsPostRequest {
	return ApiV1ExtranetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsPost200Response
func (a *DefaultAPIService) V1ExtranetsPostExecute(r ApiV1ExtranetsPostRequest) (*V1ExtranetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsResolvePolicyTargetPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsResolvePolicyTargetPostRequest *V1ExtranetsResolvePolicyTargetPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsResolvePolicyTargetPostRequest) Authorization(authorization string) ApiV1ExtranetsResolvePolicyTargetPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsResolvePolicyTargetPostRequest) V1ExtranetsResolvePolicyTargetPostRequest(v1ExtranetsResolvePolicyTargetPostRequest V1ExtranetsResolvePolicyTargetPostRequest) ApiV1ExtranetsResolvePolicyTargetPostRequest {
	r.v1ExtranetsResolvePolicyTargetPostRequest = &v1ExtranetsResolvePolicyTargetPostRequest
	return r
}

func (r ApiV1ExtranetsResolvePolicyTargetPostRequest) Execute() (*V1ExtranetsResolvePolicyTargetPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsResolvePolicyTargetPostExecute(r)
}

/*
V1ExtranetsResolvePolicyTargetPost Method for V1ExtranetsResolvePolicyTargetPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsResolvePolicyTargetPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsResolvePolicyTargetPost(ctx context.Context) ApiV1ExtranetsResolvePolicyTargetPostRequest {
	return ApiV1ExtranetsResolvePolicyTargetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsResolvePolicyTargetPost200Response
func (a *DefaultAPIService) V1ExtranetsResolvePolicyTargetPostExecute(r ApiV1ExtranetsResolvePolicyTargetPostRequest) (*V1ExtranetsResolvePolicyTargetPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsResolvePolicyTargetPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsResolvePolicyTargetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/resolve-policy-target"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsResolvePolicyTargetPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsResolvePolicyTargetPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsResolvePolicyTargetPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ExtranetsSourceSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetsSourceSegmentsPostRequest *V1ExtranetsSourceSegmentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ExtranetsSourceSegmentsPostRequest) Authorization(authorization string) ApiV1ExtranetsSourceSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ExtranetsSourceSegmentsPostRequest) V1ExtranetsSourceSegmentsPostRequest(v1ExtranetsSourceSegmentsPostRequest V1ExtranetsSourceSegmentsPostRequest) ApiV1ExtranetsSourceSegmentsPostRequest {
	r.v1ExtranetsSourceSegmentsPostRequest = &v1ExtranetsSourceSegmentsPostRequest
	return r
}

func (r ApiV1ExtranetsSourceSegmentsPostRequest) Execute() (*V1ExtranetsSourceSegmentsPost200Response, *http.Response, error) {
	return r.ApiService.V1ExtranetsSourceSegmentsPostExecute(r)
}

/*
V1ExtranetsSourceSegmentsPost Method for V1ExtranetsSourceSegmentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ExtranetsSourceSegmentsPostRequest
*/
func (a *DefaultAPIService) V1ExtranetsSourceSegmentsPost(ctx context.Context) ApiV1ExtranetsSourceSegmentsPostRequest {
	return ApiV1ExtranetsSourceSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetsSourceSegmentsPost200Response
func (a *DefaultAPIService) V1ExtranetsSourceSegmentsPostExecute(r ApiV1ExtranetsSourceSegmentsPostRequest) (*V1ExtranetsSourceSegmentsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetsSourceSegmentsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ExtranetsSourceSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/extranets/source-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetsSourceSegmentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetsSourceSegmentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetsSourceSegmentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1FlowsFlowTablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1FlowsFlowTablePostRequest *V1FlowsFlowTablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1FlowsFlowTablePostRequest) Authorization(authorization string) ApiV1FlowsFlowTablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1FlowsFlowTablePostRequest) V1FlowsFlowTablePostRequest(v1FlowsFlowTablePostRequest V1FlowsFlowTablePostRequest) ApiV1FlowsFlowTablePostRequest {
	r.v1FlowsFlowTablePostRequest = &v1FlowsFlowTablePostRequest
	return r
}

func (r ApiV1FlowsFlowTablePostRequest) Execute() (*V1FlowsFlowTablePost200Response, *http.Response, error) {
	return r.ApiService.V1FlowsFlowTablePostExecute(r)
}

/*
V1FlowsFlowTablePost Method for V1FlowsFlowTablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1FlowsFlowTablePostRequest
*/
func (a *DefaultAPIService) V1FlowsFlowTablePost(ctx context.Context) ApiV1FlowsFlowTablePostRequest {
	return ApiV1FlowsFlowTablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1FlowsFlowTablePost200Response
func (a *DefaultAPIService) V1FlowsFlowTablePostExecute(r ApiV1FlowsFlowTablePostRequest) (*V1FlowsFlowTablePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1FlowsFlowTablePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1FlowsFlowTablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/flows/flow-table"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1FlowsFlowTablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1FlowsFlowTablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1FlowsFlowTablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1FlowsTopologyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1FlowsTopologyPostRequest *V1FlowsTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1FlowsTopologyPostRequest) Authorization(authorization string) ApiV1FlowsTopologyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1FlowsTopologyPostRequest) V1FlowsTopologyPostRequest(v1FlowsTopologyPostRequest V1FlowsTopologyPostRequest) ApiV1FlowsTopologyPostRequest {
	r.v1FlowsTopologyPostRequest = &v1FlowsTopologyPostRequest
	return r
}

func (r ApiV1FlowsTopologyPostRequest) Execute() (*V1FlowsTopologyPost200Response, *http.Response, error) {
	return r.ApiService.V1FlowsTopologyPostExecute(r)
}

/*
V1FlowsTopologyPost Method for V1FlowsTopologyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1FlowsTopologyPostRequest
*/
func (a *DefaultAPIService) V1FlowsTopologyPost(ctx context.Context) ApiV1FlowsTopologyPostRequest {
	return ApiV1FlowsTopologyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1FlowsTopologyPost200Response
func (a *DefaultAPIService) V1FlowsTopologyPostExecute(r ApiV1FlowsTopologyPostRequest) (*V1FlowsTopologyPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1FlowsTopologyPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1FlowsTopologyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/flows/topology"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1FlowsTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1FlowsTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1FlowsTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysDeleteRequest) Authorization(authorization string) ApiV1GatewaysDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1GatewaysDeleteRequest) Id(id int64) ApiV1GatewaysDeleteRequest {
	r.id = &id
	return r
}

func (r ApiV1GatewaysDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GatewaysDeleteExecute(r)
}

/*
V1GatewaysDelete Method for V1GatewaysDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysDeleteRequest
*/
func (a *DefaultAPIService) V1GatewaysDelete(ctx context.Context) ApiV1GatewaysDeleteRequest {
	return ApiV1GatewaysDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GatewaysDeleteExecute(r ApiV1GatewaysDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysIdDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysIdDetailsGetRequest) Authorization(authorization string) ApiV1GatewaysIdDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysIdDetailsGetRequest) Execute() (*V1GatewaysPostRequest, *http.Response, error) {
	return r.ApiService.V1GatewaysIdDetailsGetExecute(r)
}

/*
V1GatewaysIdDetailsGet Method for V1GatewaysIdDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GatewaysIdDetailsGetRequest
*/
func (a *DefaultAPIService) V1GatewaysIdDetailsGet(ctx context.Context, id int64) ApiV1GatewaysIdDetailsGetRequest {
	return ApiV1GatewaysIdDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GatewaysPostRequest
func (a *DefaultAPIService) V1GatewaysIdDetailsGetExecute(r ApiV1GatewaysIdDetailsGetRequest) (*V1GatewaysPostRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysPostRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysIdDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/{id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	regionId int32
	vrfId int64
	addressFamily *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) Authorization(authorization string) ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) AddressFamily(addressFamily string) ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest {
	r.addressFamily = &addressFamily
	return r
}

func (r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) Execute() (*V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet200Response, *http.Response, error) {
	return r.ApiService.V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetExecute(r)
}

/*
V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet Method for V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param regionId 
 @param vrfId 
 @return ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest
*/
func (a *DefaultAPIService) V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet(ctx context.Context, regionId int32, vrfId int64) ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest {
	return ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest{
		ApiService: a,
		ctx: ctx,
		regionId: regionId,
		vrfId: vrfId,
	}
}

// Execute executes the request
//  @return V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet200Response
func (a *DefaultAPIService) V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetExecute(r ApiV1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGetRequest) (*V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysIpsecRegionsRegionIdVrfsVrfIdInsideSubnetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/ipsec/regions/{regionId}/vrfs/{vrfId}/inside-subnet"
	localVarPath = strings.Replace(localVarPath, "{"+"regionId"+"}", url.PathEscape(parameterValueToString(r.regionId, "regionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vrfId"+"}", url.PathEscape(parameterValueToString(r.vrfId, "vrfId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.addressFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressFamily", r.addressFamily, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GatewaysPostRequest *V1GatewaysPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysPostRequest) Authorization(authorization string) ApiV1GatewaysPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysPostRequest) V1GatewaysPostRequest(v1GatewaysPostRequest V1GatewaysPostRequest) ApiV1GatewaysPostRequest {
	r.v1GatewaysPostRequest = &v1GatewaysPostRequest
	return r
}

func (r ApiV1GatewaysPostRequest) Execute() (*V1GatewaysPost200Response, *http.Response, error) {
	return r.ApiService.V1GatewaysPostExecute(r)
}

/*
V1GatewaysPost Method for V1GatewaysPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysPostRequest
*/
func (a *DefaultAPIService) V1GatewaysPost(ctx context.Context) ApiV1GatewaysPostRequest {
	return ApiV1GatewaysPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysPost200Response
func (a *DefaultAPIService) V1GatewaysPostExecute(r ApiV1GatewaysPostRequest) (*V1GatewaysPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GatewaysPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GatewaysPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GatewaysPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GatewaysPutRequest *V1GatewaysPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysPutRequest) Authorization(authorization string) ApiV1GatewaysPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysPutRequest) V1GatewaysPutRequest(v1GatewaysPutRequest V1GatewaysPutRequest) ApiV1GatewaysPutRequest {
	r.v1GatewaysPutRequest = &v1GatewaysPutRequest
	return r
}

func (r ApiV1GatewaysPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GatewaysPutExecute(r)
}

/*
V1GatewaysPut Method for V1GatewaysPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysPutRequest
*/
func (a *DefaultAPIService) V1GatewaysPut(ctx context.Context) ApiV1GatewaysPutRequest {
	return ApiV1GatewaysPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GatewaysPutExecute(r ApiV1GatewaysPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GatewaysPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1GatewaysPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GatewaysPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysRegionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysRegionsGetRequest) Authorization(authorization string) ApiV1GatewaysRegionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysRegionsGetRequest) Execute() (*V1GatewaysRegionsGet200Response, *http.Response, error) {
	return r.ApiService.V1GatewaysRegionsGetExecute(r)
}

/*
V1GatewaysRegionsGet Method for V1GatewaysRegionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysRegionsGetRequest
*/
func (a *DefaultAPIService) V1GatewaysRegionsGet(ctx context.Context) ApiV1GatewaysRegionsGetRequest {
	return ApiV1GatewaysRegionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysRegionsGet200Response
func (a *DefaultAPIService) V1GatewaysRegionsGetExecute(r ApiV1GatewaysRegionsGetRequest) (*V1GatewaysRegionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysRegionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysRegionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysStatusPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GatewaysStatusPostRequest *V1GatewaysStatusPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysStatusPostRequest) Authorization(authorization string) ApiV1GatewaysStatusPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysStatusPostRequest) V1GatewaysStatusPostRequest(v1GatewaysStatusPostRequest V1GatewaysStatusPostRequest) ApiV1GatewaysStatusPostRequest {
	r.v1GatewaysStatusPostRequest = &v1GatewaysStatusPostRequest
	return r
}

func (r ApiV1GatewaysStatusPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GatewaysStatusPostExecute(r)
}

/*
V1GatewaysStatusPost Method for V1GatewaysStatusPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysStatusPostRequest
*/
func (a *DefaultAPIService) V1GatewaysStatusPost(ctx context.Context) ApiV1GatewaysStatusPostRequest {
	return ApiV1GatewaysStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GatewaysStatusPostExecute(r ApiV1GatewaysStatusPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GatewaysStatusPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GatewaysStatusPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GatewaysStatusPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GatewaysSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GatewaysSummaryGetRequest) Authorization(authorization string) ApiV1GatewaysSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GatewaysSummaryGetRequest) Execute() (*V1GatewaysSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1GatewaysSummaryGetExecute(r)
}

/*
V1GatewaysSummaryGet Method for V1GatewaysSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GatewaysSummaryGetRequest
*/
func (a *DefaultAPIService) V1GatewaysSummaryGet(ctx context.Context) ApiV1GatewaysSummaryGetRequest {
	return ApiV1GatewaysSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysSummaryGet200Response
func (a *DefaultAPIService) V1GatewaysSummaryGetExecute(r ApiV1GatewaysSummaryGetRequest) (*V1GatewaysSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GatewaysSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gateways/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListOptionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListOptionsGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListOptionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListOptionsGetRequest) Execute() (*V1GlobalAppsAppListOptionsGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListOptionsGetExecute(r)
}

/*
V1GlobalAppsAppListOptionsGet Method for V1GlobalAppsAppListOptionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsAppListOptionsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListOptionsGet(ctx context.Context) ApiV1GlobalAppsAppListOptionsGetRequest {
	return ApiV1GlobalAppsAppListOptionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListOptionsGet200Response
func (a *DefaultAPIService) V1GlobalAppsAppListOptionsGetExecute(r ApiV1GlobalAppsAppListOptionsGetRequest) (*V1GlobalAppsAppListOptionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListOptionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListOptionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-list-options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdDeleteRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdDeleteExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdDelete Method for V1GlobalAppsAppListsAppListIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDelete(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdDeleteRequest {
	return ApiV1GlobalAppsAppListsAppListIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDeleteExecute(r ApiV1GlobalAppsAppListsAppListIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest) Execute() (*V1GlobalAppsAppListOptionsGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdDetailsAppsGetExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdDetailsAppsGet Method for V1GlobalAppsAppListsAppListIdDetailsAppsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDetailsAppsGet(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest {
	return ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListOptionsGet200Response
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdDetailsAppsGetExecute(r ApiV1GlobalAppsAppListsAppListIdDetailsAppsGetRequest) (*V1GlobalAppsAppListOptionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListOptionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdDetailsAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}/details/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdGetRequest) Execute() (*V1GlobalAppsAppListsPostRequest, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdGetExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdGet Method for V1GlobalAppsAppListsAppListIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdGet(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdGetRequest {
	return ApiV1GlobalAppsAppListsAppListIdGetRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsPostRequest
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdGetExecute(r ApiV1GlobalAppsAppListsAppListIdGetRequest) (*V1GlobalAppsAppListsPostRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsPostRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsAppListIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appListId int64
	v1GlobalAppsAppListsPostRequest *V1GlobalAppsAppListsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsAppListIdPutRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsAppListIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdPutRequest) V1GlobalAppsAppListsPostRequest(v1GlobalAppsAppListsPostRequest V1GlobalAppsAppListsPostRequest) ApiV1GlobalAppsAppListsAppListIdPutRequest {
	r.v1GlobalAppsAppListsPostRequest = &v1GlobalAppsAppListsPostRequest
	return r
}

func (r ApiV1GlobalAppsAppListsAppListIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsAppListIdPutExecute(r)
}

/*
V1GlobalAppsAppListsAppListIdPut Method for V1GlobalAppsAppListsAppListIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appListId 
 @return ApiV1GlobalAppsAppListsAppListIdPutRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdPut(ctx context.Context, appListId int64) ApiV1GlobalAppsAppListsAppListIdPutRequest {
	return ApiV1GlobalAppsAppListsAppListIdPutRequest{
		ApiService: a,
		ctx: ctx,
		appListId: appListId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsAppListsAppListIdPutExecute(r ApiV1GlobalAppsAppListsAppListIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsAppListIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists/{appListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appListId"+"}", url.PathEscape(parameterValueToString(r.appListId, "appListId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsAppListsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsAppListsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsAppListsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsGetRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsGetRequest) Execute() (*V1GlobalAppsAppListsGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsGetExecute(r)
}

/*
V1GlobalAppsAppListsGet Method for V1GlobalAppsAppListsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsAppListsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsGet(ctx context.Context) ApiV1GlobalAppsAppListsGetRequest {
	return ApiV1GlobalAppsAppListsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsGet200Response
func (a *DefaultAPIService) V1GlobalAppsAppListsGetExecute(r ApiV1GlobalAppsAppListsGetRequest) (*V1GlobalAppsAppListsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsAppListsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalAppsAppListsPostRequest *V1GlobalAppsAppListsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsAppListsPostRequest) Authorization(authorization string) ApiV1GlobalAppsAppListsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsAppListsPostRequest) V1GlobalAppsAppListsPostRequest(v1GlobalAppsAppListsPostRequest V1GlobalAppsAppListsPostRequest) ApiV1GlobalAppsAppListsPostRequest {
	r.v1GlobalAppsAppListsPostRequest = &v1GlobalAppsAppListsPostRequest
	return r
}

func (r ApiV1GlobalAppsAppListsPostRequest) Execute() (*V1GlobalAppsAppListsPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsAppListsPostExecute(r)
}

/*
V1GlobalAppsAppListsPost Method for V1GlobalAppsAppListsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsAppListsPostRequest
*/
func (a *DefaultAPIService) V1GlobalAppsAppListsPost(ctx context.Context) ApiV1GlobalAppsAppListsPostRequest {
	return ApiV1GlobalAppsAppListsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsPost200Response
func (a *DefaultAPIService) V1GlobalAppsAppListsPostExecute(r ApiV1GlobalAppsAppListsPostRequest) (*V1GlobalAppsAppListsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsAppListsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/app-lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsAppListsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsAppListsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsAppListsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	categoryId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest) Authorization(authorization string) ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest) Execute() (*V1GlobalAppsAppListOptionsGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCategoriesCategoryIdAppsGetExecute(r)
}

/*
V1GlobalAppsCategoriesCategoryIdAppsGet Method for V1GlobalAppsCategoriesCategoryIdAppsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryId 
 @return ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCategoriesCategoryIdAppsGet(ctx context.Context, categoryId int64) ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest {
	return ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest{
		ApiService: a,
		ctx: ctx,
		categoryId: categoryId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListOptionsGet200Response
func (a *DefaultAPIService) V1GlobalAppsCategoriesCategoryIdAppsGetExecute(r ApiV1GlobalAppsCategoriesCategoryIdAppsGetRequest) (*V1GlobalAppsAppListOptionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListOptionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCategoriesCategoryIdAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/categories/{categoryId}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"categoryId"+"}", url.PathEscape(parameterValueToString(r.categoryId, "categoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCategoriesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCategoriesGetRequest) Authorization(authorization string) ApiV1GlobalAppsCategoriesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCategoriesGetRequest) Execute() (*V1GlobalAppsCategoriesGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCategoriesGetExecute(r)
}

/*
V1GlobalAppsCategoriesGet Method for V1GlobalAppsCategoriesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsCategoriesGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCategoriesGet(ctx context.Context) ApiV1GlobalAppsCategoriesGetRequest {
	return ApiV1GlobalAppsCategoriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCategoriesGet200Response
func (a *DefaultAPIService) V1GlobalAppsCategoriesGetExecute(r ApiV1GlobalAppsCategoriesGetRequest) (*V1GlobalAppsCategoriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCategoriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCategoriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdDeleteRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdDeleteExecute(r)
}

/*
V1GlobalAppsCustomAppIdDelete Method for V1GlobalAppsCustomAppIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDelete(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdDeleteRequest {
	return ApiV1GlobalAppsCustomAppIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDeleteExecute(r ApiV1GlobalAppsCustomAppIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest) Execute() (*V1GlobalAppsCustomAppIdDetailsAppListsGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdDetailsAppListsGetExecute(r)
}

/*
V1GlobalAppsCustomAppIdDetailsAppListsGet Method for V1GlobalAppsCustomAppIdDetailsAppListsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDetailsAppListsGet(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest {
	return ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomAppIdDetailsAppListsGet200Response
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdDetailsAppListsGetExecute(r ApiV1GlobalAppsCustomAppIdDetailsAppListsGetRequest) (*V1GlobalAppsCustomAppIdDetailsAppListsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomAppIdDetailsAppListsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdDetailsAppListsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}/details/app-lists"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdGetRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdGetRequest) Execute() (*V1GlobalAppsCustomPostRequest, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdGetExecute(r)
}

/*
V1GlobalAppsCustomAppIdGet Method for V1GlobalAppsCustomAppIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdGet(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdGetRequest {
	return ApiV1GlobalAppsCustomAppIdGetRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomPostRequest
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdGetExecute(r ApiV1GlobalAppsCustomAppIdGetRequest) (*V1GlobalAppsCustomPostRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomPostRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomAppIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	appId int64
	v1GlobalAppsCustomPostRequest *V1GlobalAppsCustomPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomAppIdPutRequest) Authorization(authorization string) ApiV1GlobalAppsCustomAppIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomAppIdPutRequest) V1GlobalAppsCustomPostRequest(v1GlobalAppsCustomPostRequest V1GlobalAppsCustomPostRequest) ApiV1GlobalAppsCustomAppIdPutRequest {
	r.v1GlobalAppsCustomPostRequest = &v1GlobalAppsCustomPostRequest
	return r
}

func (r ApiV1GlobalAppsCustomAppIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomAppIdPutExecute(r)
}

/*
V1GlobalAppsCustomAppIdPut Method for V1GlobalAppsCustomAppIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId 
 @return ApiV1GlobalAppsCustomAppIdPutRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdPut(ctx context.Context, appId int64) ApiV1GlobalAppsCustomAppIdPutRequest {
	return ApiV1GlobalAppsCustomAppIdPutRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalAppsCustomAppIdPutExecute(r ApiV1GlobalAppsCustomAppIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomAppIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsCustomPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsCustomPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsCustomPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomGetRequest) Authorization(authorization string) ApiV1GlobalAppsCustomGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomGetRequest) Execute() (*V1GlobalAppsCustomGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomGetExecute(r)
}

/*
V1GlobalAppsCustomGet Method for V1GlobalAppsCustomGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsCustomGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomGet(ctx context.Context) ApiV1GlobalAppsCustomGetRequest {
	return ApiV1GlobalAppsCustomGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsCustomGet200Response
func (a *DefaultAPIService) V1GlobalAppsCustomGetExecute(r ApiV1GlobalAppsCustomGetRequest) (*V1GlobalAppsCustomGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsCustomGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsCustomPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalAppsCustomPostRequest *V1GlobalAppsCustomPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsCustomPostRequest) Authorization(authorization string) ApiV1GlobalAppsCustomPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsCustomPostRequest) V1GlobalAppsCustomPostRequest(v1GlobalAppsCustomPostRequest V1GlobalAppsCustomPostRequest) ApiV1GlobalAppsCustomPostRequest {
	r.v1GlobalAppsCustomPostRequest = &v1GlobalAppsCustomPostRequest
	return r
}

func (r ApiV1GlobalAppsCustomPostRequest) Execute() (*V1GlobalAppsAppListsPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsCustomPostExecute(r)
}

/*
V1GlobalAppsCustomPost Method for V1GlobalAppsCustomPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsCustomPostRequest
*/
func (a *DefaultAPIService) V1GlobalAppsCustomPost(ctx context.Context) ApiV1GlobalAppsCustomPostRequest {
	return ApiV1GlobalAppsCustomPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsAppListsPost200Response
func (a *DefaultAPIService) V1GlobalAppsCustomPostExecute(r ApiV1GlobalAppsCustomPostRequest) (*V1GlobalAppsAppListsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsAppListsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsCustomPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAppsCustomPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAppsCustomPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAppsCustomPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAppsGraphiantGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAppsGraphiantGetRequest) Authorization(authorization string) ApiV1GlobalAppsGraphiantGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAppsGraphiantGetRequest) Execute() (*V1GlobalAppsGraphiantGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAppsGraphiantGetExecute(r)
}

/*
V1GlobalAppsGraphiantGet Method for V1GlobalAppsGraphiantGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAppsGraphiantGetRequest
*/
func (a *DefaultAPIService) V1GlobalAppsGraphiantGet(ctx context.Context) ApiV1GlobalAppsGraphiantGetRequest {
	return ApiV1GlobalAppsGraphiantGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAppsGraphiantGet200Response
func (a *DefaultAPIService) V1GlobalAppsGraphiantGetExecute(r ApiV1GlobalAppsGraphiantGetRequest) (*V1GlobalAppsGraphiantGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAppsGraphiantGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAppsGraphiantGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/apps/graphiant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalAttachedEdgesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalAttachedEdgesPostRequest *V1GlobalAttachedEdgesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalAttachedEdgesPostRequest) Authorization(authorization string) ApiV1GlobalAttachedEdgesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalAttachedEdgesPostRequest) V1GlobalAttachedEdgesPostRequest(v1GlobalAttachedEdgesPostRequest V1GlobalAttachedEdgesPostRequest) ApiV1GlobalAttachedEdgesPostRequest {
	r.v1GlobalAttachedEdgesPostRequest = &v1GlobalAttachedEdgesPostRequest
	return r
}

func (r ApiV1GlobalAttachedEdgesPostRequest) Execute() (*V1GlobalAttachedEdgesPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalAttachedEdgesPostExecute(r)
}

/*
V1GlobalAttachedEdgesPost Method for V1GlobalAttachedEdgesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalAttachedEdgesPostRequest
*/
func (a *DefaultAPIService) V1GlobalAttachedEdgesPost(ctx context.Context) ApiV1GlobalAttachedEdgesPostRequest {
	return ApiV1GlobalAttachedEdgesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAttachedEdgesPost200Response
func (a *DefaultAPIService) V1GlobalAttachedEdgesPostExecute(r ApiV1GlobalAttachedEdgesPostRequest) (*V1GlobalAttachedEdgesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAttachedEdgesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalAttachedEdgesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/attached-edges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalAttachedEdgesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalAttachedEdgesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalAttachedEdgesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalConfigPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalConfigPatchRequest *V1GlobalConfigPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalConfigPatchRequest) Authorization(authorization string) ApiV1GlobalConfigPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalConfigPatchRequest) V1GlobalConfigPatchRequest(v1GlobalConfigPatchRequest V1GlobalConfigPatchRequest) ApiV1GlobalConfigPatchRequest {
	r.v1GlobalConfigPatchRequest = &v1GlobalConfigPatchRequest
	return r
}

func (r ApiV1GlobalConfigPatchRequest) Execute() (*V1GlobalConfigPatch200Response, *http.Response, error) {
	return r.ApiService.V1GlobalConfigPatchExecute(r)
}

/*
V1GlobalConfigPatch Method for V1GlobalConfigPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalConfigPatchRequest
*/
func (a *DefaultAPIService) V1GlobalConfigPatch(ctx context.Context) ApiV1GlobalConfigPatchRequest {
	return ApiV1GlobalConfigPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalConfigPatch200Response
func (a *DefaultAPIService) V1GlobalConfigPatchExecute(r ApiV1GlobalConfigPatchRequest) (*V1GlobalConfigPatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalConfigPatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalConfigPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalConfigPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalConfigPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalConfigPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalConfigSitePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalConfigSitePostRequest *V1GlobalConfigSitePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalConfigSitePostRequest) Authorization(authorization string) ApiV1GlobalConfigSitePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalConfigSitePostRequest) V1GlobalConfigSitePostRequest(v1GlobalConfigSitePostRequest V1GlobalConfigSitePostRequest) ApiV1GlobalConfigSitePostRequest {
	r.v1GlobalConfigSitePostRequest = &v1GlobalConfigSitePostRequest
	return r
}

func (r ApiV1GlobalConfigSitePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalConfigSitePostExecute(r)
}

/*
V1GlobalConfigSitePost Method for V1GlobalConfigSitePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalConfigSitePostRequest
*/
func (a *DefaultAPIService) V1GlobalConfigSitePost(ctx context.Context) ApiV1GlobalConfigSitePostRequest {
	return ApiV1GlobalConfigSitePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalConfigSitePostExecute(r ApiV1GlobalConfigSitePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalConfigSitePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/config/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalConfigSitePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalConfigSitePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalConfigSitePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalDeviceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalDeviceStatusGetRequest) Authorization(authorization string) ApiV1GlobalDeviceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalDeviceStatusGetRequest) Execute() (*V1GlobalAttachedEdgesPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalDeviceStatusGetExecute(r)
}

/*
V1GlobalDeviceStatusGet Method for V1GlobalDeviceStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalDeviceStatusGetRequest
*/
func (a *DefaultAPIService) V1GlobalDeviceStatusGet(ctx context.Context) ApiV1GlobalDeviceStatusGetRequest {
	return ApiV1GlobalDeviceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAttachedEdgesPost200Response
func (a *DefaultAPIService) V1GlobalDeviceStatusGetExecute(r ApiV1GlobalDeviceStatusGetRequest) (*V1GlobalAttachedEdgesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAttachedEdgesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalDeviceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/device-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpfixDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpfixDeviceGetRequest) Authorization(authorization string) ApiV1GlobalIpfixDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpfixDeviceGetRequest) Execute() (*V1GlobalIpfixDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalIpfixDeviceGetExecute(r)
}

/*
V1GlobalIpfixDeviceGet Method for V1GlobalIpfixDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpfixDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpfixDeviceGet(ctx context.Context) ApiV1GlobalIpfixDeviceGetRequest {
	return ApiV1GlobalIpfixDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpfixDeviceGet200Response
func (a *DefaultAPIService) V1GlobalIpfixDeviceGetExecute(r ApiV1GlobalIpfixDeviceGetRequest) (*V1GlobalIpfixDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpfixDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpfixDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipfix/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpfixPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpfixPostRequest) Authorization(authorization string) ApiV1GlobalIpfixPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpfixPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalIpfixPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalIpfixPostRequest) Execute() (*V1GlobalIpfixDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalIpfixPostExecute(r)
}

/*
V1GlobalIpfixPost Method for V1GlobalIpfixPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpfixPostRequest
*/
func (a *DefaultAPIService) V1GlobalIpfixPost(ctx context.Context) ApiV1GlobalIpfixPostRequest {
	return ApiV1GlobalIpfixPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpfixDeviceGet200Response
func (a *DefaultAPIService) V1GlobalIpfixPostExecute(r ApiV1GlobalIpfixPostRequest) (*V1GlobalIpfixDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpfixDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpfixPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipfix"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpfixSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpfixSiteGetRequest) Authorization(authorization string) ApiV1GlobalIpfixSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpfixSiteGetRequest) Execute() (*V1GlobalIpfixDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalIpfixSiteGetExecute(r)
}

/*
V1GlobalIpfixSiteGet Method for V1GlobalIpfixSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpfixSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpfixSiteGet(ctx context.Context) ApiV1GlobalIpfixSiteGetRequest {
	return ApiV1GlobalIpfixSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpfixDeviceGet200Response
func (a *DefaultAPIService) V1GlobalIpfixSiteGetExecute(r ApiV1GlobalIpfixSiteGetRequest) (*V1GlobalIpfixDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpfixDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpfixSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipfix/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpsecProfileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpsecProfileGetRequest) Authorization(authorization string) ApiV1GlobalIpsecProfileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpsecProfileGetRequest) Execute() (*V1GlobalIpsecProfileGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalIpsecProfileGetExecute(r)
}

/*
V1GlobalIpsecProfileGet Method for V1GlobalIpsecProfileGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalIpsecProfileGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpsecProfileGet(ctx context.Context) ApiV1GlobalIpsecProfileGetRequest {
	return ApiV1GlobalIpsecProfileGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalIpsecProfileGet200Response
func (a *DefaultAPIService) V1GlobalIpsecProfileGetExecute(r ApiV1GlobalIpsecProfileGetRequest) (*V1GlobalIpsecProfileGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpsecProfileGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpsecProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipsec-profile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpsecProfileIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpsecProfileIdGetRequest) Authorization(authorization string) ApiV1GlobalIpsecProfileIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpsecProfileIdGetRequest) Execute() (*V1GlobalIpsecProfileIdGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalIpsecProfileIdGetExecute(r)
}

/*
V1GlobalIpsecProfileIdGet Method for V1GlobalIpsecProfileIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalIpsecProfileIdGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpsecProfileIdGet(ctx context.Context, id int64) ApiV1GlobalIpsecProfileIdGetRequest {
	return ApiV1GlobalIpsecProfileIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalIpsecProfileIdGet200Response
func (a *DefaultAPIService) V1GlobalIpsecProfileIdGetExecute(r ApiV1GlobalIpsecProfileIdGetRequest) (*V1GlobalIpsecProfileIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpsecProfileIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpsecProfileIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipsec-profile/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	vpnProfileId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest) Authorization(authorization string) ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest) Execute() (*V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetExecute(r)
}

/*
V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet Method for V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vpnProfileId 
 @return ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet(ctx context.Context, vpnProfileId int64) ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest {
	return ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest{
		ApiService: a,
		ctx: ctx,
		vpnProfileId: vpnProfileId,
	}
}

// Execute executes the request
//  @return V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet200Response
func (a *DefaultAPIService) V1GlobalIpsecProfileVpnProfileIdSiteToSiteGetExecute(r ApiV1GlobalIpsecProfileVpnProfileIdSiteToSiteGetRequest) (*V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalIpsecProfileVpnProfileIdSiteToSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/ipsec-profile/{vpnProfileId}/site-to-site"
	localVarPath = strings.Replace(localVarPath, "{"+"vpnProfileId"+"}", url.PathEscape(parameterValueToString(r.vpnProfileId, "vpnProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsGetRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsGetRequest) Execute() (*V1GlobalLanSegmentsGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsGetExecute(r)
}

/*
V1GlobalLanSegmentsGet Method for V1GlobalLanSegmentsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalLanSegmentsGetRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsGet(ctx context.Context) ApiV1GlobalLanSegmentsGetRequest {
	return ApiV1GlobalLanSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsGet200Response
func (a *DefaultAPIService) V1GlobalLanSegmentsGetExecute(r ApiV1GlobalLanSegmentsGetRequest) (*V1GlobalLanSegmentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsIdDeleteRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsIdDeleteRequest) Execute() (*V1GlobalLanSegmentsPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsIdDeleteExecute(r)
}

/*
V1GlobalLanSegmentsIdDelete Method for V1GlobalLanSegmentsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalLanSegmentsIdDeleteRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsIdDelete(ctx context.Context, id int64) ApiV1GlobalLanSegmentsIdDeleteRequest {
	return ApiV1GlobalLanSegmentsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsPost200Response
func (a *DefaultAPIService) V1GlobalLanSegmentsIdDeleteExecute(r ApiV1GlobalLanSegmentsIdDeleteRequest) (*V1GlobalLanSegmentsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalLanSegmentsPostRequest *V1GlobalLanSegmentsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsPostRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsPostRequest) V1GlobalLanSegmentsPostRequest(v1GlobalLanSegmentsPostRequest V1GlobalLanSegmentsPostRequest) ApiV1GlobalLanSegmentsPostRequest {
	r.v1GlobalLanSegmentsPostRequest = &v1GlobalLanSegmentsPostRequest
	return r
}

func (r ApiV1GlobalLanSegmentsPostRequest) Execute() (*V1GlobalLanSegmentsPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsPostExecute(r)
}

/*
V1GlobalLanSegmentsPost Method for V1GlobalLanSegmentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalLanSegmentsPostRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsPost(ctx context.Context) ApiV1GlobalLanSegmentsPostRequest {
	return ApiV1GlobalLanSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsPost200Response
func (a *DefaultAPIService) V1GlobalLanSegmentsPostExecute(r ApiV1GlobalLanSegmentsPostRequest) (*V1GlobalLanSegmentsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalLanSegmentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalLanSegmentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalLanSegmentsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	vrfId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest) Authorization(authorization string) ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest) Execute() (*V1GlobalLanSegmentsVrfIdDevicesGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalLanSegmentsVrfIdDevicesGetExecute(r)
}

/*
V1GlobalLanSegmentsVrfIdDevicesGet Method for V1GlobalLanSegmentsVrfIdDevicesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vrfId 
 @return ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest
*/
func (a *DefaultAPIService) V1GlobalLanSegmentsVrfIdDevicesGet(ctx context.Context, vrfId int64) ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest {
	return ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest{
		ApiService: a,
		ctx: ctx,
		vrfId: vrfId,
	}
}

// Execute executes the request
//  @return V1GlobalLanSegmentsVrfIdDevicesGet200Response
func (a *DefaultAPIService) V1GlobalLanSegmentsVrfIdDevicesGetExecute(r ApiV1GlobalLanSegmentsVrfIdDevicesGetRequest) (*V1GlobalLanSegmentsVrfIdDevicesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalLanSegmentsVrfIdDevicesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalLanSegmentsVrfIdDevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/lan-segments/{vrfId}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"vrfId"+"}", url.PathEscape(parameterValueToString(r.vrfId, "vrfId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalPrefixSetsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalPrefixSetsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalPrefixSetsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalPrefixSetsDeviceGetRequest) Execute() (*V1GlobalPrefixSetsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalPrefixSetsDeviceGetExecute(r)
}

/*
V1GlobalPrefixSetsDeviceGet Method for V1GlobalPrefixSetsDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalPrefixSetsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalPrefixSetsDeviceGet(ctx context.Context) ApiV1GlobalPrefixSetsDeviceGetRequest {
	return ApiV1GlobalPrefixSetsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalPrefixSetsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalPrefixSetsDeviceGetExecute(r ApiV1GlobalPrefixSetsDeviceGetRequest) (*V1GlobalPrefixSetsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalPrefixSetsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalPrefixSetsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/prefix-sets/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalPrefixSetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalPrefixSetsPostRequest) Authorization(authorization string) ApiV1GlobalPrefixSetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalPrefixSetsPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalPrefixSetsPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalPrefixSetsPostRequest) Execute() (*V1GlobalPrefixSetsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalPrefixSetsPostExecute(r)
}

/*
V1GlobalPrefixSetsPost Method for V1GlobalPrefixSetsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalPrefixSetsPostRequest
*/
func (a *DefaultAPIService) V1GlobalPrefixSetsPost(ctx context.Context) ApiV1GlobalPrefixSetsPostRequest {
	return ApiV1GlobalPrefixSetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalPrefixSetsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalPrefixSetsPostExecute(r ApiV1GlobalPrefixSetsPostRequest) (*V1GlobalPrefixSetsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalPrefixSetsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalPrefixSetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/prefix-sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalPrefixSetsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalPrefixSetsSiteGetRequest) Authorization(authorization string) ApiV1GlobalPrefixSetsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalPrefixSetsSiteGetRequest) Execute() (*V1GlobalPrefixSetsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalPrefixSetsSiteGetExecute(r)
}

/*
V1GlobalPrefixSetsSiteGet Method for V1GlobalPrefixSetsSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalPrefixSetsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalPrefixSetsSiteGet(ctx context.Context) ApiV1GlobalPrefixSetsSiteGetRequest {
	return ApiV1GlobalPrefixSetsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalPrefixSetsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalPrefixSetsSiteGetExecute(r ApiV1GlobalPrefixSetsSiteGetRequest) (*V1GlobalPrefixSetsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalPrefixSetsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalPrefixSetsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/prefix-sets/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalRoutingPoliciesDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalRoutingPoliciesDeviceGetRequest) Authorization(authorization string) ApiV1GlobalRoutingPoliciesDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalRoutingPoliciesDeviceGetRequest) Execute() (*V1GlobalRoutingPoliciesDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalRoutingPoliciesDeviceGetExecute(r)
}

/*
V1GlobalRoutingPoliciesDeviceGet Method for V1GlobalRoutingPoliciesDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalRoutingPoliciesDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalRoutingPoliciesDeviceGet(ctx context.Context) ApiV1GlobalRoutingPoliciesDeviceGetRequest {
	return ApiV1GlobalRoutingPoliciesDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalRoutingPoliciesDeviceGet200Response
func (a *DefaultAPIService) V1GlobalRoutingPoliciesDeviceGetExecute(r ApiV1GlobalRoutingPoliciesDeviceGetRequest) (*V1GlobalRoutingPoliciesDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalRoutingPoliciesDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalRoutingPoliciesDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/routing-policies/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalRoutingPoliciesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalRoutingPoliciesPostRequest) Authorization(authorization string) ApiV1GlobalRoutingPoliciesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalRoutingPoliciesPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalRoutingPoliciesPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalRoutingPoliciesPostRequest) Execute() (*V1GlobalRoutingPoliciesDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalRoutingPoliciesPostExecute(r)
}

/*
V1GlobalRoutingPoliciesPost Method for V1GlobalRoutingPoliciesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalRoutingPoliciesPostRequest
*/
func (a *DefaultAPIService) V1GlobalRoutingPoliciesPost(ctx context.Context) ApiV1GlobalRoutingPoliciesPostRequest {
	return ApiV1GlobalRoutingPoliciesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalRoutingPoliciesDeviceGet200Response
func (a *DefaultAPIService) V1GlobalRoutingPoliciesPostExecute(r ApiV1GlobalRoutingPoliciesPostRequest) (*V1GlobalRoutingPoliciesDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalRoutingPoliciesDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalRoutingPoliciesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/routing-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalRoutingPoliciesSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalRoutingPoliciesSiteGetRequest) Authorization(authorization string) ApiV1GlobalRoutingPoliciesSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalRoutingPoliciesSiteGetRequest) Execute() (*V1GlobalRoutingPoliciesDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalRoutingPoliciesSiteGetExecute(r)
}

/*
V1GlobalRoutingPoliciesSiteGet Method for V1GlobalRoutingPoliciesSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalRoutingPoliciesSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalRoutingPoliciesSiteGet(ctx context.Context) ApiV1GlobalRoutingPoliciesSiteGetRequest {
	return ApiV1GlobalRoutingPoliciesSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalRoutingPoliciesDeviceGet200Response
func (a *DefaultAPIService) V1GlobalRoutingPoliciesSiteGetExecute(r ApiV1GlobalRoutingPoliciesSiteGetRequest) (*V1GlobalRoutingPoliciesDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalRoutingPoliciesDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalRoutingPoliciesSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/routing-policies/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteListsIdSitesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteListsIdSitesGetRequest) Authorization(authorization string) ApiV1GlobalSiteListsIdSitesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteListsIdSitesGetRequest) Execute() (*V1GlobalSiteListsIdSitesGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSiteListsIdSitesGetExecute(r)
}

/*
V1GlobalSiteListsIdSitesGet Method for V1GlobalSiteListsIdSitesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GlobalSiteListsIdSitesGetRequest
*/
func (a *DefaultAPIService) V1GlobalSiteListsIdSitesGet(ctx context.Context, id int64) ApiV1GlobalSiteListsIdSitesGetRequest {
	return ApiV1GlobalSiteListsIdSitesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GlobalSiteListsIdSitesGet200Response
func (a *DefaultAPIService) V1GlobalSiteListsIdSitesGetExecute(r ApiV1GlobalSiteListsIdSitesGetRequest) (*V1GlobalSiteListsIdSitesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSiteListsIdSitesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteListsIdSitesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-lists/{id}/sites"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSiteStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSiteStatusGetRequest) Authorization(authorization string) ApiV1GlobalSiteStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSiteStatusGetRequest) Execute() (*V1GlobalAttachedEdgesPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSiteStatusGetExecute(r)
}

/*
V1GlobalSiteStatusGet Method for V1GlobalSiteStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSiteStatusGetRequest
*/
func (a *DefaultAPIService) V1GlobalSiteStatusGet(ctx context.Context) ApiV1GlobalSiteStatusGetRequest {
	return ApiV1GlobalSiteStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalAttachedEdgesPost200Response
func (a *DefaultAPIService) V1GlobalSiteStatusGetExecute(r ApiV1GlobalSiteStatusGetRequest) (*V1GlobalAttachedEdgesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalAttachedEdgesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSiteStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/site-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSnmpsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSnmpsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalSnmpsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSnmpsDeviceGetRequest) Execute() (*V1GlobalSnmpsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSnmpsDeviceGetExecute(r)
}

/*
V1GlobalSnmpsDeviceGet Method for V1GlobalSnmpsDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSnmpsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalSnmpsDeviceGet(ctx context.Context) ApiV1GlobalSnmpsDeviceGetRequest {
	return ApiV1GlobalSnmpsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSnmpsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalSnmpsDeviceGetExecute(r ApiV1GlobalSnmpsDeviceGetRequest) (*V1GlobalSnmpsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSnmpsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSnmpsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/snmps/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSnmpsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSnmpsPostRequest) Authorization(authorization string) ApiV1GlobalSnmpsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSnmpsPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalSnmpsPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalSnmpsPostRequest) Execute() (*V1GlobalSnmpsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSnmpsPostExecute(r)
}

/*
V1GlobalSnmpsPost Method for V1GlobalSnmpsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSnmpsPostRequest
*/
func (a *DefaultAPIService) V1GlobalSnmpsPost(ctx context.Context) ApiV1GlobalSnmpsPostRequest {
	return ApiV1GlobalSnmpsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSnmpsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalSnmpsPostExecute(r ApiV1GlobalSnmpsPostRequest) (*V1GlobalSnmpsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSnmpsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSnmpsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/snmps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSnmpsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSnmpsSiteGetRequest) Authorization(authorization string) ApiV1GlobalSnmpsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSnmpsSiteGetRequest) Execute() (*V1GlobalSnmpsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSnmpsSiteGetExecute(r)
}

/*
V1GlobalSnmpsSiteGet Method for V1GlobalSnmpsSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSnmpsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalSnmpsSiteGet(ctx context.Context) ApiV1GlobalSnmpsSiteGetRequest {
	return ApiV1GlobalSnmpsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSnmpsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalSnmpsSiteGetExecute(r ApiV1GlobalSnmpsSiteGetRequest) (*V1GlobalSnmpsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSnmpsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSnmpsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/snmps/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSummaryPostRequest *V1GlobalSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSummaryPostRequest) Authorization(authorization string) ApiV1GlobalSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSummaryPostRequest) V1GlobalSummaryPostRequest(v1GlobalSummaryPostRequest V1GlobalSummaryPostRequest) ApiV1GlobalSummaryPostRequest {
	r.v1GlobalSummaryPostRequest = &v1GlobalSummaryPostRequest
	return r
}

func (r ApiV1GlobalSummaryPostRequest) Execute() (*V1GlobalSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSummaryPostExecute(r)
}

/*
V1GlobalSummaryPost Method for V1GlobalSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSummaryPostRequest
*/
func (a *DefaultAPIService) V1GlobalSummaryPost(ctx context.Context) ApiV1GlobalSummaryPostRequest {
	return ApiV1GlobalSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSummaryPost200Response
func (a *DefaultAPIService) V1GlobalSummaryPostExecute(r ApiV1GlobalSummaryPostRequest) (*V1GlobalSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyncPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalSyncPostRequest *V1GlobalSyncPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyncPostRequest) Authorization(authorization string) ApiV1GlobalSyncPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyncPostRequest) V1GlobalSyncPostRequest(v1GlobalSyncPostRequest V1GlobalSyncPostRequest) ApiV1GlobalSyncPostRequest {
	r.v1GlobalSyncPostRequest = &v1GlobalSyncPostRequest
	return r
}

func (r ApiV1GlobalSyncPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GlobalSyncPostExecute(r)
}

/*
V1GlobalSyncPost Method for V1GlobalSyncPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyncPostRequest
*/
func (a *DefaultAPIService) V1GlobalSyncPost(ctx context.Context) ApiV1GlobalSyncPostRequest {
	return ApiV1GlobalSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GlobalSyncPostExecute(r ApiV1GlobalSyncPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyncPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalSyncPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalSyncPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalSyncPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyslogsDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyslogsDeviceGetRequest) Authorization(authorization string) ApiV1GlobalSyslogsDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyslogsDeviceGetRequest) Execute() (*V1GlobalSyslogsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSyslogsDeviceGetExecute(r)
}

/*
V1GlobalSyslogsDeviceGet Method for V1GlobalSyslogsDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyslogsDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalSyslogsDeviceGet(ctx context.Context) ApiV1GlobalSyslogsDeviceGetRequest {
	return ApiV1GlobalSyslogsDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSyslogsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalSyslogsDeviceGetExecute(r ApiV1GlobalSyslogsDeviceGetRequest) (*V1GlobalSyslogsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSyslogsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyslogsDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/syslogs/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyslogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyslogsPostRequest) Authorization(authorization string) ApiV1GlobalSyslogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyslogsPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalSyslogsPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalSyslogsPostRequest) Execute() (*V1GlobalSyslogsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSyslogsPostExecute(r)
}

/*
V1GlobalSyslogsPost Method for V1GlobalSyslogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyslogsPostRequest
*/
func (a *DefaultAPIService) V1GlobalSyslogsPost(ctx context.Context) ApiV1GlobalSyslogsPostRequest {
	return ApiV1GlobalSyslogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSyslogsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalSyslogsPostExecute(r ApiV1GlobalSyslogsPostRequest) (*V1GlobalSyslogsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSyslogsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyslogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/syslogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalSyslogsSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalSyslogsSiteGetRequest) Authorization(authorization string) ApiV1GlobalSyslogsSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalSyslogsSiteGetRequest) Execute() (*V1GlobalSyslogsDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalSyslogsSiteGetExecute(r)
}

/*
V1GlobalSyslogsSiteGet Method for V1GlobalSyslogsSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalSyslogsSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalSyslogsSiteGet(ctx context.Context) ApiV1GlobalSyslogsSiteGetRequest {
	return ApiV1GlobalSyslogsSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalSyslogsDeviceGet200Response
func (a *DefaultAPIService) V1GlobalSyslogsSiteGetExecute(r ApiV1GlobalSyslogsSiteGetRequest) (*V1GlobalSyslogsDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalSyslogsDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalSyslogsSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/syslogs/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalTrafficPoliciesDeviceGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalTrafficPoliciesDeviceGetRequest) Authorization(authorization string) ApiV1GlobalTrafficPoliciesDeviceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalTrafficPoliciesDeviceGetRequest) Execute() (*V1GlobalTrafficPoliciesDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalTrafficPoliciesDeviceGetExecute(r)
}

/*
V1GlobalTrafficPoliciesDeviceGet Method for V1GlobalTrafficPoliciesDeviceGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalTrafficPoliciesDeviceGetRequest
*/
func (a *DefaultAPIService) V1GlobalTrafficPoliciesDeviceGet(ctx context.Context) ApiV1GlobalTrafficPoliciesDeviceGetRequest {
	return ApiV1GlobalTrafficPoliciesDeviceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalTrafficPoliciesDeviceGet200Response
func (a *DefaultAPIService) V1GlobalTrafficPoliciesDeviceGetExecute(r ApiV1GlobalTrafficPoliciesDeviceGetRequest) (*V1GlobalTrafficPoliciesDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalTrafficPoliciesDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalTrafficPoliciesDeviceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/traffic-policies/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalTrafficPoliciesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GlobalIpfixPostRequest *V1GlobalIpfixPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalTrafficPoliciesPostRequest) Authorization(authorization string) ApiV1GlobalTrafficPoliciesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalTrafficPoliciesPostRequest) V1GlobalIpfixPostRequest(v1GlobalIpfixPostRequest V1GlobalIpfixPostRequest) ApiV1GlobalTrafficPoliciesPostRequest {
	r.v1GlobalIpfixPostRequest = &v1GlobalIpfixPostRequest
	return r
}

func (r ApiV1GlobalTrafficPoliciesPostRequest) Execute() (*V1GlobalTrafficPoliciesDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalTrafficPoliciesPostExecute(r)
}

/*
V1GlobalTrafficPoliciesPost Method for V1GlobalTrafficPoliciesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalTrafficPoliciesPostRequest
*/
func (a *DefaultAPIService) V1GlobalTrafficPoliciesPost(ctx context.Context) ApiV1GlobalTrafficPoliciesPostRequest {
	return ApiV1GlobalTrafficPoliciesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalTrafficPoliciesDeviceGet200Response
func (a *DefaultAPIService) V1GlobalTrafficPoliciesPostExecute(r ApiV1GlobalTrafficPoliciesPostRequest) (*V1GlobalTrafficPoliciesDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalTrafficPoliciesDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalTrafficPoliciesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/traffic-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GlobalIpfixPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GlobalIpfixPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GlobalIpfixPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GlobalTrafficPoliciesSiteGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GlobalTrafficPoliciesSiteGetRequest) Authorization(authorization string) ApiV1GlobalTrafficPoliciesSiteGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GlobalTrafficPoliciesSiteGetRequest) Execute() (*V1GlobalTrafficPoliciesDeviceGet200Response, *http.Response, error) {
	return r.ApiService.V1GlobalTrafficPoliciesSiteGetExecute(r)
}

/*
V1GlobalTrafficPoliciesSiteGet Method for V1GlobalTrafficPoliciesSiteGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GlobalTrafficPoliciesSiteGetRequest
*/
func (a *DefaultAPIService) V1GlobalTrafficPoliciesSiteGet(ctx context.Context) ApiV1GlobalTrafficPoliciesSiteGetRequest {
	return ApiV1GlobalTrafficPoliciesSiteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GlobalTrafficPoliciesDeviceGet200Response
func (a *DefaultAPIService) V1GlobalTrafficPoliciesSiteGetExecute(r ApiV1GlobalTrafficPoliciesSiteGetRequest) (*V1GlobalTrafficPoliciesDeviceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GlobalTrafficPoliciesDeviceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GlobalTrafficPoliciesSiteGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/global/traffic-policies/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsEnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsEnterprisesGetRequest) Authorization(authorization string) ApiV1GroupsEnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsEnterprisesGetRequest) Execute() (*V1GroupsGet200Response, *http.Response, error) {
	return r.ApiService.V1GroupsEnterprisesGetExecute(r)
}

/*
V1GroupsEnterprisesGet Method for V1GroupsEnterprisesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsEnterprisesGetRequest
*/
func (a *DefaultAPIService) V1GroupsEnterprisesGet(ctx context.Context) ApiV1GroupsEnterprisesGetRequest {
	return ApiV1GroupsEnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsGet200Response
func (a *DefaultAPIService) V1GroupsEnterprisesGetExecute(r ApiV1GroupsEnterprisesGetRequest) (*V1GroupsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsEnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/enterprises"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsGetRequest) Authorization(authorization string) ApiV1GroupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsGetRequest) Execute() (*V1GroupsGet200Response, *http.Response, error) {
	return r.ApiService.V1GroupsGetExecute(r)
}

/*
V1GroupsGet Method for V1GroupsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsGetRequest
*/
func (a *DefaultAPIService) V1GroupsGet(ctx context.Context) ApiV1GroupsGetRequest {
	return ApiV1GroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsGet200Response
func (a *DefaultAPIService) V1GroupsGetExecute(r ApiV1GroupsGetRequest) (*V1GroupsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdDeleteRequest) Authorization(authorization string) ApiV1GroupsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdDeleteRequest) Execute() (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdDeleteExecute(r)
}

/*
V1GroupsIdDelete Method for V1GroupsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdDeleteRequest
*/
func (a *DefaultAPIService) V1GroupsIdDelete(ctx context.Context, id string) ApiV1GroupsIdDeleteRequest {
	return ApiV1GroupsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersPost204Response
func (a *DefaultAPIService) V1GroupsIdDeleteExecute(r ApiV1GroupsIdDeleteRequest) (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersPost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest) Authorization(authorization string) ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest) Execute() (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdEnterprisesEnterpriseIdDeleteExecute(r)
}

/*
V1GroupsIdEnterprisesEnterpriseIdDelete Method for V1GroupsIdEnterprisesEnterpriseIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId 
 @param id 
 @return ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest
*/
func (a *DefaultAPIService) V1GroupsIdEnterprisesEnterpriseIdDelete(ctx context.Context, enterpriseId int64, id string) ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest {
	return ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersPost204Response
func (a *DefaultAPIService) V1GroupsIdEnterprisesEnterpriseIdDeleteExecute(r ApiV1GroupsIdEnterprisesEnterpriseIdDeleteRequest) (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersPost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdEnterprisesEnterpriseIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/enterprises/{enterpriseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdEnterprisesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdEnterprisesPostRequest *V1GroupsIdEnterprisesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdEnterprisesPostRequest) Authorization(authorization string) ApiV1GroupsIdEnterprisesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdEnterprisesPostRequest) V1GroupsIdEnterprisesPostRequest(v1GroupsIdEnterprisesPostRequest V1GroupsIdEnterprisesPostRequest) ApiV1GroupsIdEnterprisesPostRequest {
	r.v1GroupsIdEnterprisesPostRequest = &v1GroupsIdEnterprisesPostRequest
	return r
}

func (r ApiV1GroupsIdEnterprisesPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GroupsIdEnterprisesPostExecute(r)
}

/*
V1GroupsIdEnterprisesPost Method for V1GroupsIdEnterprisesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdEnterprisesPostRequest
*/
func (a *DefaultAPIService) V1GroupsIdEnterprisesPost(ctx context.Context, id string) ApiV1GroupsIdEnterprisesPostRequest {
	return ApiV1GroupsIdEnterprisesPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GroupsIdEnterprisesPostExecute(r ApiV1GroupsIdEnterprisesPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdEnterprisesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/enterprises"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdEnterprisesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GroupsIdEnterprisesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdEnterprisesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdGetRequest) Authorization(authorization string) ApiV1GroupsIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdGetRequest) Execute() (*V1GroupsIdGet200Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdGetExecute(r)
}

/*
V1GroupsIdGet Method for V1GroupsIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdGetRequest
*/
func (a *DefaultAPIService) V1GroupsIdGet(ctx context.Context, id string) ApiV1GroupsIdGetRequest {
	return ApiV1GroupsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdGet200Response
func (a *DefaultAPIService) V1GroupsIdGetExecute(r ApiV1GroupsIdGetRequest) (*V1GroupsIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersGetRequest) Authorization(authorization string) ApiV1GroupsIdMembersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersGetRequest) Execute() (*V1GroupsIdMembersGet200Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdMembersGetExecute(r)
}

/*
V1GroupsIdMembersGet Method for V1GroupsIdMembersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdMembersGetRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersGet(ctx context.Context, id string) ApiV1GroupsIdMembersGetRequest {
	return ApiV1GroupsIdMembersGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersGet200Response
func (a *DefaultAPIService) V1GroupsIdMembersGetExecute(r ApiV1GroupsIdMembersGetRequest) (*V1GroupsIdMembersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersMemberIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	memberId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersMemberIdDeleteRequest) Authorization(authorization string) ApiV1GroupsIdMembersMemberIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersMemberIdDeleteRequest) Execute() (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdMembersMemberIdDeleteExecute(r)
}

/*
V1GroupsIdMembersMemberIdDelete Method for V1GroupsIdMembersMemberIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @param memberId 
 @return ApiV1GroupsIdMembersMemberIdDeleteRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersMemberIdDelete(ctx context.Context, id string, memberId string) ApiV1GroupsIdMembersMemberIdDeleteRequest {
	return ApiV1GroupsIdMembersMemberIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		memberId: memberId,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersPost204Response
func (a *DefaultAPIService) V1GroupsIdMembersMemberIdDeleteExecute(r ApiV1GroupsIdMembersMemberIdDeleteRequest) (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersPost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersMemberIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members/{memberId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"memberId"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdMembersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdMembersPostRequest *V1GroupsIdMembersPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdMembersPostRequest) Authorization(authorization string) ApiV1GroupsIdMembersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdMembersPostRequest) V1GroupsIdMembersPostRequest(v1GroupsIdMembersPostRequest V1GroupsIdMembersPostRequest) ApiV1GroupsIdMembersPostRequest {
	r.v1GroupsIdMembersPostRequest = &v1GroupsIdMembersPostRequest
	return r
}

func (r ApiV1GroupsIdMembersPostRequest) Execute() (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdMembersPostExecute(r)
}

/*
V1GroupsIdMembersPost Method for V1GroupsIdMembersPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdMembersPostRequest
*/
func (a *DefaultAPIService) V1GroupsIdMembersPost(ctx context.Context, id string) ApiV1GroupsIdMembersPostRequest {
	return ApiV1GroupsIdMembersPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersPost204Response
func (a *DefaultAPIService) V1GroupsIdMembersPostExecute(r ApiV1GroupsIdMembersPostRequest) (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersPost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdMembersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdMembersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1GroupsIdMembersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdMembersPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsIdPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	v1GroupsIdPatchRequest *V1GroupsIdPatchRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsIdPatchRequest) Authorization(authorization string) ApiV1GroupsIdPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsIdPatchRequest) V1GroupsIdPatchRequest(v1GroupsIdPatchRequest V1GroupsIdPatchRequest) ApiV1GroupsIdPatchRequest {
	r.v1GroupsIdPatchRequest = &v1GroupsIdPatchRequest
	return r
}

func (r ApiV1GroupsIdPatchRequest) Execute() (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	return r.ApiService.V1GroupsIdPatchExecute(r)
}

/*
V1GroupsIdPatch Method for V1GroupsIdPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1GroupsIdPatchRequest
*/
func (a *DefaultAPIService) V1GroupsIdPatch(ctx context.Context, id string) ApiV1GroupsIdPatchRequest {
	return ApiV1GroupsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersPost204Response
func (a *DefaultAPIService) V1GroupsIdPatchExecute(r ApiV1GroupsIdPatchRequest) (*V1GroupsIdMembersPost204Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersPost204Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsIdPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v1GroupsIdPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsIdPatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1GroupsPutRequest *V1GroupsPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsPutRequest) Authorization(authorization string) ApiV1GroupsPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsPutRequest) V1GroupsPutRequest(v1GroupsPutRequest V1GroupsPutRequest) ApiV1GroupsPutRequest {
	r.v1GroupsPutRequest = &v1GroupsPutRequest
	return r
}

func (r ApiV1GroupsPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1GroupsPutExecute(r)
}

/*
V1GroupsPut Method for V1GroupsPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsPutRequest
*/
func (a *DefaultAPIService) V1GroupsPut(ctx context.Context) ApiV1GroupsPutRequest {
	return ApiV1GroupsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1GroupsPutExecute(r ApiV1GroupsPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1GroupsPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1GroupsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1GroupsPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1GroupsRootGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1GroupsRootGetRequest) Authorization(authorization string) ApiV1GroupsRootGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1GroupsRootGetRequest) Execute() (*V1GroupsGet200Response, *http.Response, error) {
	return r.ApiService.V1GroupsRootGetExecute(r)
}

/*
V1GroupsRootGet Method for V1GroupsRootGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1GroupsRootGetRequest
*/
func (a *DefaultAPIService) V1GroupsRootGet(ctx context.Context) ApiV1GroupsRootGetRequest {
	return ApiV1GroupsRootGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsGet200Response
func (a *DefaultAPIService) V1GroupsRootGetExecute(r ApiV1GroupsRootGetRequest) (*V1GroupsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1GroupsRootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/groups/root"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1IdPasswordRecoverPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1IdPasswordRecoverPatchRequest) Authorization(authorization string) ApiV1IdPasswordRecoverPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1IdPasswordRecoverPatchRequest) Body(body map[string]interface{}) ApiV1IdPasswordRecoverPatchRequest {
	r.body = &body
	return r
}

func (r ApiV1IdPasswordRecoverPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1IdPasswordRecoverPatchExecute(r)
}

/*
V1IdPasswordRecoverPatch Method for V1IdPasswordRecoverPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1IdPasswordRecoverPatchRequest
*/
func (a *DefaultAPIService) V1IdPasswordRecoverPatch(ctx context.Context, id string) ApiV1IdPasswordRecoverPatchRequest {
	return ApiV1IdPasswordRecoverPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1IdPasswordRecoverPatchExecute(r ApiV1IdPasswordRecoverPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1IdPasswordRecoverPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{id}/password/recover"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LanSegmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LanSegmentsGetRequest) Authorization(authorization string) ApiV1LanSegmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LanSegmentsGetRequest) Execute() (*V1LanSegmentsGet200Response, *http.Response, error) {
	return r.ApiService.V1LanSegmentsGetExecute(r)
}

/*
V1LanSegmentsGet Method for V1LanSegmentsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1LanSegmentsGetRequest
*/
func (a *DefaultAPIService) V1LanSegmentsGet(ctx context.Context) ApiV1LanSegmentsGetRequest {
	return ApiV1LanSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1LanSegmentsGet200Response
func (a *DefaultAPIService) V1LanSegmentsGetExecute(r ApiV1LanSegmentsGetRequest) (*V1LanSegmentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LanSegmentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LanSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lan-segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LldpInterfaceIdNeighborsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	interfaceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LldpInterfaceIdNeighborsGetRequest) Authorization(authorization string) ApiV1LldpInterfaceIdNeighborsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LldpInterfaceIdNeighborsGetRequest) Execute() (*V1LldpInterfaceIdNeighborsGet200Response, *http.Response, error) {
	return r.ApiService.V1LldpInterfaceIdNeighborsGetExecute(r)
}

/*
V1LldpInterfaceIdNeighborsGet Method for V1LldpInterfaceIdNeighborsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId 
 @return ApiV1LldpInterfaceIdNeighborsGetRequest
*/
func (a *DefaultAPIService) V1LldpInterfaceIdNeighborsGet(ctx context.Context, interfaceId int64) ApiV1LldpInterfaceIdNeighborsGetRequest {
	return ApiV1LldpInterfaceIdNeighborsGetRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return V1LldpInterfaceIdNeighborsGet200Response
func (a *DefaultAPIService) V1LldpInterfaceIdNeighborsGetExecute(r ApiV1LldpInterfaceIdNeighborsGetRequest) (*V1LldpInterfaceIdNeighborsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LldpInterfaceIdNeighborsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LldpInterfaceIdNeighborsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lldp/{interfaceId}/neighbors"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LldpInterfaceIdSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	interfaceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LldpInterfaceIdSummaryGetRequest) Authorization(authorization string) ApiV1LldpInterfaceIdSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LldpInterfaceIdSummaryGetRequest) Execute() (*V1LldpInterfaceIdSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1LldpInterfaceIdSummaryGetExecute(r)
}

/*
V1LldpInterfaceIdSummaryGet Method for V1LldpInterfaceIdSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId 
 @return ApiV1LldpInterfaceIdSummaryGetRequest
*/
func (a *DefaultAPIService) V1LldpInterfaceIdSummaryGet(ctx context.Context, interfaceId int64) ApiV1LldpInterfaceIdSummaryGetRequest {
	return ApiV1LldpInterfaceIdSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return V1LldpInterfaceIdSummaryGet200Response
func (a *DefaultAPIService) V1LldpInterfaceIdSummaryGetExecute(r ApiV1LldpInterfaceIdSummaryGetRequest) (*V1LldpInterfaceIdSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LldpInterfaceIdSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LldpInterfaceIdSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lldp/{interfaceId}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LldpInterfaceIdVendorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	interfaceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LldpInterfaceIdVendorsGetRequest) Authorization(authorization string) ApiV1LldpInterfaceIdVendorsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LldpInterfaceIdVendorsGetRequest) Execute() (*V1LldpInterfaceIdVendorsGet200Response, *http.Response, error) {
	return r.ApiService.V1LldpInterfaceIdVendorsGetExecute(r)
}

/*
V1LldpInterfaceIdVendorsGet Method for V1LldpInterfaceIdVendorsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param interfaceId 
 @return ApiV1LldpInterfaceIdVendorsGetRequest
*/
func (a *DefaultAPIService) V1LldpInterfaceIdVendorsGet(ctx context.Context, interfaceId int64) ApiV1LldpInterfaceIdVendorsGetRequest {
	return ApiV1LldpInterfaceIdVendorsGetRequest{
		ApiService: a,
		ctx: ctx,
		interfaceId: interfaceId,
	}
}

// Execute executes the request
//  @return V1LldpInterfaceIdVendorsGet200Response
func (a *DefaultAPIService) V1LldpInterfaceIdVendorsGetExecute(r ApiV1LldpInterfaceIdVendorsGetRequest) (*V1LldpInterfaceIdVendorsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LldpInterfaceIdVendorsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LldpInterfaceIdVendorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/lldp/{interfaceId}/vendors"
	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", url.PathEscape(parameterValueToString(r.interfaceId, "interfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1LogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1LogsPostRequest *V1LogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1LogsPostRequest) Authorization(authorization string) ApiV1LogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1LogsPostRequest) V1LogsPostRequest(v1LogsPostRequest V1LogsPostRequest) ApiV1LogsPostRequest {
	r.v1LogsPostRequest = &v1LogsPostRequest
	return r
}

func (r ApiV1LogsPostRequest) Execute() (*V1LogsPost200Response, *http.Response, error) {
	return r.ApiService.V1LogsPostExecute(r)
}

/*
V1LogsPost Method for V1LogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1LogsPostRequest
*/
func (a *DefaultAPIService) V1LogsPost(ctx context.Context) ApiV1LogsPostRequest {
	return ApiV1LogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1LogsPost200Response
func (a *DefaultAPIService) V1LogsPostExecute(r ApiV1LogsPostRequest) (*V1LogsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1LogsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1LogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1LogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1LogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1LogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsBandwidthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsBandwidthPostRequest *V1MonitoringCircuitsBandwidthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsBandwidthPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsBandwidthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsBandwidthPostRequest) V1MonitoringCircuitsBandwidthPostRequest(v1MonitoringCircuitsBandwidthPostRequest V1MonitoringCircuitsBandwidthPostRequest) ApiV1MonitoringCircuitsBandwidthPostRequest {
	r.v1MonitoringCircuitsBandwidthPostRequest = &v1MonitoringCircuitsBandwidthPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsBandwidthPostRequest) Execute() (*V1MonitoringCircuitsBandwidthPost200Response, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsBandwidthPostExecute(r)
}

/*
V1MonitoringCircuitsBandwidthPost Method for V1MonitoringCircuitsBandwidthPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsBandwidthPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsBandwidthPost(ctx context.Context) ApiV1MonitoringCircuitsBandwidthPostRequest {
	return ApiV1MonitoringCircuitsBandwidthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsBandwidthPost200Response
func (a *DefaultAPIService) V1MonitoringCircuitsBandwidthPostExecute(r ApiV1MonitoringCircuitsBandwidthPostRequest) (*V1MonitoringCircuitsBandwidthPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsBandwidthPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsBandwidthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsBandwidthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsBandwidthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsBandwidthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsIncidentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsUtilizationPostRequest *V2MonitoringCircuitsUtilizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsIncidentsPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsIncidentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsIncidentsPostRequest) V2MonitoringCircuitsUtilizationPostRequest(v2MonitoringCircuitsUtilizationPostRequest V2MonitoringCircuitsUtilizationPostRequest) ApiV1MonitoringCircuitsIncidentsPostRequest {
	r.v2MonitoringCircuitsUtilizationPostRequest = &v2MonitoringCircuitsUtilizationPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsIncidentsPostRequest) Execute() (*V1MonitoringCircuitsIncidentsPost200Response, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsIncidentsPostExecute(r)
}

/*
V1MonitoringCircuitsIncidentsPost Method for V1MonitoringCircuitsIncidentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsIncidentsPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsIncidentsPost(ctx context.Context) ApiV1MonitoringCircuitsIncidentsPostRequest {
	return ApiV1MonitoringCircuitsIncidentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsIncidentsPost200Response
func (a *DefaultAPIService) V1MonitoringCircuitsIncidentsPostExecute(r ApiV1MonitoringCircuitsIncidentsPostRequest) (*V1MonitoringCircuitsIncidentsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsIncidentsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsIncidentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/incidents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsUtilizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsUtilizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsUtilizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsSummaryPostRequest *V2MonitoringCircuitsSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsSummaryPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsSummaryPostRequest) V2MonitoringCircuitsSummaryPostRequest(v2MonitoringCircuitsSummaryPostRequest V2MonitoringCircuitsSummaryPostRequest) ApiV1MonitoringCircuitsSummaryPostRequest {
	r.v2MonitoringCircuitsSummaryPostRequest = &v2MonitoringCircuitsSummaryPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsSummaryPostRequest) Execute() (*V1MonitoringCircuitsSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsSummaryPostExecute(r)
}

/*
V1MonitoringCircuitsSummaryPost Method for V1MonitoringCircuitsSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsSummaryPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsSummaryPost(ctx context.Context) ApiV1MonitoringCircuitsSummaryPostRequest {
	return ApiV1MonitoringCircuitsSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsSummaryPost200Response
func (a *DefaultAPIService) V1MonitoringCircuitsSummaryPostExecute(r ApiV1MonitoringCircuitsSummaryPostRequest) (*V1MonitoringCircuitsSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsUtilizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsUtilizationPostRequest *V2MonitoringCircuitsUtilizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsUtilizationPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsUtilizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsUtilizationPostRequest) V2MonitoringCircuitsUtilizationPostRequest(v2MonitoringCircuitsUtilizationPostRequest V2MonitoringCircuitsUtilizationPostRequest) ApiV1MonitoringCircuitsUtilizationPostRequest {
	r.v2MonitoringCircuitsUtilizationPostRequest = &v2MonitoringCircuitsUtilizationPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsUtilizationPostRequest) Execute() (*V1MonitoringCircuitsUtilizationPost200Response, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsUtilizationPostExecute(r)
}

/*
V1MonitoringCircuitsUtilizationPost Method for V1MonitoringCircuitsUtilizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsUtilizationPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsUtilizationPost(ctx context.Context) ApiV1MonitoringCircuitsUtilizationPostRequest {
	return ApiV1MonitoringCircuitsUtilizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsUtilizationPost200Response
func (a *DefaultAPIService) V1MonitoringCircuitsUtilizationPostExecute(r ApiV1MonitoringCircuitsUtilizationPostRequest) (*V1MonitoringCircuitsUtilizationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsUtilizationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsUtilizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/utilization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsUtilizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsUtilizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsUtilizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MonitoringCircuitsVisualizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsVisualizationPostRequest *V1MonitoringCircuitsVisualizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1MonitoringCircuitsVisualizationPostRequest) Authorization(authorization string) ApiV1MonitoringCircuitsVisualizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1MonitoringCircuitsVisualizationPostRequest) V1MonitoringCircuitsVisualizationPostRequest(v1MonitoringCircuitsVisualizationPostRequest V1MonitoringCircuitsVisualizationPostRequest) ApiV1MonitoringCircuitsVisualizationPostRequest {
	r.v1MonitoringCircuitsVisualizationPostRequest = &v1MonitoringCircuitsVisualizationPostRequest
	return r
}

func (r ApiV1MonitoringCircuitsVisualizationPostRequest) Execute() (*V1MonitoringCircuitsVisualizationPost200Response, *http.Response, error) {
	return r.ApiService.V1MonitoringCircuitsVisualizationPostExecute(r)
}

/*
V1MonitoringCircuitsVisualizationPost Method for V1MonitoringCircuitsVisualizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MonitoringCircuitsVisualizationPostRequest
*/
func (a *DefaultAPIService) V1MonitoringCircuitsVisualizationPost(ctx context.Context) ApiV1MonitoringCircuitsVisualizationPostRequest {
	return ApiV1MonitoringCircuitsVisualizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsVisualizationPost200Response
func (a *DefaultAPIService) V1MonitoringCircuitsVisualizationPostExecute(r ApiV1MonitoringCircuitsVisualizationPostRequest) (*V1MonitoringCircuitsVisualizationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsVisualizationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MonitoringCircuitsVisualizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/monitoring/circuits/visualization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsVisualizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsVisualizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsVisualizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1NatEntriesDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1NatEntriesDeviceIdGetRequest) Authorization(authorization string) ApiV1NatEntriesDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1NatEntriesDeviceIdGetRequest) Execute() (*V1NatEntriesDeviceIdGet200Response, *http.Response, error) {
	return r.ApiService.V1NatEntriesDeviceIdGetExecute(r)
}

/*
V1NatEntriesDeviceIdGet Method for V1NatEntriesDeviceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1NatEntriesDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1NatEntriesDeviceIdGet(ctx context.Context, deviceId int64) ApiV1NatEntriesDeviceIdGetRequest {
	return ApiV1NatEntriesDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1NatEntriesDeviceIdGet200Response
func (a *DefaultAPIService) V1NatEntriesDeviceIdGetExecute(r ApiV1NatEntriesDeviceIdGetRequest) (*V1NatEntriesDeviceIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1NatEntriesDeviceIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1NatEntriesDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/nat/entries/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1NatUtilizationDeviceIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1NatUtilizationDeviceIdGetRequest) Authorization(authorization string) ApiV1NatUtilizationDeviceIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1NatUtilizationDeviceIdGetRequest) Execute() (*V1NatUtilizationDeviceIdGet200Response, *http.Response, error) {
	return r.ApiService.V1NatUtilizationDeviceIdGetExecute(r)
}

/*
V1NatUtilizationDeviceIdGet Method for V1NatUtilizationDeviceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1NatUtilizationDeviceIdGetRequest
*/
func (a *DefaultAPIService) V1NatUtilizationDeviceIdGet(ctx context.Context, deviceId int64) ApiV1NatUtilizationDeviceIdGetRequest {
	return ApiV1NatUtilizationDeviceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1NatUtilizationDeviceIdGet200Response
func (a *DefaultAPIService) V1NatUtilizationDeviceIdGetExecute(r ApiV1NatUtilizationDeviceIdGetRequest) (*V1NatUtilizationDeviceIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1NatUtilizationDeviceIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1NatUtilizationDeviceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/nat/utilization/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyApplicationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyApplicationsGetRequest) Authorization(authorization string) ApiV1PolicyApplicationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyApplicationsGetRequest) Execute() (*V1PolicyApplicationsGet200Response, *http.Response, error) {
	return r.ApiService.V1PolicyApplicationsGetExecute(r)
}

/*
V1PolicyApplicationsGet Method for V1PolicyApplicationsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyApplicationsGetRequest
*/
func (a *DefaultAPIService) V1PolicyApplicationsGet(ctx context.Context) ApiV1PolicyApplicationsGetRequest {
	return ApiV1PolicyApplicationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyApplicationsGet200Response
func (a *DefaultAPIService) V1PolicyApplicationsGetExecute(r ApiV1PolicyApplicationsGetRequest) (*V1PolicyApplicationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyApplicationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyApplicationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyPrefixSetsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyPrefixSetsIdDeleteRequest) Authorization(authorization string) ApiV1PolicyPrefixSetsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyPrefixSetsIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1PolicyPrefixSetsIdDeleteExecute(r)
}

/*
V1PolicyPrefixSetsIdDelete Method for V1PolicyPrefixSetsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1PolicyPrefixSetsIdDeleteRequest
*/
func (a *DefaultAPIService) V1PolicyPrefixSetsIdDelete(ctx context.Context, id int64) ApiV1PolicyPrefixSetsIdDeleteRequest {
	return ApiV1PolicyPrefixSetsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1PolicyPrefixSetsIdDeleteExecute(r ApiV1PolicyPrefixSetsIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyPrefixSetsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/prefix-sets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyPrefixSetsIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	v1PolicyPrefixSetsIdPutRequest *V1PolicyPrefixSetsIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyPrefixSetsIdPutRequest) Authorization(authorization string) ApiV1PolicyPrefixSetsIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyPrefixSetsIdPutRequest) V1PolicyPrefixSetsIdPutRequest(v1PolicyPrefixSetsIdPutRequest V1PolicyPrefixSetsIdPutRequest) ApiV1PolicyPrefixSetsIdPutRequest {
	r.v1PolicyPrefixSetsIdPutRequest = &v1PolicyPrefixSetsIdPutRequest
	return r
}

func (r ApiV1PolicyPrefixSetsIdPutRequest) Execute() (*V1PolicyPrefixSetsPost200Response, *http.Response, error) {
	return r.ApiService.V1PolicyPrefixSetsIdPutExecute(r)
}

/*
V1PolicyPrefixSetsIdPut Method for V1PolicyPrefixSetsIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1PolicyPrefixSetsIdPutRequest
*/
func (a *DefaultAPIService) V1PolicyPrefixSetsIdPut(ctx context.Context, id int64) ApiV1PolicyPrefixSetsIdPutRequest {
	return ApiV1PolicyPrefixSetsIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1PolicyPrefixSetsPost200Response
func (a *DefaultAPIService) V1PolicyPrefixSetsIdPutExecute(r ApiV1PolicyPrefixSetsIdPutRequest) (*V1PolicyPrefixSetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyPrefixSetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyPrefixSetsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/prefix-sets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyPrefixSetsIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1PolicyPrefixSetsIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyPrefixSetsIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyPrefixSetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PolicyPrefixSetsPostRequest *V1PolicyPrefixSetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyPrefixSetsPostRequest) Authorization(authorization string) ApiV1PolicyPrefixSetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyPrefixSetsPostRequest) V1PolicyPrefixSetsPostRequest(v1PolicyPrefixSetsPostRequest V1PolicyPrefixSetsPostRequest) ApiV1PolicyPrefixSetsPostRequest {
	r.v1PolicyPrefixSetsPostRequest = &v1PolicyPrefixSetsPostRequest
	return r
}

func (r ApiV1PolicyPrefixSetsPostRequest) Execute() (*V1PolicyPrefixSetsPost200Response, *http.Response, error) {
	return r.ApiService.V1PolicyPrefixSetsPostExecute(r)
}

/*
V1PolicyPrefixSetsPost Method for V1PolicyPrefixSetsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyPrefixSetsPostRequest
*/
func (a *DefaultAPIService) V1PolicyPrefixSetsPost(ctx context.Context) ApiV1PolicyPrefixSetsPostRequest {
	return ApiV1PolicyPrefixSetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyPrefixSetsPost200Response
func (a *DefaultAPIService) V1PolicyPrefixSetsPostExecute(r ApiV1PolicyPrefixSetsPostRequest) (*V1PolicyPrefixSetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyPrefixSetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyPrefixSetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/prefix-sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyPrefixSetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PolicyPrefixSetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyPrefixSetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
	level *int32
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsIdDeleteRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsIdDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1PolicyRouteTagSetsIdDeleteRequest) Level(level int32) ApiV1PolicyRouteTagSetsIdDeleteRequest {
	r.level = &level
	return r
}

func (r ApiV1PolicyRouteTagSetsIdDeleteRequest) Execute() (*V1PolicyRouteTagSetsPost200Response, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsIdDeleteExecute(r)
}

/*
V1PolicyRouteTagSetsIdDelete Method for V1PolicyRouteTagSetsIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1PolicyRouteTagSetsIdDeleteRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsIdDelete(ctx context.Context, id int64) ApiV1PolicyRouteTagSetsIdDeleteRequest {
	return ApiV1PolicyRouteTagSetsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsPost200Response
func (a *DefaultAPIService) V1PolicyRouteTagSetsIdDeleteExecute(r ApiV1PolicyRouteTagSetsIdDeleteRequest) (*V1PolicyRouteTagSetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PolicyRouteTagSetsPostRequest *V1PolicyRouteTagSetsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsPostRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsPostRequest) V1PolicyRouteTagSetsPostRequest(v1PolicyRouteTagSetsPostRequest V1PolicyRouteTagSetsPostRequest) ApiV1PolicyRouteTagSetsPostRequest {
	r.v1PolicyRouteTagSetsPostRequest = &v1PolicyRouteTagSetsPostRequest
	return r
}

func (r ApiV1PolicyRouteTagSetsPostRequest) Execute() (*V1PolicyRouteTagSetsPost200Response, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsPostExecute(r)
}

/*
V1PolicyRouteTagSetsPost Method for V1PolicyRouteTagSetsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsPostRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsPost(ctx context.Context) ApiV1PolicyRouteTagSetsPostRequest {
	return ApiV1PolicyRouteTagSetsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsPost200Response
func (a *DefaultAPIService) V1PolicyRouteTagSetsPostExecute(r ApiV1PolicyRouteTagSetsPostRequest) (*V1PolicyRouteTagSetsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyRouteTagSetsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PolicyRouteTagSetsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyRouteTagSetsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsTagDetailGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsTagDetailGetRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsTagDetailGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsTagDetailGetRequest) Execute() (*V1PolicyRouteTagSetsTagDetailGet200Response, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsTagDetailGetExecute(r)
}

/*
V1PolicyRouteTagSetsTagDetailGet Method for V1PolicyRouteTagSetsTagDetailGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsTagDetailGetRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagDetailGet(ctx context.Context) ApiV1PolicyRouteTagSetsTagDetailGetRequest {
	return ApiV1PolicyRouteTagSetsTagDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsTagDetailGet200Response
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagDetailGetExecute(r ApiV1PolicyRouteTagSetsTagDetailGetRequest) (*V1PolicyRouteTagSetsTagDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsTagDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsTagDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/tag-detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsTagsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsTagsGetRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsTagsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsTagsGetRequest) Execute() (*V1PolicyRouteTagSetsTagsGet200Response, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsTagsGetExecute(r)
}

/*
V1PolicyRouteTagSetsTagsGet Method for V1PolicyRouteTagSetsTagsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsTagsGetRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsGet(ctx context.Context) ApiV1PolicyRouteTagSetsTagsGetRequest {
	return ApiV1PolicyRouteTagSetsTagsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsTagsGet200Response
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsGetExecute(r ApiV1PolicyRouteTagSetsTagsGetRequest) (*V1PolicyRouteTagSetsTagsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsTagsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsTagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PolicyRouteTagSetsTagsSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PolicyRouteTagSetsTagsSummaryGetRequest) Authorization(authorization string) ApiV1PolicyRouteTagSetsTagsSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PolicyRouteTagSetsTagsSummaryGetRequest) Execute() (*V1PolicyRouteTagSetsTagsSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1PolicyRouteTagSetsTagsSummaryGetExecute(r)
}

/*
V1PolicyRouteTagSetsTagsSummaryGet Method for V1PolicyRouteTagSetsTagsSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PolicyRouteTagSetsTagsSummaryGetRequest
*/
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsSummaryGet(ctx context.Context) ApiV1PolicyRouteTagSetsTagsSummaryGetRequest {
	return ApiV1PolicyRouteTagSetsTagsSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PolicyRouteTagSetsTagsSummaryGet200Response
func (a *DefaultAPIService) V1PolicyRouteTagSetsTagsSummaryGetExecute(r ApiV1PolicyRouteTagSetsTagsSummaryGetRequest) (*V1PolicyRouteTagSetsTagsSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PolicyRouteTagSetsTagsSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PolicyRouteTagSetsTagsSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/policy/route-tag-sets/tags-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalApikeysDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	gcsName *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalApikeysDeleteRequest) Authorization(authorization string) ApiV1PortalApikeysDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1PortalApikeysDeleteRequest) GcsName(gcsName string) ApiV1PortalApikeysDeleteRequest {
	r.gcsName = &gcsName
	return r
}

func (r ApiV1PortalApikeysDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1PortalApikeysDeleteExecute(r)
}

/*
V1PortalApikeysDelete Method for V1PortalApikeysDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalApikeysDeleteRequest
*/
func (a *DefaultAPIService) V1PortalApikeysDelete(ctx context.Context) ApiV1PortalApikeysDeleteRequest {
	return ApiV1PortalApikeysDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1PortalApikeysDeleteExecute(r ApiV1PortalApikeysDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalApikeysDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.gcsName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gcsName", r.gcsName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalApikeysGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalApikeysGetRequest) Authorization(authorization string) ApiV1PortalApikeysGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalApikeysGetRequest) Execute() (*V1PortalApikeysGet200Response, *http.Response, error) {
	return r.ApiService.V1PortalApikeysGetExecute(r)
}

/*
V1PortalApikeysGet Method for V1PortalApikeysGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalApikeysGetRequest
*/
func (a *DefaultAPIService) V1PortalApikeysGet(ctx context.Context) ApiV1PortalApikeysGetRequest {
	return ApiV1PortalApikeysGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalApikeysGet200Response
func (a *DefaultAPIService) V1PortalApikeysGetExecute(r ApiV1PortalApikeysGetRequest) (*V1PortalApikeysGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalApikeysGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalApikeysGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalApikeysPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalApikeysPostRequest *V1PortalApikeysPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalApikeysPostRequest) Authorization(authorization string) ApiV1PortalApikeysPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalApikeysPostRequest) V1PortalApikeysPostRequest(v1PortalApikeysPostRequest V1PortalApikeysPostRequest) ApiV1PortalApikeysPostRequest {
	r.v1PortalApikeysPostRequest = &v1PortalApikeysPostRequest
	return r
}

func (r ApiV1PortalApikeysPostRequest) Execute() (*V1PortalApikeysPost200Response, *http.Response, error) {
	return r.ApiService.V1PortalApikeysPostExecute(r)
}

/*
V1PortalApikeysPost Method for V1PortalApikeysPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalApikeysPostRequest
*/
func (a *DefaultAPIService) V1PortalApikeysPost(ctx context.Context) ApiV1PortalApikeysPostRequest {
	return ApiV1PortalApikeysPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalApikeysPost200Response
func (a *DefaultAPIService) V1PortalApikeysPostExecute(r ApiV1PortalApikeysPostRequest) (*V1PortalApikeysPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalApikeysPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalApikeysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalApikeysPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PortalApikeysPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalApikeysPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivateDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateDetailsGetRequest) Authorization(authorization string) ApiV1PortalPrivateDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateDetailsGetRequest) Execute() (*V1PortalPrivateDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V1PortalPrivateDetailsGetExecute(r)
}

/*
V1PortalPrivateDetailsGet Method for V1PortalPrivateDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateDetailsGetRequest
*/
func (a *DefaultAPIService) V1PortalPrivateDetailsGet(ctx context.Context) ApiV1PortalPrivateDetailsGetRequest {
	return ApiV1PortalPrivateDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalPrivateDetailsGet200Response
func (a *DefaultAPIService) V1PortalPrivateDetailsGetExecute(r ApiV1PortalPrivateDetailsGetRequest) (*V1PortalPrivateDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalPrivateDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivateInventoryDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateInventoryDetailsGetRequest) Authorization(authorization string) ApiV1PortalPrivateInventoryDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateInventoryDetailsGetRequest) Execute() (*V1PortalPrivateInventoryDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V1PortalPrivateInventoryDetailsGetExecute(r)
}

/*
V1PortalPrivateInventoryDetailsGet Method for V1PortalPrivateInventoryDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateInventoryDetailsGetRequest
*/
func (a *DefaultAPIService) V1PortalPrivateInventoryDetailsGet(ctx context.Context) ApiV1PortalPrivateInventoryDetailsGetRequest {
	return ApiV1PortalPrivateInventoryDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PortalPrivateInventoryDetailsGet200Response
func (a *DefaultAPIService) V1PortalPrivateInventoryDetailsGetExecute(r ApiV1PortalPrivateInventoryDetailsGetRequest) (*V1PortalPrivateInventoryDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PortalPrivateInventoryDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateInventoryDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/inventory_details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalPrivatePostRequest *V1PortalPrivatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivatePostRequest) Authorization(authorization string) ApiV1PortalPrivatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivatePostRequest) V1PortalPrivatePostRequest(v1PortalPrivatePostRequest V1PortalPrivatePostRequest) ApiV1PortalPrivatePostRequest {
	r.v1PortalPrivatePostRequest = &v1PortalPrivatePostRequest
	return r
}

func (r ApiV1PortalPrivatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1PortalPrivatePostExecute(r)
}

/*
V1PortalPrivatePost Method for V1PortalPrivatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivatePostRequest
*/
func (a *DefaultAPIService) V1PortalPrivatePost(ctx context.Context) ApiV1PortalPrivatePostRequest {
	return ApiV1PortalPrivatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1PortalPrivatePostExecute(r ApiV1PortalPrivatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalPrivatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PortalPrivatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalPrivatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivateRegisterPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalPrivatePostRequest *V1PortalPrivatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateRegisterPostRequest) Authorization(authorization string) ApiV1PortalPrivateRegisterPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateRegisterPostRequest) V1PortalPrivatePostRequest(v1PortalPrivatePostRequest V1PortalPrivatePostRequest) ApiV1PortalPrivateRegisterPostRequest {
	r.v1PortalPrivatePostRequest = &v1PortalPrivatePostRequest
	return r
}

func (r ApiV1PortalPrivateRegisterPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1PortalPrivateRegisterPostExecute(r)
}

/*
V1PortalPrivateRegisterPost Method for V1PortalPrivateRegisterPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateRegisterPostRequest
*/
func (a *DefaultAPIService) V1PortalPrivateRegisterPost(ctx context.Context) ApiV1PortalPrivateRegisterPostRequest {
	return ApiV1PortalPrivateRegisterPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1PortalPrivateRegisterPostExecute(r ApiV1PortalPrivateRegisterPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateRegisterPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalPrivatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PortalPrivatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalPrivatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PortalPrivateSyncPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PortalPrivateSyncPostRequest *V1PortalPrivateSyncPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PortalPrivateSyncPostRequest) Authorization(authorization string) ApiV1PortalPrivateSyncPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PortalPrivateSyncPostRequest) V1PortalPrivateSyncPostRequest(v1PortalPrivateSyncPostRequest V1PortalPrivateSyncPostRequest) ApiV1PortalPrivateSyncPostRequest {
	r.v1PortalPrivateSyncPostRequest = &v1PortalPrivateSyncPostRequest
	return r
}

func (r ApiV1PortalPrivateSyncPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1PortalPrivateSyncPostExecute(r)
}

/*
V1PortalPrivateSyncPost Method for V1PortalPrivateSyncPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PortalPrivateSyncPostRequest
*/
func (a *DefaultAPIService) V1PortalPrivateSyncPost(ctx context.Context) ApiV1PortalPrivateSyncPostRequest {
	return ApiV1PortalPrivateSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1PortalPrivateSyncPostExecute(r ApiV1PortalPrivateSyncPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PortalPrivateSyncPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/portal/private/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PortalPrivateSyncPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1PortalPrivateSyncPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PortalPrivateSyncPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1PresharedkeyGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1PresharedkeyGetRequest) Authorization(authorization string) ApiV1PresharedkeyGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1PresharedkeyGetRequest) Execute() (*V1PresharedkeyGet200Response, *http.Response, error) {
	return r.ApiService.V1PresharedkeyGetExecute(r)
}

/*
V1PresharedkeyGet Method for V1PresharedkeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1PresharedkeyGetRequest
*/
func (a *DefaultAPIService) V1PresharedkeyGet(ctx context.Context) ApiV1PresharedkeyGetRequest {
	return ApiV1PresharedkeyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1PresharedkeyGet200Response
func (a *DefaultAPIService) V1PresharedkeyGetExecute(r ApiV1PresharedkeyGetRequest) (*V1PresharedkeyGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1PresharedkeyGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1PresharedkeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/presharedkey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1QosCircuitProfilesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1QosCircuitProfilesGetRequest) Authorization(authorization string) ApiV1QosCircuitProfilesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1QosCircuitProfilesGetRequest) Execute() (*V1QosCircuitProfilesGet200Response, *http.Response, error) {
	return r.ApiService.V1QosCircuitProfilesGetExecute(r)
}

/*
V1QosCircuitProfilesGet Method for V1QosCircuitProfilesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1QosCircuitProfilesGetRequest
*/
func (a *DefaultAPIService) V1QosCircuitProfilesGet(ctx context.Context) ApiV1QosCircuitProfilesGetRequest {
	return ApiV1QosCircuitProfilesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1QosCircuitProfilesGet200Response
func (a *DefaultAPIService) V1QosCircuitProfilesGetExecute(r ApiV1QosCircuitProfilesGetRequest) (*V1QosCircuitProfilesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1QosCircuitProfilesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1QosCircuitProfilesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/qos/circuit-profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1RegionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1RegionsGetRequest) Authorization(authorization string) ApiV1RegionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1RegionsGetRequest) Execute() (*V1GatewaysRegionsGet200Response, *http.Response, error) {
	return r.ApiService.V1RegionsGetExecute(r)
}

/*
V1RegionsGet Method for V1RegionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1RegionsGetRequest
*/
func (a *DefaultAPIService) V1RegionsGet(ctx context.Context) ApiV1RegionsGetRequest {
	return ApiV1RegionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GatewaysRegionsGet200Response
func (a *DefaultAPIService) V1RegionsGetExecute(r ApiV1RegionsGetRequest) (*V1GatewaysRegionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GatewaysRegionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1RegionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SearchGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	maxResults *int32
	search *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SearchGetRequest) Authorization(authorization string) ApiV1SearchGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1SearchGetRequest) MaxResults(maxResults int32) ApiV1SearchGetRequest {
	r.maxResults = &maxResults
	return r
}

// 
func (r ApiV1SearchGetRequest) Search(search string) ApiV1SearchGetRequest {
	r.search = &search
	return r
}

func (r ApiV1SearchGetRequest) Execute() (*V1SearchGet200Response, *http.Response, error) {
	return r.ApiService.V1SearchGetExecute(r)
}

/*
V1SearchGet Method for V1SearchGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SearchGetRequest
*/
func (a *DefaultAPIService) V1SearchGet(ctx context.Context) ApiV1SearchGetRequest {
	return ApiV1SearchGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SearchGet200Response
func (a *DefaultAPIService) V1SearchGetExecute(r ApiV1SearchGetRequest) (*V1SearchGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SearchGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SearchGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.maxResults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxResults", r.maxResults, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SiteDetailsSitelistsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SiteDetailsSitelistsPostRequest *V1SiteDetailsSitelistsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SiteDetailsSitelistsPostRequest) Authorization(authorization string) ApiV1SiteDetailsSitelistsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SiteDetailsSitelistsPostRequest) V1SiteDetailsSitelistsPostRequest(v1SiteDetailsSitelistsPostRequest V1SiteDetailsSitelistsPostRequest) ApiV1SiteDetailsSitelistsPostRequest {
	r.v1SiteDetailsSitelistsPostRequest = &v1SiteDetailsSitelistsPostRequest
	return r
}

func (r ApiV1SiteDetailsSitelistsPostRequest) Execute() (*V1SiteDetailsSitelistsPost200Response, *http.Response, error) {
	return r.ApiService.V1SiteDetailsSitelistsPostExecute(r)
}

/*
V1SiteDetailsSitelistsPost Method for V1SiteDetailsSitelistsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SiteDetailsSitelistsPostRequest
*/
func (a *DefaultAPIService) V1SiteDetailsSitelistsPost(ctx context.Context) ApiV1SiteDetailsSitelistsPostRequest {
	return ApiV1SiteDetailsSitelistsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SiteDetailsSitelistsPost200Response
func (a *DefaultAPIService) V1SiteDetailsSitelistsPostExecute(r ApiV1SiteDetailsSitelistsPostRequest) (*V1SiteDetailsSitelistsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SiteDetailsSitelistsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SiteDetailsSitelistsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/site/details/sitelists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SiteDetailsSitelistsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SiteDetailsSitelistsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SiteDetailsSitelistsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SiteIdDetailsInterfacesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SiteIdDetailsInterfacesGetRequest) Authorization(authorization string) ApiV1SiteIdDetailsInterfacesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SiteIdDetailsInterfacesGetRequest) Execute() (*V1SiteIdDetailsInterfacesGet200Response, *http.Response, error) {
	return r.ApiService.V1SiteIdDetailsInterfacesGetExecute(r)
}

/*
V1SiteIdDetailsInterfacesGet Method for V1SiteIdDetailsInterfacesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1SiteIdDetailsInterfacesGetRequest
*/
func (a *DefaultAPIService) V1SiteIdDetailsInterfacesGet(ctx context.Context, id int64) ApiV1SiteIdDetailsInterfacesGetRequest {
	return ApiV1SiteIdDetailsInterfacesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1SiteIdDetailsInterfacesGet200Response
func (a *DefaultAPIService) V1SiteIdDetailsInterfacesGetExecute(r ApiV1SiteIdDetailsInterfacesGetRequest) (*V1SiteIdDetailsInterfacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SiteIdDetailsInterfacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SiteIdDetailsInterfacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/site/{id}/details/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesDetailsGetRequest) Authorization(authorization string) ApiV1SitesDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesDetailsGetRequest) Execute() (*V1SitesDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V1SitesDetailsGetExecute(r)
}

/*
V1SitesDetailsGet Method for V1SitesDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SitesDetailsGetRequest
*/
func (a *DefaultAPIService) V1SitesDetailsGet(ctx context.Context) ApiV1SitesDetailsGetRequest {
	return ApiV1SitesDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SitesDetailsGet200Response
func (a *DefaultAPIService) V1SitesDetailsGetExecute(r ApiV1SitesDetailsGetRequest) (*V1SitesDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesGetRequest) Authorization(authorization string) ApiV1SitesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesGetRequest) Execute() (*V1SitesGet200Response, *http.Response, error) {
	return r.ApiService.V1SitesGetExecute(r)
}

/*
V1SitesGet Method for V1SitesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SitesGetRequest
*/
func (a *DefaultAPIService) V1SitesGet(ctx context.Context) ApiV1SitesGetRequest {
	return ApiV1SitesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SitesGet200Response
func (a *DefaultAPIService) V1SitesGetExecute(r ApiV1SitesGetRequest) (*V1SitesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SitesPostRequest *V1SitesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesPostRequest) Authorization(authorization string) ApiV1SitesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesPostRequest) V1SitesPostRequest(v1SitesPostRequest V1SitesPostRequest) ApiV1SitesPostRequest {
	r.v1SitesPostRequest = &v1SitesPostRequest
	return r
}

func (r ApiV1SitesPostRequest) Execute() (*V1SitesPost200Response, *http.Response, error) {
	return r.ApiService.V1SitesPostExecute(r)
}

/*
V1SitesPost Method for V1SitesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SitesPostRequest
*/
func (a *DefaultAPIService) V1SitesPost(ctx context.Context) ApiV1SitesPostRequest {
	return ApiV1SitesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SitesPost200Response
func (a *DefaultAPIService) V1SitesPostExecute(r ApiV1SitesPostRequest) (*V1SitesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SitesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SitesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SitesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdCircuitsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdCircuitsGetRequest) Authorization(authorization string) ApiV1SitesSiteIdCircuitsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdCircuitsGetRequest) Execute() (*V1SitesSiteIdCircuitsGet200Response, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdCircuitsGetExecute(r)
}

/*
V1SitesSiteIdCircuitsGet Method for V1SitesSiteIdCircuitsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdCircuitsGetRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdCircuitsGet(ctx context.Context, siteId int64) ApiV1SitesSiteIdCircuitsGetRequest {
	return ApiV1SitesSiteIdCircuitsGetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1SitesSiteIdCircuitsGet200Response
func (a *DefaultAPIService) V1SitesSiteIdCircuitsGetExecute(r ApiV1SitesSiteIdCircuitsGetRequest) (*V1SitesSiteIdCircuitsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesSiteIdCircuitsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdCircuitsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}/circuits"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdDeleteRequest) Authorization(authorization string) ApiV1SitesSiteIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdDeleteExecute(r)
}

/*
V1SitesSiteIdDelete Method for V1SitesSiteIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdDeleteRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdDelete(ctx context.Context, siteId int64) ApiV1SitesSiteIdDeleteRequest {
	return ApiV1SitesSiteIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1SitesSiteIdDeleteExecute(r ApiV1SitesSiteIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdDevicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdDevicesGetRequest) Authorization(authorization string) ApiV1SitesSiteIdDevicesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdDevicesGetRequest) Execute() (*V1SitesSiteIdDevicesGet200Response, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdDevicesGetExecute(r)
}

/*
V1SitesSiteIdDevicesGet Method for V1SitesSiteIdDevicesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdDevicesGetRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdDevicesGet(ctx context.Context, siteId int64) ApiV1SitesSiteIdDevicesGetRequest {
	return ApiV1SitesSiteIdDevicesGetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1SitesSiteIdDevicesGet200Response
func (a *DefaultAPIService) V1SitesSiteIdDevicesGetExecute(r ApiV1SitesSiteIdDevicesGetRequest) (*V1SitesSiteIdDevicesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesSiteIdDevicesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdDevicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.siteId < 0 {
		return localVarReturnValue, nil, reportError("siteId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SitesSiteIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v1SitesSiteIdPostRequest *V1SitesSiteIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SitesSiteIdPostRequest) Authorization(authorization string) ApiV1SitesSiteIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SitesSiteIdPostRequest) V1SitesSiteIdPostRequest(v1SitesSiteIdPostRequest V1SitesSiteIdPostRequest) ApiV1SitesSiteIdPostRequest {
	r.v1SitesSiteIdPostRequest = &v1SitesSiteIdPostRequest
	return r
}

func (r ApiV1SitesSiteIdPostRequest) Execute() (*V1SitesPost200Response, *http.Response, error) {
	return r.ApiService.V1SitesSiteIdPostExecute(r)
}

/*
V1SitesSiteIdPost Method for V1SitesSiteIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1SitesSiteIdPostRequest
*/
func (a *DefaultAPIService) V1SitesSiteIdPost(ctx context.Context, siteId int64) ApiV1SitesSiteIdPostRequest {
	return ApiV1SitesSiteIdPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1SitesPost200Response
func (a *DefaultAPIService) V1SitesSiteIdPostExecute(r ApiV1SitesSiteIdPostRequest) (*V1SitesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SitesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SitesSiteIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SitesSiteIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SitesSiteIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SitesSiteIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareAutoUpgradeDefaultGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareAutoUpgradeDefaultGetRequest) Authorization(authorization string) ApiV1SoftwareAutoUpgradeDefaultGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareAutoUpgradeDefaultGetRequest) Execute() (*V1SoftwareAutoUpgradeDefaultGet200Response, *http.Response, error) {
	return r.ApiService.V1SoftwareAutoUpgradeDefaultGetExecute(r)
}

/*
V1SoftwareAutoUpgradeDefaultGet Method for V1SoftwareAutoUpgradeDefaultGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareAutoUpgradeDefaultGetRequest
*/
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultGet(ctx context.Context) ApiV1SoftwareAutoUpgradeDefaultGetRequest {
	return ApiV1SoftwareAutoUpgradeDefaultGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareAutoUpgradeDefaultGet200Response
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultGetExecute(r ApiV1SoftwareAutoUpgradeDefaultGetRequest) (*V1SoftwareAutoUpgradeDefaultGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareAutoUpgradeDefaultGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareAutoUpgradeDefaultGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/auto-upgrade/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareAutoUpgradeDefaultPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SoftwareAutoUpgradeDefaultGet200Response *V1SoftwareAutoUpgradeDefaultGet200Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareAutoUpgradeDefaultPutRequest) Authorization(authorization string) ApiV1SoftwareAutoUpgradeDefaultPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareAutoUpgradeDefaultPutRequest) V1SoftwareAutoUpgradeDefaultGet200Response(v1SoftwareAutoUpgradeDefaultGet200Response V1SoftwareAutoUpgradeDefaultGet200Response) ApiV1SoftwareAutoUpgradeDefaultPutRequest {
	r.v1SoftwareAutoUpgradeDefaultGet200Response = &v1SoftwareAutoUpgradeDefaultGet200Response
	return r
}

func (r ApiV1SoftwareAutoUpgradeDefaultPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1SoftwareAutoUpgradeDefaultPutExecute(r)
}

/*
V1SoftwareAutoUpgradeDefaultPut Method for V1SoftwareAutoUpgradeDefaultPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareAutoUpgradeDefaultPutRequest
*/
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultPut(ctx context.Context) ApiV1SoftwareAutoUpgradeDefaultPutRequest {
	return ApiV1SoftwareAutoUpgradeDefaultPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1SoftwareAutoUpgradeDefaultPutExecute(r ApiV1SoftwareAutoUpgradeDefaultPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareAutoUpgradeDefaultPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/auto-upgrade/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SoftwareAutoUpgradeDefaultGet200Response == nil {
		return localVarReturnValue, nil, reportError("v1SoftwareAutoUpgradeDefaultGet200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SoftwareAutoUpgradeDefaultGet200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareGcsreleaseUploadNotesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1SoftwareGcsreleaseUploadNotesPostRequest *V1SoftwareGcsreleaseUploadNotesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) Authorization(authorization string) ApiV1SoftwareGcsreleaseUploadNotesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) V1SoftwareGcsreleaseUploadNotesPostRequest(v1SoftwareGcsreleaseUploadNotesPostRequest V1SoftwareGcsreleaseUploadNotesPostRequest) ApiV1SoftwareGcsreleaseUploadNotesPostRequest {
	r.v1SoftwareGcsreleaseUploadNotesPostRequest = &v1SoftwareGcsreleaseUploadNotesPostRequest
	return r
}

func (r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1SoftwareGcsreleaseUploadNotesPostExecute(r)
}

/*
V1SoftwareGcsreleaseUploadNotesPost Method for V1SoftwareGcsreleaseUploadNotesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareGcsreleaseUploadNotesPostRequest
*/
func (a *DefaultAPIService) V1SoftwareGcsreleaseUploadNotesPost(ctx context.Context) ApiV1SoftwareGcsreleaseUploadNotesPostRequest {
	return ApiV1SoftwareGcsreleaseUploadNotesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1SoftwareGcsreleaseUploadNotesPostExecute(r ApiV1SoftwareGcsreleaseUploadNotesPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareGcsreleaseUploadNotesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/gcsrelease/upload/notes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1SoftwareGcsreleaseUploadNotesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1SoftwareGcsreleaseUploadNotesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1SoftwareGcsreleaseUploadNotesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareReleaseNotesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareReleaseNotesGetRequest) Authorization(authorization string) ApiV1SoftwareReleaseNotesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareReleaseNotesGetRequest) Execute() (*V1SoftwareReleaseNotesGet200Response, *http.Response, error) {
	return r.ApiService.V1SoftwareReleaseNotesGetExecute(r)
}

/*
V1SoftwareReleaseNotesGet Method for V1SoftwareReleaseNotesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareReleaseNotesGetRequest
*/
func (a *DefaultAPIService) V1SoftwareReleaseNotesGet(ctx context.Context) ApiV1SoftwareReleaseNotesGetRequest {
	return ApiV1SoftwareReleaseNotesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareReleaseNotesGet200Response
func (a *DefaultAPIService) V1SoftwareReleaseNotesGetExecute(r ApiV1SoftwareReleaseNotesGetRequest) (*V1SoftwareReleaseNotesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareReleaseNotesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareReleaseNotesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/release/notes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareReleasesDownloadGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareReleasesDownloadGetRequest) Authorization(authorization string) ApiV1SoftwareReleasesDownloadGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareReleasesDownloadGetRequest) Execute() (*V1SoftwareReleasesDownloadGet200Response, *http.Response, error) {
	return r.ApiService.V1SoftwareReleasesDownloadGetExecute(r)
}

/*
V1SoftwareReleasesDownloadGet Method for V1SoftwareReleasesDownloadGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareReleasesDownloadGetRequest
*/
func (a *DefaultAPIService) V1SoftwareReleasesDownloadGet(ctx context.Context) ApiV1SoftwareReleasesDownloadGetRequest {
	return ApiV1SoftwareReleasesDownloadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareReleasesDownloadGet200Response
func (a *DefaultAPIService) V1SoftwareReleasesDownloadGetExecute(r ApiV1SoftwareReleasesDownloadGetRequest) (*V1SoftwareReleasesDownloadGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareReleasesDownloadGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareReleasesDownloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/releases/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareReleasesSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareReleasesSummaryGetRequest) Authorization(authorization string) ApiV1SoftwareReleasesSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareReleasesSummaryGetRequest) Execute() (*V1SoftwareReleasesSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1SoftwareReleasesSummaryGetExecute(r)
}

/*
V1SoftwareReleasesSummaryGet Method for V1SoftwareReleasesSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareReleasesSummaryGetRequest
*/
func (a *DefaultAPIService) V1SoftwareReleasesSummaryGet(ctx context.Context) ApiV1SoftwareReleasesSummaryGetRequest {
	return ApiV1SoftwareReleasesSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareReleasesSummaryGet200Response
func (a *DefaultAPIService) V1SoftwareReleasesSummaryGetExecute(r ApiV1SoftwareReleasesSummaryGetRequest) (*V1SoftwareReleasesSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareReleasesSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareReleasesSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/releases/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareRunningDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareRunningDetailsGetRequest) Authorization(authorization string) ApiV1SoftwareRunningDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareRunningDetailsGetRequest) Execute() (*V1SoftwareRunningDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V1SoftwareRunningDetailsGetExecute(r)
}

/*
V1SoftwareRunningDetailsGet Method for V1SoftwareRunningDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareRunningDetailsGetRequest
*/
func (a *DefaultAPIService) V1SoftwareRunningDetailsGet(ctx context.Context) ApiV1SoftwareRunningDetailsGetRequest {
	return ApiV1SoftwareRunningDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareRunningDetailsGet200Response
func (a *DefaultAPIService) V1SoftwareRunningDetailsGetExecute(r ApiV1SoftwareRunningDetailsGetRequest) (*V1SoftwareRunningDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareRunningDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareRunningDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/running/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1SoftwareRunningSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1SoftwareRunningSummaryGetRequest) Authorization(authorization string) ApiV1SoftwareRunningSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1SoftwareRunningSummaryGetRequest) Execute() (*V1SoftwareRunningSummaryGet200Response, *http.Response, error) {
	return r.ApiService.V1SoftwareRunningSummaryGetExecute(r)
}

/*
V1SoftwareRunningSummaryGet Method for V1SoftwareRunningSummaryGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1SoftwareRunningSummaryGetRequest
*/
func (a *DefaultAPIService) V1SoftwareRunningSummaryGet(ctx context.Context) ApiV1SoftwareRunningSummaryGetRequest {
	return ApiV1SoftwareRunningSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1SoftwareRunningSummaryGet200Response
func (a *DefaultAPIService) V1SoftwareRunningSummaryGetExecute(r ApiV1SoftwareRunningSummaryGetRequest) (*V1SoftwareRunningSummaryGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1SoftwareRunningSummaryGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1SoftwareRunningSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/software/running/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TalkersDeviceDeviceIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v1TalkersDeviceDeviceIdTopPostRequest *V1TalkersDeviceDeviceIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TalkersDeviceDeviceIdTopPostRequest) Authorization(authorization string) ApiV1TalkersDeviceDeviceIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TalkersDeviceDeviceIdTopPostRequest) V1TalkersDeviceDeviceIdTopPostRequest(v1TalkersDeviceDeviceIdTopPostRequest V1TalkersDeviceDeviceIdTopPostRequest) ApiV1TalkersDeviceDeviceIdTopPostRequest {
	r.v1TalkersDeviceDeviceIdTopPostRequest = &v1TalkersDeviceDeviceIdTopPostRequest
	return r
}

func (r ApiV1TalkersDeviceDeviceIdTopPostRequest) Execute() (*V1TalkersDeviceDeviceIdTopPost200Response, *http.Response, error) {
	return r.ApiService.V1TalkersDeviceDeviceIdTopPostExecute(r)
}

/*
V1TalkersDeviceDeviceIdTopPost Method for V1TalkersDeviceDeviceIdTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1TalkersDeviceDeviceIdTopPostRequest
*/
func (a *DefaultAPIService) V1TalkersDeviceDeviceIdTopPost(ctx context.Context, deviceId int64) ApiV1TalkersDeviceDeviceIdTopPostRequest {
	return ApiV1TalkersDeviceDeviceIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1TalkersDeviceDeviceIdTopPost200Response
func (a *DefaultAPIService) V1TalkersDeviceDeviceIdTopPostExecute(r ApiV1TalkersDeviceDeviceIdTopPostRequest) (*V1TalkersDeviceDeviceIdTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TalkersDeviceDeviceIdTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TalkersDeviceDeviceIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/talkers/device/{deviceId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TalkersDeviceDeviceIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TalkersDeviceDeviceIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TalkersDeviceDeviceIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TalkersSiteSiteIdTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v1TalkersDeviceDeviceIdTopPostRequest *V1TalkersDeviceDeviceIdTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TalkersSiteSiteIdTopPostRequest) Authorization(authorization string) ApiV1TalkersSiteSiteIdTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TalkersSiteSiteIdTopPostRequest) V1TalkersDeviceDeviceIdTopPostRequest(v1TalkersDeviceDeviceIdTopPostRequest V1TalkersDeviceDeviceIdTopPostRequest) ApiV1TalkersSiteSiteIdTopPostRequest {
	r.v1TalkersDeviceDeviceIdTopPostRequest = &v1TalkersDeviceDeviceIdTopPostRequest
	return r
}

func (r ApiV1TalkersSiteSiteIdTopPostRequest) Execute() (*V1TalkersDeviceDeviceIdTopPost200Response, *http.Response, error) {
	return r.ApiService.V1TalkersSiteSiteIdTopPostExecute(r)
}

/*
V1TalkersSiteSiteIdTopPost Method for V1TalkersSiteSiteIdTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1TalkersSiteSiteIdTopPostRequest
*/
func (a *DefaultAPIService) V1TalkersSiteSiteIdTopPost(ctx context.Context, siteId int64) ApiV1TalkersSiteSiteIdTopPostRequest {
	return ApiV1TalkersSiteSiteIdTopPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1TalkersDeviceDeviceIdTopPost200Response
func (a *DefaultAPIService) V1TalkersSiteSiteIdTopPostExecute(r ApiV1TalkersSiteSiteIdTopPostRequest) (*V1TalkersDeviceDeviceIdTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TalkersDeviceDeviceIdTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TalkersSiteSiteIdTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/talkers/site/{siteId}/top"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TalkersDeviceDeviceIdTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TalkersDeviceDeviceIdTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TalkersDeviceDeviceIdTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingDeviceDeviceIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingDeviceDeviceIdPostRequest) Authorization(authorization string) ApiV1TroubleshootingDeviceDeviceIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingDeviceDeviceIdPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV1TroubleshootingDeviceDeviceIdPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV1TroubleshootingDeviceDeviceIdPostRequest) Execute() (*V1TroubleshootingDeviceDeviceIdPost200Response, *http.Response, error) {
	return r.ApiService.V1TroubleshootingDeviceDeviceIdPostExecute(r)
}

/*
V1TroubleshootingDeviceDeviceIdPost Method for V1TroubleshootingDeviceDeviceIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV1TroubleshootingDeviceDeviceIdPostRequest
*/
func (a *DefaultAPIService) V1TroubleshootingDeviceDeviceIdPost(ctx context.Context, deviceId int64) ApiV1TroubleshootingDeviceDeviceIdPostRequest {
	return ApiV1TroubleshootingDeviceDeviceIdPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V1TroubleshootingDeviceDeviceIdPost200Response
func (a *DefaultAPIService) V1TroubleshootingDeviceDeviceIdPostExecute(r ApiV1TroubleshootingDeviceDeviceIdPostRequest) (*V1TroubleshootingDeviceDeviceIdPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingDeviceDeviceIdPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingDeviceDeviceIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/device/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingEnterprisePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1TroubleshootingEnterprisePostRequest *V1TroubleshootingEnterprisePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingEnterprisePostRequest) Authorization(authorization string) ApiV1TroubleshootingEnterprisePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingEnterprisePostRequest) V1TroubleshootingEnterprisePostRequest(v1TroubleshootingEnterprisePostRequest V1TroubleshootingEnterprisePostRequest) ApiV1TroubleshootingEnterprisePostRequest {
	r.v1TroubleshootingEnterprisePostRequest = &v1TroubleshootingEnterprisePostRequest
	return r
}

func (r ApiV1TroubleshootingEnterprisePostRequest) Execute() (*V1TroubleshootingEnterprisePost200Response, *http.Response, error) {
	return r.ApiService.V1TroubleshootingEnterprisePostExecute(r)
}

/*
V1TroubleshootingEnterprisePost Method for V1TroubleshootingEnterprisePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingEnterprisePostRequest
*/
func (a *DefaultAPIService) V1TroubleshootingEnterprisePost(ctx context.Context) ApiV1TroubleshootingEnterprisePostRequest {
	return ApiV1TroubleshootingEnterprisePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingEnterprisePost200Response
func (a *DefaultAPIService) V1TroubleshootingEnterprisePostExecute(r ApiV1TroubleshootingEnterprisePostRequest) (*V1TroubleshootingEnterprisePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingEnterprisePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingEnterprisePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1TroubleshootingEnterprisePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1TroubleshootingEnterprisePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1TroubleshootingEnterprisePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingFilterGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingFilterGetRequest) Authorization(authorization string) ApiV1TroubleshootingFilterGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingFilterGetRequest) Execute() (*V1BackboneHealthFilterGet200Response, *http.Response, error) {
	return r.ApiService.V1TroubleshootingFilterGetExecute(r)
}

/*
V1TroubleshootingFilterGet Method for V1TroubleshootingFilterGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingFilterGetRequest
*/
func (a *DefaultAPIService) V1TroubleshootingFilterGet(ctx context.Context) ApiV1TroubleshootingFilterGetRequest {
	return ApiV1TroubleshootingFilterGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1BackboneHealthFilterGet200Response
func (a *DefaultAPIService) V1TroubleshootingFilterGetExecute(r ApiV1TroubleshootingFilterGetRequest) (*V1BackboneHealthFilterGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BackboneHealthFilterGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingFilterGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingSiteConnectivityStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingSiteConnectivityStatusGetRequest) Authorization(authorization string) ApiV1TroubleshootingSiteConnectivityStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingSiteConnectivityStatusGetRequest) Execute() (*V1TroubleshootingSiteConnectivityStatusGet200Response, *http.Response, error) {
	return r.ApiService.V1TroubleshootingSiteConnectivityStatusGetExecute(r)
}

/*
V1TroubleshootingSiteConnectivityStatusGet Method for V1TroubleshootingSiteConnectivityStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingSiteConnectivityStatusGetRequest
*/
func (a *DefaultAPIService) V1TroubleshootingSiteConnectivityStatusGet(ctx context.Context) ApiV1TroubleshootingSiteConnectivityStatusGetRequest {
	return ApiV1TroubleshootingSiteConnectivityStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingSiteConnectivityStatusGet200Response
func (a *DefaultAPIService) V1TroubleshootingSiteConnectivityStatusGetExecute(r ApiV1TroubleshootingSiteConnectivityStatusGetRequest) (*V1TroubleshootingSiteConnectivityStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingSiteConnectivityStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingSiteConnectivityStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/site-connectivity-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingSiteSiteIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingSiteSiteIdGetRequest) Authorization(authorization string) ApiV1TroubleshootingSiteSiteIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingSiteSiteIdGetRequest) Execute() (*V1TroubleshootingSiteSiteIdGet200Response, *http.Response, error) {
	return r.ApiService.V1TroubleshootingSiteSiteIdGetExecute(r)
}

/*
V1TroubleshootingSiteSiteIdGet Method for V1TroubleshootingSiteSiteIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV1TroubleshootingSiteSiteIdGetRequest
*/
func (a *DefaultAPIService) V1TroubleshootingSiteSiteIdGet(ctx context.Context, siteId int64) ApiV1TroubleshootingSiteSiteIdGetRequest {
	return ApiV1TroubleshootingSiteSiteIdGetRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V1TroubleshootingSiteSiteIdGet200Response
func (a *DefaultAPIService) V1TroubleshootingSiteSiteIdGetExecute(r ApiV1TroubleshootingSiteSiteIdGetRequest) (*V1TroubleshootingSiteSiteIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingSiteSiteIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingSiteSiteIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/site/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TroubleshootingTopSitesByAlertsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1BackboneHealthTopDevicesByAlertsPostRequest *V1BackboneHealthTopDevicesByAlertsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TroubleshootingTopSitesByAlertsPostRequest) Authorization(authorization string) ApiV1TroubleshootingTopSitesByAlertsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TroubleshootingTopSitesByAlertsPostRequest) V1BackboneHealthTopDevicesByAlertsPostRequest(v1BackboneHealthTopDevicesByAlertsPostRequest V1BackboneHealthTopDevicesByAlertsPostRequest) ApiV1TroubleshootingTopSitesByAlertsPostRequest {
	r.v1BackboneHealthTopDevicesByAlertsPostRequest = &v1BackboneHealthTopDevicesByAlertsPostRequest
	return r
}

func (r ApiV1TroubleshootingTopSitesByAlertsPostRequest) Execute() (*V1TroubleshootingTopSitesByAlertsPost200Response, *http.Response, error) {
	return r.ApiService.V1TroubleshootingTopSitesByAlertsPostExecute(r)
}

/*
V1TroubleshootingTopSitesByAlertsPost Method for V1TroubleshootingTopSitesByAlertsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1TroubleshootingTopSitesByAlertsPostRequest
*/
func (a *DefaultAPIService) V1TroubleshootingTopSitesByAlertsPost(ctx context.Context) ApiV1TroubleshootingTopSitesByAlertsPostRequest {
	return ApiV1TroubleshootingTopSitesByAlertsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1TroubleshootingTopSitesByAlertsPost200Response
func (a *DefaultAPIService) V1TroubleshootingTopSitesByAlertsPostExecute(r ApiV1TroubleshootingTopSitesByAlertsPostRequest) (*V1TroubleshootingTopSitesByAlertsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1TroubleshootingTopSitesByAlertsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TroubleshootingTopSitesByAlertsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/troubleshooting/top-sites-by-alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1BackboneHealthTopDevicesByAlertsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1BackboneHealthTopDevicesByAlertsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1BackboneHealthTopDevicesByAlertsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1TtTtIdentityDeviceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	ttIdentity string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1TtTtIdentityDeviceStatusGetRequest) Authorization(authorization string) ApiV1TtTtIdentityDeviceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1TtTtIdentityDeviceStatusGetRequest) Execute() (*V1DeviceStatusPost200Response, *http.Response, error) {
	return r.ApiService.V1TtTtIdentityDeviceStatusGetExecute(r)
}

/*
V1TtTtIdentityDeviceStatusGet Method for V1TtTtIdentityDeviceStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ttIdentity 
 @return ApiV1TtTtIdentityDeviceStatusGetRequest
*/
func (a *DefaultAPIService) V1TtTtIdentityDeviceStatusGet(ctx context.Context, ttIdentity string) ApiV1TtTtIdentityDeviceStatusGetRequest {
	return ApiV1TtTtIdentityDeviceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		ttIdentity: ttIdentity,
	}
}

// Execute executes the request
//  @return V1DeviceStatusPost200Response
func (a *DefaultAPIService) V1TtTtIdentityDeviceStatusGetExecute(r ApiV1TtTtIdentityDeviceStatusGetRequest) (*V1DeviceStatusPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1DeviceStatusPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1TtTtIdentityDeviceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tt/{ttIdentity}/device-status"
	localVarPath = strings.Replace(localVarPath, "{"+"ttIdentity"+"}", url.PathEscape(parameterValueToString(r.ttIdentity, "ttIdentity")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersGetRequest) Authorization(authorization string) ApiV1UsersGetRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV1UsersGetRequest) Id(id string) ApiV1UsersGetRequest {
	r.id = &id
	return r
}

func (r ApiV1UsersGetRequest) Execute() (*V1GroupsIdMembersGet200Response, *http.Response, error) {
	return r.ApiService.V1UsersGetExecute(r)
}

/*
V1UsersGet Method for V1UsersGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1UsersGetRequest
*/
func (a *DefaultAPIService) V1UsersGet(ctx context.Context) ApiV1UsersGetRequest {
	return ApiV1UsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1GroupsIdMembersGet200Response
func (a *DefaultAPIService) V1UsersGetExecute(r ApiV1UsersGetRequest) (*V1GroupsIdMembersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsIdMembersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdDeleteRequest) Authorization(authorization string) ApiV1UsersIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1UsersIdDeleteExecute(r)
}

/*
V1UsersIdDelete Method for V1UsersIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdDeleteRequest
*/
func (a *DefaultAPIService) V1UsersIdDelete(ctx context.Context, id string) ApiV1UsersIdDeleteRequest {
	return ApiV1UsersIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1UsersIdDeleteExecute(r ApiV1UsersIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdEnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdEnterprisesGetRequest) Authorization(authorization string) ApiV1UsersIdEnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdEnterprisesGetRequest) Execute() (*V1EnterprisesGet200Response, *http.Response, error) {
	return r.ApiService.V1UsersIdEnterprisesGetExecute(r)
}

/*
V1UsersIdEnterprisesGet Method for V1UsersIdEnterprisesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdEnterprisesGetRequest
*/
func (a *DefaultAPIService) V1UsersIdEnterprisesGet(ctx context.Context, id string) ApiV1UsersIdEnterprisesGetRequest {
	return ApiV1UsersIdEnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1EnterprisesGet200Response
func (a *DefaultAPIService) V1UsersIdEnterprisesGetExecute(r ApiV1UsersIdEnterprisesGetRequest) (*V1EnterprisesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1EnterprisesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdEnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/enterprises"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdGroupsEnterprisesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdGroupsEnterprisesGetRequest) Authorization(authorization string) ApiV1UsersIdGroupsEnterprisesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdGroupsEnterprisesGetRequest) Execute() (*V1GroupsGet200Response, *http.Response, error) {
	return r.ApiService.V1UsersIdGroupsEnterprisesGetExecute(r)
}

/*
V1UsersIdGroupsEnterprisesGet Method for V1UsersIdGroupsEnterprisesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdGroupsEnterprisesGetRequest
*/
func (a *DefaultAPIService) V1UsersIdGroupsEnterprisesGet(ctx context.Context, id string) ApiV1UsersIdGroupsEnterprisesGetRequest {
	return ApiV1UsersIdGroupsEnterprisesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsGet200Response
func (a *DefaultAPIService) V1UsersIdGroupsEnterprisesGetExecute(r ApiV1UsersIdGroupsEnterprisesGetRequest) (*V1GroupsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdGroupsEnterprisesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/groups/enterprises"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdGroupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdGroupsGetRequest) Authorization(authorization string) ApiV1UsersIdGroupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdGroupsGetRequest) Execute() (*V1GroupsGet200Response, *http.Response, error) {
	return r.ApiService.V1UsersIdGroupsGetExecute(r)
}

/*
V1UsersIdGroupsGet Method for V1UsersIdGroupsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdGroupsGetRequest
*/
func (a *DefaultAPIService) V1UsersIdGroupsGet(ctx context.Context, id string) ApiV1UsersIdGroupsGetRequest {
	return ApiV1UsersIdGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsGet200Response
func (a *DefaultAPIService) V1UsersIdGroupsGetExecute(r ApiV1UsersIdGroupsGetRequest) (*V1GroupsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdGroupsRootGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdGroupsRootGetRequest) Authorization(authorization string) ApiV1UsersIdGroupsRootGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdGroupsRootGetRequest) Execute() (*V1GroupsGet200Response, *http.Response, error) {
	return r.ApiService.V1UsersIdGroupsRootGetExecute(r)
}

/*
V1UsersIdGroupsRootGet Method for V1UsersIdGroupsRootGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdGroupsRootGetRequest
*/
func (a *DefaultAPIService) V1UsersIdGroupsRootGet(ctx context.Context, id string) ApiV1UsersIdGroupsRootGetRequest {
	return ApiV1UsersIdGroupsRootGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V1GroupsGet200Response
func (a *DefaultAPIService) V1UsersIdGroupsRootGetExecute(r ApiV1UsersIdGroupsRootGetRequest) (*V1GroupsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1GroupsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdGroupsRootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/groups/root"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersIdVerifyPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	id string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersIdVerifyPatchRequest) Authorization(authorization string) ApiV1UsersIdVerifyPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersIdVerifyPatchRequest) Body(body map[string]interface{}) ApiV1UsersIdVerifyPatchRequest {
	r.body = &body
	return r
}

func (r ApiV1UsersIdVerifyPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1UsersIdVerifyPatchExecute(r)
}

/*
V1UsersIdVerifyPatch Method for V1UsersIdVerifyPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 
 @return ApiV1UsersIdVerifyPatchRequest
*/
func (a *DefaultAPIService) V1UsersIdVerifyPatch(ctx context.Context, id string) ApiV1UsersIdVerifyPatchRequest {
	return ApiV1UsersIdVerifyPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1UsersIdVerifyPatchExecute(r ApiV1UsersIdVerifyPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersIdVerifyPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{id}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1UsersPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1UsersPutRequest *V1UsersPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1UsersPutRequest) Authorization(authorization string) ApiV1UsersPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1UsersPutRequest) V1UsersPutRequest(v1UsersPutRequest V1UsersPutRequest) ApiV1UsersPutRequest {
	r.v1UsersPutRequest = &v1UsersPutRequest
	return r
}

func (r ApiV1UsersPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1UsersPutExecute(r)
}

/*
V1UsersPut Method for V1UsersPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1UsersPutRequest
*/
func (a *DefaultAPIService) V1UsersPut(ctx context.Context) ApiV1UsersPutRequest {
	return ApiV1UsersPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V1UsersPutExecute(r ApiV1UsersPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1UsersPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1UsersPutRequest == nil {
		return localVarReturnValue, nil, reportError("v1UsersPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1UsersPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1VersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1VersionPostRequest *V1VersionPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1VersionPostRequest) Authorization(authorization string) ApiV1VersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1VersionPostRequest) V1VersionPostRequest(v1VersionPostRequest V1VersionPostRequest) ApiV1VersionPostRequest {
	r.v1VersionPostRequest = &v1VersionPostRequest
	return r
}

func (r ApiV1VersionPostRequest) Execute() (*V1VersionPost200Response, *http.Response, error) {
	return r.ApiService.V1VersionPostExecute(r)
}

/*
V1VersionPost Method for V1VersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1VersionPostRequest
*/
func (a *DefaultAPIService) V1VersionPost(ctx context.Context) ApiV1VersionPostRequest {
	return ApiV1VersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1VersionPost200Response
func (a *DefaultAPIService) V1VersionPostExecute(r ApiV1VersionPostRequest) (*V1VersionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1VersionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1VersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1VersionPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1VersionPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1VersionPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ZonesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV1ZonesGetRequest) Authorization(authorization string) ApiV1ZonesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV1ZonesGetRequest) Execute() (*V1ZonesGet200Response, *http.Response, error) {
	return r.ApiService.V1ZonesGetExecute(r)
}

/*
V1ZonesGet Method for V1ZonesGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ZonesGetRequest
*/
func (a *DefaultAPIService) V1ZonesGet(ctx context.Context) ApiV1ZonesGetRequest {
	return ApiV1ZonesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ZonesGet200Response
func (a *DefaultAPIService) V1ZonesGetExecute(r ApiV1ZonesGetRequest) (*V1ZonesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ZonesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1ZonesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AckCreateupdatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AckCreateupdatePostRequest *V2AckCreateupdatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AckCreateupdatePostRequest) Authorization(authorization string) ApiV2AckCreateupdatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AckCreateupdatePostRequest) V2AckCreateupdatePostRequest(v2AckCreateupdatePostRequest V2AckCreateupdatePostRequest) ApiV2AckCreateupdatePostRequest {
	r.v2AckCreateupdatePostRequest = &v2AckCreateupdatePostRequest
	return r
}

func (r ApiV2AckCreateupdatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AckCreateupdatePostExecute(r)
}

/*
V2AckCreateupdatePost Method for V2AckCreateupdatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AckCreateupdatePostRequest
*/
func (a *DefaultAPIService) V2AckCreateupdatePost(ctx context.Context) ApiV2AckCreateupdatePostRequest {
	return ApiV2AckCreateupdatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AckCreateupdatePostExecute(r ApiV2AckCreateupdatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AckCreateupdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/ack/createupdate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AckCreateupdatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AckCreateupdatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AckCreateupdatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistByEnterpriseGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistByEnterpriseGetRequest) Authorization(authorization string) ApiV2AllowlistByEnterpriseGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistByEnterpriseGetRequest) Execute() (*V2AllowlistRuleIdGet200Response, *http.Response, error) {
	return r.ApiService.V2AllowlistByEnterpriseGetExecute(r)
}

/*
V2AllowlistByEnterpriseGet Method for V2AllowlistByEnterpriseGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AllowlistByEnterpriseGetRequest
*/
func (a *DefaultAPIService) V2AllowlistByEnterpriseGet(ctx context.Context) ApiV2AllowlistByEnterpriseGetRequest {
	return ApiV2AllowlistByEnterpriseGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AllowlistRuleIdGet200Response
func (a *DefaultAPIService) V2AllowlistByEnterpriseGetExecute(r ApiV2AllowlistByEnterpriseGetRequest) (*V2AllowlistRuleIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AllowlistRuleIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistByEnterpriseGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist-by-enterprise"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AllowlistCreatePostRequest *V2AllowlistCreatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistCreatePostRequest) Authorization(authorization string) ApiV2AllowlistCreatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistCreatePostRequest) V2AllowlistCreatePostRequest(v2AllowlistCreatePostRequest V2AllowlistCreatePostRequest) ApiV2AllowlistCreatePostRequest {
	r.v2AllowlistCreatePostRequest = &v2AllowlistCreatePostRequest
	return r
}

func (r ApiV2AllowlistCreatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AllowlistCreatePostExecute(r)
}

/*
V2AllowlistCreatePost Method for V2AllowlistCreatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AllowlistCreatePostRequest
*/
func (a *DefaultAPIService) V2AllowlistCreatePost(ctx context.Context) ApiV2AllowlistCreatePostRequest {
	return ApiV2AllowlistCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AllowlistCreatePostExecute(r ApiV2AllowlistCreatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AllowlistCreatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AllowlistCreatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AllowlistCreatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	alertId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest) Authorization(authorization string) ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AllowlistDeletebyalertidAlertIdDeleteExecute(r)
}

/*
V2AllowlistDeletebyalertidAlertIdDelete Method for V2AllowlistDeletebyalertidAlertIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertId Alert id of the alert to delete allowlist/mutelist for
 @return ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest
*/
func (a *DefaultAPIService) V2AllowlistDeletebyalertidAlertIdDelete(ctx context.Context, alertId string) ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest {
	return ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		alertId: alertId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AllowlistDeletebyalertidAlertIdDeleteExecute(r ApiV2AllowlistDeletebyalertidAlertIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistDeletebyalertidAlertIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/deletebyalertid/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	entityId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest) Authorization(authorization string) ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AllowlistDeletebyentityidEntityIdDeleteExecute(r)
}

/*
V2AllowlistDeletebyentityidEntityIdDelete Method for V2AllowlistDeletebyentityidEntityIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityId Entity id of the alert to delete allowlist/mutelist for
 @return ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest
*/
func (a *DefaultAPIService) V2AllowlistDeletebyentityidEntityIdDelete(ctx context.Context, entityId string) ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest {
	return ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		entityId: entityId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AllowlistDeletebyentityidEntityIdDeleteExecute(r ApiV2AllowlistDeletebyentityidEntityIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistDeletebyentityidEntityIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/deletebyentityid/{entityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", url.PathEscape(parameterValueToString(r.entityId, "entityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AllowlistRuleIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	ruleId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AllowlistRuleIdGetRequest) Authorization(authorization string) ApiV2AllowlistRuleIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AllowlistRuleIdGetRequest) Execute() (*V2AllowlistRuleIdGet200Response, *http.Response, error) {
	return r.ApiService.V2AllowlistRuleIdGetExecute(r)
}

/*
V2AllowlistRuleIdGet Method for V2AllowlistRuleIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleId Alert id of the alert to retrieve allowlist/mutelist for
 @return ApiV2AllowlistRuleIdGetRequest
*/
func (a *DefaultAPIService) V2AllowlistRuleIdGet(ctx context.Context, ruleId string) ApiV2AllowlistRuleIdGetRequest {
	return ApiV2AllowlistRuleIdGetRequest{
		ApiService: a,
		ctx: ctx,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return V2AllowlistRuleIdGet200Response
func (a *DefaultAPIService) V2AllowlistRuleIdGetExecute(r ApiV2AllowlistRuleIdGetRequest) (*V2AllowlistRuleIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AllowlistRuleIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AllowlistRuleIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/allowlist/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantAddToConversationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantAddToConversationPostRequest *V2AssistantAddToConversationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantAddToConversationPostRequest) Authorization(authorization string) ApiV2AssistantAddToConversationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantAddToConversationPostRequest) V2AssistantAddToConversationPostRequest(v2AssistantAddToConversationPostRequest V2AssistantAddToConversationPostRequest) ApiV2AssistantAddToConversationPostRequest {
	r.v2AssistantAddToConversationPostRequest = &v2AssistantAddToConversationPostRequest
	return r
}

func (r ApiV2AssistantAddToConversationPostRequest) Execute() (*V2AssistantAddToConversationPost200Response, *http.Response, error) {
	return r.ApiService.V2AssistantAddToConversationPostExecute(r)
}

/*
V2AssistantAddToConversationPost Method for V2AssistantAddToConversationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantAddToConversationPostRequest
*/
func (a *DefaultAPIService) V2AssistantAddToConversationPost(ctx context.Context) ApiV2AssistantAddToConversationPostRequest {
	return ApiV2AssistantAddToConversationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantAddToConversationPost200Response
func (a *DefaultAPIService) V2AssistantAddToConversationPostExecute(r ApiV2AssistantAddToConversationPostRequest) (*V2AssistantAddToConversationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantAddToConversationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantAddToConversationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/add-to-conversation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantAddToConversationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantAddToConversationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantAddToConversationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	conversationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantConversationIdDeleteRequest) Authorization(authorization string) ApiV2AssistantConversationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantConversationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantConversationIdDeleteExecute(r)
}

/*
V2AssistantConversationIdDelete Method for V2AssistantConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId 
 @return ApiV2AssistantConversationIdDeleteRequest
*/
func (a *DefaultAPIService) V2AssistantConversationIdDelete(ctx context.Context, conversationId int64) ApiV2AssistantConversationIdDeleteRequest {
	return ApiV2AssistantConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantConversationIdDeleteExecute(r ApiV2AssistantConversationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/{conversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversationId"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	conversationId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest) Authorization(authorization string) ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantDeleteConversationChatConversationIdDeleteExecute(r)
}

/*
V2AssistantDeleteConversationChatConversationIdDelete Method for V2AssistantDeleteConversationChatConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId 
 @return ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest
*/
func (a *DefaultAPIService) V2AssistantDeleteConversationChatConversationIdDelete(ctx context.Context, conversationId string) ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest {
	return ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantDeleteConversationChatConversationIdDeleteExecute(r ApiV2AssistantDeleteConversationChatConversationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantDeleteConversationChatConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/delete-conversation-chat/{conversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversationId"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantDeleteConversationConversationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	conversationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantDeleteConversationConversationIdDeleteRequest) Authorization(authorization string) ApiV2AssistantDeleteConversationConversationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantDeleteConversationConversationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantDeleteConversationConversationIdDeleteExecute(r)
}

/*
V2AssistantDeleteConversationConversationIdDelete Method for V2AssistantDeleteConversationConversationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId 
 @return ApiV2AssistantDeleteConversationConversationIdDeleteRequest
*/
func (a *DefaultAPIService) V2AssistantDeleteConversationConversationIdDelete(ctx context.Context, conversationId int64) ApiV2AssistantDeleteConversationConversationIdDeleteRequest {
	return ApiV2AssistantDeleteConversationConversationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantDeleteConversationConversationIdDeleteExecute(r ApiV2AssistantDeleteConversationConversationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantDeleteConversationConversationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/delete-conversation/{conversationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversationId"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantGetConversationDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantGetConversationDetailsPostRequest *V2AssistantGetConversationDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantGetConversationDetailsPostRequest) Authorization(authorization string) ApiV2AssistantGetConversationDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantGetConversationDetailsPostRequest) V2AssistantGetConversationDetailsPostRequest(v2AssistantGetConversationDetailsPostRequest V2AssistantGetConversationDetailsPostRequest) ApiV2AssistantGetConversationDetailsPostRequest {
	r.v2AssistantGetConversationDetailsPostRequest = &v2AssistantGetConversationDetailsPostRequest
	return r
}

func (r ApiV2AssistantGetConversationDetailsPostRequest) Execute() (*V2AssistantGetConversationDetailsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssistantGetConversationDetailsPostExecute(r)
}

/*
V2AssistantGetConversationDetailsPost Method for V2AssistantGetConversationDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantGetConversationDetailsPostRequest
*/
func (a *DefaultAPIService) V2AssistantGetConversationDetailsPost(ctx context.Context) ApiV2AssistantGetConversationDetailsPostRequest {
	return ApiV2AssistantGetConversationDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantGetConversationDetailsPost200Response
func (a *DefaultAPIService) V2AssistantGetConversationDetailsPostExecute(r ApiV2AssistantGetConversationDetailsPostRequest) (*V2AssistantGetConversationDetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantGetConversationDetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantGetConversationDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/get-conversation-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantGetConversationDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantGetConversationDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantGetConversationDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantGetConversationsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantGetConversationsPostRequest *V2AssistantGetConversationsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantGetConversationsPostRequest) Authorization(authorization string) ApiV2AssistantGetConversationsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantGetConversationsPostRequest) V2AssistantGetConversationsPostRequest(v2AssistantGetConversationsPostRequest V2AssistantGetConversationsPostRequest) ApiV2AssistantGetConversationsPostRequest {
	r.v2AssistantGetConversationsPostRequest = &v2AssistantGetConversationsPostRequest
	return r
}

func (r ApiV2AssistantGetConversationsPostRequest) Execute() (*V2AssistantGetConversationsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssistantGetConversationsPostExecute(r)
}

/*
V2AssistantGetConversationsPost Method for V2AssistantGetConversationsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantGetConversationsPostRequest
*/
func (a *DefaultAPIService) V2AssistantGetConversationsPost(ctx context.Context) ApiV2AssistantGetConversationsPostRequest {
	return ApiV2AssistantGetConversationsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssistantGetConversationsPost200Response
func (a *DefaultAPIService) V2AssistantGetConversationsPostExecute(r ApiV2AssistantGetConversationsPostRequest) (*V2AssistantGetConversationsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssistantGetConversationsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantGetConversationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/get-conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantGetConversationsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantGetConversationsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantGetConversationsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantUpdateConversationNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssistantUpdateConversationNamePostRequest *V2AssistantUpdateConversationNamePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantUpdateConversationNamePostRequest) Authorization(authorization string) ApiV2AssistantUpdateConversationNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantUpdateConversationNamePostRequest) V2AssistantUpdateConversationNamePostRequest(v2AssistantUpdateConversationNamePostRequest V2AssistantUpdateConversationNamePostRequest) ApiV2AssistantUpdateConversationNamePostRequest {
	r.v2AssistantUpdateConversationNamePostRequest = &v2AssistantUpdateConversationNamePostRequest
	return r
}

func (r ApiV2AssistantUpdateConversationNamePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssistantUpdateConversationNamePostExecute(r)
}

/*
V2AssistantUpdateConversationNamePost Method for V2AssistantUpdateConversationNamePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantUpdateConversationNamePostRequest
*/
func (a *DefaultAPIService) V2AssistantUpdateConversationNamePost(ctx context.Context) ApiV2AssistantUpdateConversationNamePostRequest {
	return ApiV2AssistantUpdateConversationNamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssistantUpdateConversationNamePostExecute(r ApiV2AssistantUpdateConversationNamePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantUpdateConversationNamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/update-conversation-name"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssistantUpdateConversationNamePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssistantUpdateConversationNamePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssistantUpdateConversationNamePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssistantVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssistantVersionPostRequest) Authorization(authorization string) ApiV2AssistantVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssistantVersionPostRequest) Body(body map[string]interface{}) ApiV2AssistantVersionPostRequest {
	r.body = &body
	return r
}

func (r ApiV2AssistantVersionPostRequest) Execute() (*V2VersionPost200Response, *http.Response, error) {
	return r.ApiService.V2AssistantVersionPostExecute(r)
}

/*
V2AssistantVersionPost Method for V2AssistantVersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssistantVersionPostRequest
*/
func (a *DefaultAPIService) V2AssistantVersionPost(ctx context.Context) ApiV2AssistantVersionPostRequest {
	return ApiV2AssistantVersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2VersionPost200Response
func (a *DefaultAPIService) V2AssistantVersionPostExecute(r ApiV2AssistantVersionPostRequest) (*V2VersionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2VersionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssistantVersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assistant/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceApplicationdetailsbynamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceApplicationdetailsbynamePostRequest *V2AssuranceApplicationdetailsbynamePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceApplicationdetailsbynamePostRequest) Authorization(authorization string) ApiV2AssuranceApplicationdetailsbynamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceApplicationdetailsbynamePostRequest) V2AssuranceApplicationdetailsbynamePostRequest(v2AssuranceApplicationdetailsbynamePostRequest V2AssuranceApplicationdetailsbynamePostRequest) ApiV2AssuranceApplicationdetailsbynamePostRequest {
	r.v2AssuranceApplicationdetailsbynamePostRequest = &v2AssuranceApplicationdetailsbynamePostRequest
	return r
}

func (r ApiV2AssuranceApplicationdetailsbynamePostRequest) Execute() (*V2AssuranceApplicationdetailsbynamePost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceApplicationdetailsbynamePostExecute(r)
}

/*
V2AssuranceApplicationdetailsbynamePost Method for V2AssuranceApplicationdetailsbynamePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceApplicationdetailsbynamePostRequest
*/
func (a *DefaultAPIService) V2AssuranceApplicationdetailsbynamePost(ctx context.Context) ApiV2AssuranceApplicationdetailsbynamePostRequest {
	return ApiV2AssuranceApplicationdetailsbynamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceApplicationdetailsbynamePost200Response
func (a *DefaultAPIService) V2AssuranceApplicationdetailsbynamePostExecute(r ApiV2AssuranceApplicationdetailsbynamePostRequest) (*V2AssuranceApplicationdetailsbynamePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceApplicationdetailsbynamePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceApplicationdetailsbynamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/applicationdetailsbyname"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceApplicationdetailsbynamePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceApplicationdetailsbynamePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceApplicationdetailsbynamePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceApplicationprofilesummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceApplicationprofilesummaryPostRequest) Authorization(authorization string) ApiV2AssuranceApplicationprofilesummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceApplicationprofilesummaryPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2AssuranceApplicationprofilesummaryPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2AssuranceApplicationprofilesummaryPostRequest) Execute() (*V2AssuranceApplicationprofilesummaryPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceApplicationprofilesummaryPostExecute(r)
}

/*
V2AssuranceApplicationprofilesummaryPost Method for V2AssuranceApplicationprofilesummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceApplicationprofilesummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceApplicationprofilesummaryPost(ctx context.Context) ApiV2AssuranceApplicationprofilesummaryPostRequest {
	return ApiV2AssuranceApplicationprofilesummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceApplicationprofilesummaryPost200Response
func (a *DefaultAPIService) V2AssuranceApplicationprofilesummaryPostExecute(r ApiV2AssuranceApplicationprofilesummaryPostRequest) (*V2AssuranceApplicationprofilesummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceApplicationprofilesummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceApplicationprofilesummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/applicationprofilesummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketAppServersAllGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketAppServersAllGetRequest) Authorization(authorization string) ApiV2AssuranceBucketAppServersAllGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketAppServersAllGetRequest) Execute() (*V2AssuranceBucketAppServersAllGet200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketAppServersAllGetExecute(r)
}

/*
V2AssuranceBucketAppServersAllGet Method for V2AssuranceBucketAppServersAllGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketAppServersAllGetRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketAppServersAllGet(ctx context.Context) ApiV2AssuranceBucketAppServersAllGetRequest {
	return ApiV2AssuranceBucketAppServersAllGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketAppServersAllGet200Response
func (a *DefaultAPIService) V2AssuranceBucketAppServersAllGetExecute(r ApiV2AssuranceBucketAppServersAllGetRequest) (*V2AssuranceBucketAppServersAllGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketAppServersAllGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketAppServersAllGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-app-servers/all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketAppServersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketAppServersPostRequest *V2AssuranceBucketAppServersPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketAppServersPostRequest) Authorization(authorization string) ApiV2AssuranceBucketAppServersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketAppServersPostRequest) V2AssuranceBucketAppServersPostRequest(v2AssuranceBucketAppServersPostRequest V2AssuranceBucketAppServersPostRequest) ApiV2AssuranceBucketAppServersPostRequest {
	r.v2AssuranceBucketAppServersPostRequest = &v2AssuranceBucketAppServersPostRequest
	return r
}

func (r ApiV2AssuranceBucketAppServersPostRequest) Execute() (*V2AssuranceBucketAppServersPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketAppServersPostExecute(r)
}

/*
V2AssuranceBucketAppServersPost Method for V2AssuranceBucketAppServersPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketAppServersPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketAppServersPost(ctx context.Context) ApiV2AssuranceBucketAppServersPostRequest {
	return ApiV2AssuranceBucketAppServersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketAppServersPost200Response
func (a *DefaultAPIService) V2AssuranceBucketAppServersPostExecute(r ApiV2AssuranceBucketAppServersPostRequest) (*V2AssuranceBucketAppServersPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketAppServersPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketAppServersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-app-servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketAppServersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketAppServersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketAppServersPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketAppsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketAppsPostRequest *V2AssuranceBucketAppsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketAppsPostRequest) Authorization(authorization string) ApiV2AssuranceBucketAppsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketAppsPostRequest) V2AssuranceBucketAppsPostRequest(v2AssuranceBucketAppsPostRequest V2AssuranceBucketAppsPostRequest) ApiV2AssuranceBucketAppsPostRequest {
	r.v2AssuranceBucketAppsPostRequest = &v2AssuranceBucketAppsPostRequest
	return r
}

func (r ApiV2AssuranceBucketAppsPostRequest) Execute() (*V2AssuranceBucketAppsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketAppsPostExecute(r)
}

/*
V2AssuranceBucketAppsPost Method for V2AssuranceBucketAppsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketAppsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketAppsPost(ctx context.Context) ApiV2AssuranceBucketAppsPostRequest {
	return ApiV2AssuranceBucketAppsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketAppsPost200Response
func (a *DefaultAPIService) V2AssuranceBucketAppsPostExecute(r ApiV2AssuranceBucketAppsPostRequest) (*V2AssuranceBucketAppsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketAppsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketAppsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketAppsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketAppsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketAppsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketTopologiesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketTopologiesPostRequest *V2AssuranceBucketTopologiesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketTopologiesPostRequest) Authorization(authorization string) ApiV2AssuranceBucketTopologiesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketTopologiesPostRequest) V2AssuranceBucketTopologiesPostRequest(v2AssuranceBucketTopologiesPostRequest V2AssuranceBucketTopologiesPostRequest) ApiV2AssuranceBucketTopologiesPostRequest {
	r.v2AssuranceBucketTopologiesPostRequest = &v2AssuranceBucketTopologiesPostRequest
	return r
}

func (r ApiV2AssuranceBucketTopologiesPostRequest) Execute() (*V2AssuranceBucketTopologiesPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketTopologiesPostExecute(r)
}

/*
V2AssuranceBucketTopologiesPost Method for V2AssuranceBucketTopologiesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketTopologiesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketTopologiesPost(ctx context.Context) ApiV2AssuranceBucketTopologiesPostRequest {
	return ApiV2AssuranceBucketTopologiesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketTopologiesPost200Response
func (a *DefaultAPIService) V2AssuranceBucketTopologiesPostExecute(r ApiV2AssuranceBucketTopologiesPostRequest) (*V2AssuranceBucketTopologiesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketTopologiesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketTopologiesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucket-topologies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketTopologiesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketTopologiesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketTopologiesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceBucketdetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceBucketdetailsPostRequest *V2AssuranceBucketdetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceBucketdetailsPostRequest) Authorization(authorization string) ApiV2AssuranceBucketdetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceBucketdetailsPostRequest) V2AssuranceBucketdetailsPostRequest(v2AssuranceBucketdetailsPostRequest V2AssuranceBucketdetailsPostRequest) ApiV2AssuranceBucketdetailsPostRequest {
	r.v2AssuranceBucketdetailsPostRequest = &v2AssuranceBucketdetailsPostRequest
	return r
}

func (r ApiV2AssuranceBucketdetailsPostRequest) Execute() (*V2AssuranceBucketdetailsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceBucketdetailsPostExecute(r)
}

/*
V2AssuranceBucketdetailsPost Method for V2AssuranceBucketdetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceBucketdetailsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceBucketdetailsPost(ctx context.Context) ApiV2AssuranceBucketdetailsPostRequest {
	return ApiV2AssuranceBucketdetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceBucketdetailsPost200Response
func (a *DefaultAPIService) V2AssuranceBucketdetailsPostExecute(r ApiV2AssuranceBucketdetailsPostRequest) (*V2AssuranceBucketdetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceBucketdetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceBucketdetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/bucketdetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceBucketdetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceBucketdetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceBucketdetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceCreateUserReportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceCreateUserReportPostRequest *V2AssuranceCreateUserReportPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceCreateUserReportPostRequest) Authorization(authorization string) ApiV2AssuranceCreateUserReportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceCreateUserReportPostRequest) V2AssuranceCreateUserReportPostRequest(v2AssuranceCreateUserReportPostRequest V2AssuranceCreateUserReportPostRequest) ApiV2AssuranceCreateUserReportPostRequest {
	r.v2AssuranceCreateUserReportPostRequest = &v2AssuranceCreateUserReportPostRequest
	return r
}

func (r ApiV2AssuranceCreateUserReportPostRequest) Execute() (*V2AssuranceCreateUserReportPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceCreateUserReportPostExecute(r)
}

/*
V2AssuranceCreateUserReportPost Method for V2AssuranceCreateUserReportPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceCreateUserReportPostRequest
*/
func (a *DefaultAPIService) V2AssuranceCreateUserReportPost(ctx context.Context) ApiV2AssuranceCreateUserReportPostRequest {
	return ApiV2AssuranceCreateUserReportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceCreateUserReportPost200Response
func (a *DefaultAPIService) V2AssuranceCreateUserReportPostExecute(r ApiV2AssuranceCreateUserReportPostRequest) (*V2AssuranceCreateUserReportPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceCreateUserReportPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceCreateUserReportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/create-user-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceCreateUserReportPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceCreateUserReportPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceCreateUserReportPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceCreateclassifiedapplicationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceCreateclassifiedapplicationPostRequest *V2AssuranceCreateclassifiedapplicationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceCreateclassifiedapplicationPostRequest) Authorization(authorization string) ApiV2AssuranceCreateclassifiedapplicationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceCreateclassifiedapplicationPostRequest) V2AssuranceCreateclassifiedapplicationPostRequest(v2AssuranceCreateclassifiedapplicationPostRequest V2AssuranceCreateclassifiedapplicationPostRequest) ApiV2AssuranceCreateclassifiedapplicationPostRequest {
	r.v2AssuranceCreateclassifiedapplicationPostRequest = &v2AssuranceCreateclassifiedapplicationPostRequest
	return r
}

func (r ApiV2AssuranceCreateclassifiedapplicationPostRequest) Execute() (*V2AssuranceCreateclassifiedapplicationPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceCreateclassifiedapplicationPostExecute(r)
}

/*
V2AssuranceCreateclassifiedapplicationPost Method for V2AssuranceCreateclassifiedapplicationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceCreateclassifiedapplicationPostRequest
*/
func (a *DefaultAPIService) V2AssuranceCreateclassifiedapplicationPost(ctx context.Context) ApiV2AssuranceCreateclassifiedapplicationPostRequest {
	return ApiV2AssuranceCreateclassifiedapplicationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceCreateclassifiedapplicationPost200Response
func (a *DefaultAPIService) V2AssuranceCreateclassifiedapplicationPostExecute(r ApiV2AssuranceCreateclassifiedapplicationPostRequest) (*V2AssuranceCreateclassifiedapplicationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceCreateclassifiedapplicationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceCreateclassifiedapplicationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/createclassifiedapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceCreateclassifiedapplicationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceCreateclassifiedapplicationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceCreateclassifiedapplicationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceDeleteUserReportDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	reportId *int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceDeleteUserReportDeleteRequest) Authorization(authorization string) ApiV2AssuranceDeleteUserReportDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV2AssuranceDeleteUserReportDeleteRequest) ReportId(reportId int64) ApiV2AssuranceDeleteUserReportDeleteRequest {
	r.reportId = &reportId
	return r
}

func (r ApiV2AssuranceDeleteUserReportDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssuranceDeleteUserReportDeleteExecute(r)
}

/*
V2AssuranceDeleteUserReportDelete Method for V2AssuranceDeleteUserReportDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceDeleteUserReportDeleteRequest
*/
func (a *DefaultAPIService) V2AssuranceDeleteUserReportDelete(ctx context.Context) ApiV2AssuranceDeleteUserReportDeleteRequest {
	return ApiV2AssuranceDeleteUserReportDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssuranceDeleteUserReportDeleteExecute(r ApiV2AssuranceDeleteUserReportDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceDeleteUserReportDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/delete-user-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.reportId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reportId", r.reportId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	classificationEntryIdList *[]string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) Authorization(authorization string) ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest {
	r.authorization = &authorization
	return r
}

// 
func (r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) ClassificationEntryIdList(classificationEntryIdList []string) ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest {
	r.classificationEntryIdList = &classificationEntryIdList
	return r
}

func (r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssuranceDeleteclassifiedapplicationDeleteExecute(r)
}

/*
V2AssuranceDeleteclassifiedapplicationDelete Method for V2AssuranceDeleteclassifiedapplicationDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest
*/
func (a *DefaultAPIService) V2AssuranceDeleteclassifiedapplicationDelete(ctx context.Context) ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest {
	return ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssuranceDeleteclassifiedapplicationDeleteExecute(r ApiV2AssuranceDeleteclassifiedapplicationDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceDeleteclassifiedapplicationDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/deleteclassifiedapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.classificationEntryIdList != nil {
		t := *r.classificationEntryIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classificationEntryIdList", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classificationEntryIdList", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceDownloadUserReportGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceDownloadUserReportGetRequest) Authorization(authorization string) ApiV2AssuranceDownloadUserReportGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceDownloadUserReportGetRequest) Execute() (*V2AssuranceDownloadUserReportGet200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceDownloadUserReportGetExecute(r)
}

/*
V2AssuranceDownloadUserReportGet Method for V2AssuranceDownloadUserReportGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceDownloadUserReportGetRequest
*/
func (a *DefaultAPIService) V2AssuranceDownloadUserReportGet(ctx context.Context) ApiV2AssuranceDownloadUserReportGetRequest {
	return ApiV2AssuranceDownloadUserReportGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceDownloadUserReportGet200Response
func (a *DefaultAPIService) V2AssuranceDownloadUserReportGetExecute(r ApiV2AssuranceDownloadUserReportGetRequest) (*V2AssuranceDownloadUserReportGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceDownloadUserReportGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceDownloadUserReportGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/download-user-report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceEndpointIntelPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceEndpointIntelPostRequest *V2AssuranceEndpointIntelPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceEndpointIntelPostRequest) Authorization(authorization string) ApiV2AssuranceEndpointIntelPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceEndpointIntelPostRequest) V2AssuranceEndpointIntelPostRequest(v2AssuranceEndpointIntelPostRequest V2AssuranceEndpointIntelPostRequest) ApiV2AssuranceEndpointIntelPostRequest {
	r.v2AssuranceEndpointIntelPostRequest = &v2AssuranceEndpointIntelPostRequest
	return r
}

func (r ApiV2AssuranceEndpointIntelPostRequest) Execute() (*V2AssuranceEndpointIntelPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceEndpointIntelPostExecute(r)
}

/*
V2AssuranceEndpointIntelPost Method for V2AssuranceEndpointIntelPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceEndpointIntelPostRequest
*/
func (a *DefaultAPIService) V2AssuranceEndpointIntelPost(ctx context.Context) ApiV2AssuranceEndpointIntelPostRequest {
	return ApiV2AssuranceEndpointIntelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceEndpointIntelPost200Response
func (a *DefaultAPIService) V2AssuranceEndpointIntelPostExecute(r ApiV2AssuranceEndpointIntelPostRequest) (*V2AssuranceEndpointIntelPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceEndpointIntelPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceEndpointIntelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/endpoint-intel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceEndpointIntelPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceEndpointIntelPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceEndpointIntelPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceEnterprisesummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceEnterprisesummaryPostRequest) Authorization(authorization string) ApiV2AssuranceEnterprisesummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceEnterprisesummaryPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2AssuranceEnterprisesummaryPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2AssuranceEnterprisesummaryPostRequest) Execute() (*V2AssuranceEnterprisesummaryPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceEnterprisesummaryPostExecute(r)
}

/*
V2AssuranceEnterprisesummaryPost Method for V2AssuranceEnterprisesummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceEnterprisesummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceEnterprisesummaryPost(ctx context.Context) ApiV2AssuranceEnterprisesummaryPostRequest {
	return ApiV2AssuranceEnterprisesummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceEnterprisesummaryPost200Response
func (a *DefaultAPIService) V2AssuranceEnterprisesummaryPostExecute(r ApiV2AssuranceEnterprisesummaryPostRequest) (*V2AssuranceEnterprisesummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceEnterprisesummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceEnterprisesummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/enterprisesummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceFlowSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceFlowSummaryPostRequest *V2AssuranceFlowSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceFlowSummaryPostRequest) Authorization(authorization string) ApiV2AssuranceFlowSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceFlowSummaryPostRequest) V2AssuranceFlowSummaryPostRequest(v2AssuranceFlowSummaryPostRequest V2AssuranceFlowSummaryPostRequest) ApiV2AssuranceFlowSummaryPostRequest {
	r.v2AssuranceFlowSummaryPostRequest = &v2AssuranceFlowSummaryPostRequest
	return r
}

func (r ApiV2AssuranceFlowSummaryPostRequest) Execute() (*V2AssuranceFlowSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceFlowSummaryPostExecute(r)
}

/*
V2AssuranceFlowSummaryPost Method for V2AssuranceFlowSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceFlowSummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceFlowSummaryPost(ctx context.Context) ApiV2AssuranceFlowSummaryPostRequest {
	return ApiV2AssuranceFlowSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceFlowSummaryPost200Response
func (a *DefaultAPIService) V2AssuranceFlowSummaryPostExecute(r ApiV2AssuranceFlowSummaryPostRequest) (*V2AssuranceFlowSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceFlowSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceFlowSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/flow-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceFlowSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceFlowSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceFlowSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceGetclassifiedapplicationlistGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceGetclassifiedapplicationlistGetRequest) Authorization(authorization string) ApiV2AssuranceGetclassifiedapplicationlistGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceGetclassifiedapplicationlistGetRequest) Execute() (*V2AssuranceGetclassifiedapplicationlistGet200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceGetclassifiedapplicationlistGetExecute(r)
}

/*
V2AssuranceGetclassifiedapplicationlistGet Method for V2AssuranceGetclassifiedapplicationlistGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceGetclassifiedapplicationlistGetRequest
*/
func (a *DefaultAPIService) V2AssuranceGetclassifiedapplicationlistGet(ctx context.Context) ApiV2AssuranceGetclassifiedapplicationlistGetRequest {
	return ApiV2AssuranceGetclassifiedapplicationlistGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceGetclassifiedapplicationlistGet200Response
func (a *DefaultAPIService) V2AssuranceGetclassifiedapplicationlistGetExecute(r ApiV2AssuranceGetclassifiedapplicationlistGetRequest) (*V2AssuranceGetclassifiedapplicationlistGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceGetclassifiedapplicationlistGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceGetclassifiedapplicationlistGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/getclassifiedapplicationlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceReadUserReportListGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceReadUserReportListGetRequest) Authorization(authorization string) ApiV2AssuranceReadUserReportListGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceReadUserReportListGetRequest) Execute() (*V2AssuranceReadUserReportListGet200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceReadUserReportListGetExecute(r)
}

/*
V2AssuranceReadUserReportListGet Method for V2AssuranceReadUserReportListGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceReadUserReportListGetRequest
*/
func (a *DefaultAPIService) V2AssuranceReadUserReportListGet(ctx context.Context) ApiV2AssuranceReadUserReportListGetRequest {
	return ApiV2AssuranceReadUserReportListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceReadUserReportListGet200Response
func (a *DefaultAPIService) V2AssuranceReadUserReportListGetExecute(r ApiV2AssuranceReadUserReportListGetRequest) (*V2AssuranceReadUserReportListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceReadUserReportListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceReadUserReportListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/read-user-report-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceScoredetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceScoredetailsPostRequest) Authorization(authorization string) ApiV2AssuranceScoredetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceScoredetailsPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2AssuranceScoredetailsPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2AssuranceScoredetailsPostRequest) Execute() (*V2AssuranceScoredetailsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceScoredetailsPostExecute(r)
}

/*
V2AssuranceScoredetailsPost Method for V2AssuranceScoredetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceScoredetailsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceScoredetailsPost(ctx context.Context) ApiV2AssuranceScoredetailsPostRequest {
	return ApiV2AssuranceScoredetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceScoredetailsPost200Response
func (a *DefaultAPIService) V2AssuranceScoredetailsPostExecute(r ApiV2AssuranceScoredetailsPostRequest) (*V2AssuranceScoredetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceScoredetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceScoredetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/scoredetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyClientSessionDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyClientSessionDetailsPostRequest *V2AssuranceTopologyClientSessionDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyClientSessionDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) V2AssuranceTopologyClientSessionDetailsPostRequest(v2AssuranceTopologyClientSessionDetailsPostRequest V2AssuranceTopologyClientSessionDetailsPostRequest) ApiV2AssuranceTopologyClientSessionDetailsPostRequest {
	r.v2AssuranceTopologyClientSessionDetailsPostRequest = &v2AssuranceTopologyClientSessionDetailsPostRequest
	return r
}

func (r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) Execute() (*V2AssuranceTopologyClientSessionDetailsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyClientSessionDetailsPostExecute(r)
}

/*
V2AssuranceTopologyClientSessionDetailsPost Method for V2AssuranceTopologyClientSessionDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyClientSessionDetailsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionDetailsPost(ctx context.Context) ApiV2AssuranceTopologyClientSessionDetailsPostRequest {
	return ApiV2AssuranceTopologyClientSessionDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyClientSessionDetailsPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionDetailsPostExecute(r ApiV2AssuranceTopologyClientSessionDetailsPostRequest) (*V2AssuranceTopologyClientSessionDetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyClientSessionDetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyClientSessionDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-client-session-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyClientSessionDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyClientSessionDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyClientSessionDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyClientSessionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyClientSessionsPostRequest *V2AssuranceTopologyClientSessionsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyClientSessionsPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyClientSessionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyClientSessionsPostRequest) V2AssuranceTopologyClientSessionsPostRequest(v2AssuranceTopologyClientSessionsPostRequest V2AssuranceTopologyClientSessionsPostRequest) ApiV2AssuranceTopologyClientSessionsPostRequest {
	r.v2AssuranceTopologyClientSessionsPostRequest = &v2AssuranceTopologyClientSessionsPostRequest
	return r
}

func (r ApiV2AssuranceTopologyClientSessionsPostRequest) Execute() (*V2AssuranceTopologyClientSessionsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyClientSessionsPostExecute(r)
}

/*
V2AssuranceTopologyClientSessionsPost Method for V2AssuranceTopologyClientSessionsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyClientSessionsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionsPost(ctx context.Context) ApiV2AssuranceTopologyClientSessionsPostRequest {
	return ApiV2AssuranceTopologyClientSessionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyClientSessionsPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyClientSessionsPostExecute(r ApiV2AssuranceTopologyClientSessionsPostRequest) (*V2AssuranceTopologyClientSessionsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyClientSessionsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyClientSessionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-client-sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyClientSessionsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyClientSessionsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyClientSessionsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyClientSummariesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyClientSummariesPostRequest *V2AssuranceTopologyClientSummariesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyClientSummariesPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyClientSummariesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyClientSummariesPostRequest) V2AssuranceTopologyClientSummariesPostRequest(v2AssuranceTopologyClientSummariesPostRequest V2AssuranceTopologyClientSummariesPostRequest) ApiV2AssuranceTopologyClientSummariesPostRequest {
	r.v2AssuranceTopologyClientSummariesPostRequest = &v2AssuranceTopologyClientSummariesPostRequest
	return r
}

func (r ApiV2AssuranceTopologyClientSummariesPostRequest) Execute() (*V2AssuranceTopologyClientSummariesPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyClientSummariesPostExecute(r)
}

/*
V2AssuranceTopologyClientSummariesPost Method for V2AssuranceTopologyClientSummariesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyClientSummariesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyClientSummariesPost(ctx context.Context) ApiV2AssuranceTopologyClientSummariesPostRequest {
	return ApiV2AssuranceTopologyClientSummariesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyClientSummariesPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyClientSummariesPostExecute(r ApiV2AssuranceTopologyClientSummariesPostRequest) (*V2AssuranceTopologyClientSummariesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyClientSummariesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyClientSummariesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-client-summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyClientSummariesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyClientSummariesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyClientSummariesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyFlowsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyFlowsPostRequest *V2AssuranceTopologyFlowsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyFlowsPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyFlowsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyFlowsPostRequest) V2AssuranceTopologyFlowsPostRequest(v2AssuranceTopologyFlowsPostRequest V2AssuranceTopologyFlowsPostRequest) ApiV2AssuranceTopologyFlowsPostRequest {
	r.v2AssuranceTopologyFlowsPostRequest = &v2AssuranceTopologyFlowsPostRequest
	return r
}

func (r ApiV2AssuranceTopologyFlowsPostRequest) Execute() (*V2AssuranceTopologyFlowsPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyFlowsPostExecute(r)
}

/*
V2AssuranceTopologyFlowsPost Method for V2AssuranceTopologyFlowsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyFlowsPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyFlowsPost(ctx context.Context) ApiV2AssuranceTopologyFlowsPostRequest {
	return ApiV2AssuranceTopologyFlowsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyFlowsPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyFlowsPostExecute(r ApiV2AssuranceTopologyFlowsPostRequest) (*V2AssuranceTopologyFlowsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyFlowsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyFlowsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyFlowsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyFlowsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyFlowsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyInventoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyInventoryPostRequest *V2AssuranceTopologyInventoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyInventoryPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyInventoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyInventoryPostRequest) V2AssuranceTopologyInventoryPostRequest(v2AssuranceTopologyInventoryPostRequest V2AssuranceTopologyInventoryPostRequest) ApiV2AssuranceTopologyInventoryPostRequest {
	r.v2AssuranceTopologyInventoryPostRequest = &v2AssuranceTopologyInventoryPostRequest
	return r
}

func (r ApiV2AssuranceTopologyInventoryPostRequest) Execute() (*V2AssuranceTopologyInventoryPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyInventoryPostExecute(r)
}

/*
V2AssuranceTopologyInventoryPost Method for V2AssuranceTopologyInventoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyInventoryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyInventoryPost(ctx context.Context) ApiV2AssuranceTopologyInventoryPostRequest {
	return ApiV2AssuranceTopologyInventoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyInventoryPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyInventoryPostExecute(r ApiV2AssuranceTopologyInventoryPostRequest) (*V2AssuranceTopologyInventoryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyInventoryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyInventoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-inventory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyInventoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyInventoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyInventoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyOverviewPostRequest *V2AssuranceTopologyOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyOverviewPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyOverviewPostRequest) V2AssuranceTopologyOverviewPostRequest(v2AssuranceTopologyOverviewPostRequest V2AssuranceTopologyOverviewPostRequest) ApiV2AssuranceTopologyOverviewPostRequest {
	r.v2AssuranceTopologyOverviewPostRequest = &v2AssuranceTopologyOverviewPostRequest
	return r
}

func (r ApiV2AssuranceTopologyOverviewPostRequest) Execute() (*V2AssuranceTopologyOverviewPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyOverviewPostExecute(r)
}

/*
V2AssuranceTopologyOverviewPost Method for V2AssuranceTopologyOverviewPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyOverviewPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyOverviewPost(ctx context.Context) ApiV2AssuranceTopologyOverviewPostRequest {
	return ApiV2AssuranceTopologyOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyOverviewPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyOverviewPostExecute(r ApiV2AssuranceTopologyOverviewPostRequest) (*V2AssuranceTopologyOverviewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyOverviewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologyRegionSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologyRegionSummaryPostRequest *V2AssuranceTopologyRegionSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologyRegionSummaryPostRequest) Authorization(authorization string) ApiV2AssuranceTopologyRegionSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologyRegionSummaryPostRequest) V2AssuranceTopologyRegionSummaryPostRequest(v2AssuranceTopologyRegionSummaryPostRequest V2AssuranceTopologyRegionSummaryPostRequest) ApiV2AssuranceTopologyRegionSummaryPostRequest {
	r.v2AssuranceTopologyRegionSummaryPostRequest = &v2AssuranceTopologyRegionSummaryPostRequest
	return r
}

func (r ApiV2AssuranceTopologyRegionSummaryPostRequest) Execute() (*V2AssuranceTopologyRegionSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologyRegionSummaryPostExecute(r)
}

/*
V2AssuranceTopologyRegionSummaryPost Method for V2AssuranceTopologyRegionSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologyRegionSummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologyRegionSummaryPost(ctx context.Context) ApiV2AssuranceTopologyRegionSummaryPostRequest {
	return ApiV2AssuranceTopologyRegionSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologyRegionSummaryPost200Response
func (a *DefaultAPIService) V2AssuranceTopologyRegionSummaryPostExecute(r ApiV2AssuranceTopologyRegionSummaryPostRequest) (*V2AssuranceTopologyRegionSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologyRegionSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologyRegionSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-region-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologyRegionSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologyRegionSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologyRegionSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceTopologySiteSummariesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceTopologySiteSummariesPostRequest *V2AssuranceTopologySiteSummariesPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceTopologySiteSummariesPostRequest) Authorization(authorization string) ApiV2AssuranceTopologySiteSummariesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceTopologySiteSummariesPostRequest) V2AssuranceTopologySiteSummariesPostRequest(v2AssuranceTopologySiteSummariesPostRequest V2AssuranceTopologySiteSummariesPostRequest) ApiV2AssuranceTopologySiteSummariesPostRequest {
	r.v2AssuranceTopologySiteSummariesPostRequest = &v2AssuranceTopologySiteSummariesPostRequest
	return r
}

func (r ApiV2AssuranceTopologySiteSummariesPostRequest) Execute() (*V2AssuranceTopologySiteSummariesPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceTopologySiteSummariesPostExecute(r)
}

/*
V2AssuranceTopologySiteSummariesPost Method for V2AssuranceTopologySiteSummariesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceTopologySiteSummariesPostRequest
*/
func (a *DefaultAPIService) V2AssuranceTopologySiteSummariesPost(ctx context.Context) ApiV2AssuranceTopologySiteSummariesPostRequest {
	return ApiV2AssuranceTopologySiteSummariesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceTopologySiteSummariesPost200Response
func (a *DefaultAPIService) V2AssuranceTopologySiteSummariesPostExecute(r ApiV2AssuranceTopologySiteSummariesPostRequest) (*V2AssuranceTopologySiteSummariesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceTopologySiteSummariesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceTopologySiteSummariesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/topology-site-summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceTopologySiteSummariesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceTopologySiteSummariesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceTopologySiteSummariesPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) Authorization(authorization string) ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) Execute() (*V2AssuranceApplicationprofilesummaryPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceUnclassifiedapplicationprofilesummaryPostExecute(r)
}

/*
V2AssuranceUnclassifiedapplicationprofilesummaryPost Method for V2AssuranceUnclassifiedapplicationprofilesummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest
*/
func (a *DefaultAPIService) V2AssuranceUnclassifiedapplicationprofilesummaryPost(ctx context.Context) ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest {
	return ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AssuranceApplicationprofilesummaryPost200Response
func (a *DefaultAPIService) V2AssuranceUnclassifiedapplicationprofilesummaryPostExecute(r ApiV2AssuranceUnclassifiedapplicationprofilesummaryPostRequest) (*V2AssuranceApplicationprofilesummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AssuranceApplicationprofilesummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceUnclassifiedapplicationprofilesummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/unclassifiedapplicationprofilesummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceUpdateclassifiedapplicationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AssuranceGetclassifiedapplicationlistGet200Response *V2AssuranceGetclassifiedapplicationlistGet200Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) Authorization(authorization string) ApiV2AssuranceUpdateclassifiedapplicationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) V2AssuranceGetclassifiedapplicationlistGet200Response(v2AssuranceGetclassifiedapplicationlistGet200Response V2AssuranceGetclassifiedapplicationlistGet200Response) ApiV2AssuranceUpdateclassifiedapplicationPostRequest {
	r.v2AssuranceGetclassifiedapplicationlistGet200Response = &v2AssuranceGetclassifiedapplicationlistGet200Response
	return r
}

func (r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2AssuranceUpdateclassifiedapplicationPostExecute(r)
}

/*
V2AssuranceUpdateclassifiedapplicationPost Method for V2AssuranceUpdateclassifiedapplicationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceUpdateclassifiedapplicationPostRequest
*/
func (a *DefaultAPIService) V2AssuranceUpdateclassifiedapplicationPost(ctx context.Context) ApiV2AssuranceUpdateclassifiedapplicationPostRequest {
	return ApiV2AssuranceUpdateclassifiedapplicationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2AssuranceUpdateclassifiedapplicationPostExecute(r ApiV2AssuranceUpdateclassifiedapplicationPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceUpdateclassifiedapplicationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/updateclassifiedapplication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AssuranceGetclassifiedapplicationlistGet200Response == nil {
		return localVarReturnValue, nil, reportError("v2AssuranceGetclassifiedapplicationlistGet200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AssuranceGetclassifiedapplicationlistGet200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AssuranceVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AssuranceVersionPostRequest) Authorization(authorization string) ApiV2AssuranceVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AssuranceVersionPostRequest) Body(body map[string]interface{}) ApiV2AssuranceVersionPostRequest {
	r.body = &body
	return r
}

func (r ApiV2AssuranceVersionPostRequest) Execute() (*V2VersionPost200Response, *http.Response, error) {
	return r.ApiService.V2AssuranceVersionPostExecute(r)
}

/*
V2AssuranceVersionPost Method for V2AssuranceVersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AssuranceVersionPostRequest
*/
func (a *DefaultAPIService) V2AssuranceVersionPost(ctx context.Context) ApiV2AssuranceVersionPostRequest {
	return ApiV2AssuranceVersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2VersionPost200Response
func (a *DefaultAPIService) V2AssuranceVersionPostExecute(r ApiV2AssuranceVersionPostRequest) (*V2VersionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2VersionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AssuranceVersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/assurance/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2AuditLogsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AuditLogsPostRequest *V2AuditLogsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2AuditLogsPostRequest) Authorization(authorization string) ApiV2AuditLogsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2AuditLogsPostRequest) V2AuditLogsPostRequest(v2AuditLogsPostRequest V2AuditLogsPostRequest) ApiV2AuditLogsPostRequest {
	r.v2AuditLogsPostRequest = &v2AuditLogsPostRequest
	return r
}

func (r ApiV2AuditLogsPostRequest) Execute() (*V2AuditLogsPost200Response, *http.Response, error) {
	return r.ApiService.V2AuditLogsPostExecute(r)
}

/*
V2AuditLogsPost Method for V2AuditLogsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2AuditLogsPostRequest
*/
func (a *DefaultAPIService) V2AuditLogsPost(ctx context.Context) ApiV2AuditLogsPostRequest {
	return ApiV2AuditLogsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2AuditLogsPost200Response
func (a *DefaultAPIService) V2AuditLogsPostExecute(r ApiV2AuditLogsPostRequest) (*V2AuditLogsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AuditLogsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2AuditLogsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/audit/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AuditLogsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AuditLogsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AuditLogsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ChildalertlistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ChildalertlistPostRequest *V2ChildalertlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ChildalertlistPostRequest) Authorization(authorization string) ApiV2ChildalertlistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ChildalertlistPostRequest) V2ChildalertlistPostRequest(v2ChildalertlistPostRequest V2ChildalertlistPostRequest) ApiV2ChildalertlistPostRequest {
	r.v2ChildalertlistPostRequest = &v2ChildalertlistPostRequest
	return r
}

func (r ApiV2ChildalertlistPostRequest) Execute() (*V2ChildalertlistPost200Response, *http.Response, error) {
	return r.ApiService.V2ChildalertlistPostExecute(r)
}

/*
V2ChildalertlistPost Method for V2ChildalertlistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ChildalertlistPostRequest
*/
func (a *DefaultAPIService) V2ChildalertlistPost(ctx context.Context) ApiV2ChildalertlistPostRequest {
	return ApiV2ChildalertlistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ChildalertlistPost200Response
func (a *DefaultAPIService) V2ChildalertlistPostExecute(r ApiV2ChildalertlistPostRequest) (*V2ChildalertlistPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ChildalertlistPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ChildalertlistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/childalertlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ChildalertlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ChildalertlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ChildalertlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2DeviceDeviceIdLanSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2DeviceDeviceIdLanSegmentsPostRequest) Authorization(authorization string) ApiV2DeviceDeviceIdLanSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2DeviceDeviceIdLanSegmentsPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2DeviceDeviceIdLanSegmentsPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2DeviceDeviceIdLanSegmentsPostRequest) Execute() (*V2DeviceDeviceIdLanSegmentsPost200Response, *http.Response, error) {
	return r.ApiService.V2DeviceDeviceIdLanSegmentsPostExecute(r)
}

/*
V2DeviceDeviceIdLanSegmentsPost Method for V2DeviceDeviceIdLanSegmentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV2DeviceDeviceIdLanSegmentsPostRequest
*/
func (a *DefaultAPIService) V2DeviceDeviceIdLanSegmentsPost(ctx context.Context, deviceId int64) ApiV2DeviceDeviceIdLanSegmentsPostRequest {
	return ApiV2DeviceDeviceIdLanSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V2DeviceDeviceIdLanSegmentsPost200Response
func (a *DefaultAPIService) V2DeviceDeviceIdLanSegmentsPostExecute(r ApiV2DeviceDeviceIdLanSegmentsPostRequest) (*V2DeviceDeviceIdLanSegmentsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DeviceDeviceIdLanSegmentsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2DeviceDeviceIdLanSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/device/{deviceId}/lan-segments"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2DeviceDeviceIdTopologyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	deviceId int64
	v2DeviceDeviceIdTopologyPostRequest *V2DeviceDeviceIdTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2DeviceDeviceIdTopologyPostRequest) Authorization(authorization string) ApiV2DeviceDeviceIdTopologyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2DeviceDeviceIdTopologyPostRequest) V2DeviceDeviceIdTopologyPostRequest(v2DeviceDeviceIdTopologyPostRequest V2DeviceDeviceIdTopologyPostRequest) ApiV2DeviceDeviceIdTopologyPostRequest {
	r.v2DeviceDeviceIdTopologyPostRequest = &v2DeviceDeviceIdTopologyPostRequest
	return r
}

func (r ApiV2DeviceDeviceIdTopologyPostRequest) Execute() (*V2DeviceDeviceIdTopologyPost200Response, *http.Response, error) {
	return r.ApiService.V2DeviceDeviceIdTopologyPostExecute(r)
}

/*
V2DeviceDeviceIdTopologyPost Method for V2DeviceDeviceIdTopologyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId 
 @return ApiV2DeviceDeviceIdTopologyPostRequest
*/
func (a *DefaultAPIService) V2DeviceDeviceIdTopologyPost(ctx context.Context, deviceId int64) ApiV2DeviceDeviceIdTopologyPostRequest {
	return ApiV2DeviceDeviceIdTopologyPostRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return V2DeviceDeviceIdTopologyPost200Response
func (a *DefaultAPIService) V2DeviceDeviceIdTopologyPostExecute(r ApiV2DeviceDeviceIdTopologyPostRequest) (*V2DeviceDeviceIdTopologyPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DeviceDeviceIdTopologyPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2DeviceDeviceIdTopologyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/device/{deviceId}/topology"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2DeviceDeviceIdTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2DeviceDeviceIdTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2DeviceDeviceIdTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetConsumersUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetConsumersUsageTopPostRequest *V2ExtranetConsumersUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetConsumersUsageTopPostRequest) Authorization(authorization string) ApiV2ExtranetConsumersUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetConsumersUsageTopPostRequest) V2ExtranetConsumersUsageTopPostRequest(v2ExtranetConsumersUsageTopPostRequest V2ExtranetConsumersUsageTopPostRequest) ApiV2ExtranetConsumersUsageTopPostRequest {
	r.v2ExtranetConsumersUsageTopPostRequest = &v2ExtranetConsumersUsageTopPostRequest
	return r
}

func (r ApiV2ExtranetConsumersUsageTopPostRequest) Execute() (*V2ExtranetConsumersUsageTopPost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetConsumersUsageTopPostExecute(r)
}

/*
V2ExtranetConsumersUsageTopPost Method for V2ExtranetConsumersUsageTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetConsumersUsageTopPostRequest
*/
func (a *DefaultAPIService) V2ExtranetConsumersUsageTopPost(ctx context.Context) ApiV2ExtranetConsumersUsageTopPostRequest {
	return ApiV2ExtranetConsumersUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetConsumersUsageTopPost200Response
func (a *DefaultAPIService) V2ExtranetConsumersUsageTopPostExecute(r ApiV2ExtranetConsumersUsageTopPostRequest) (*V2ExtranetConsumersUsageTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetConsumersUsageTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetConsumersUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/consumers-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetConsumersUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetConsumersUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetConsumersUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetLanSegmentsUsageTopPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetLanSegmentsUsageTopPostRequest *V2ExtranetLanSegmentsUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetLanSegmentsUsageTopPostRequest) Authorization(authorization string) ApiV2ExtranetLanSegmentsUsageTopPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetLanSegmentsUsageTopPostRequest) V2ExtranetLanSegmentsUsageTopPostRequest(v2ExtranetLanSegmentsUsageTopPostRequest V2ExtranetLanSegmentsUsageTopPostRequest) ApiV2ExtranetLanSegmentsUsageTopPostRequest {
	r.v2ExtranetLanSegmentsUsageTopPostRequest = &v2ExtranetLanSegmentsUsageTopPostRequest
	return r
}

func (r ApiV2ExtranetLanSegmentsUsageTopPostRequest) Execute() (*V2ExtranetLanSegmentsUsageTopPost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetLanSegmentsUsageTopPostExecute(r)
}

/*
V2ExtranetLanSegmentsUsageTopPost Method for V2ExtranetLanSegmentsUsageTopPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetLanSegmentsUsageTopPostRequest
*/
func (a *DefaultAPIService) V2ExtranetLanSegmentsUsageTopPost(ctx context.Context) ApiV2ExtranetLanSegmentsUsageTopPostRequest {
	return ApiV2ExtranetLanSegmentsUsageTopPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetLanSegmentsUsageTopPost200Response
func (a *DefaultAPIService) V2ExtranetLanSegmentsUsageTopPostExecute(r ApiV2ExtranetLanSegmentsUsageTopPostRequest) (*V2ExtranetLanSegmentsUsageTopPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetLanSegmentsUsageTopPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetLanSegmentsUsageTopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/lan-segments-usage/top"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetLanSegmentsUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetLanSegmentsUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetLanSegmentsUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetServiceOvertimeConsumptionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetSitesConsumptionOverviewPostRequest *V2ExtranetSitesConsumptionOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) Authorization(authorization string) ApiV2ExtranetServiceOvertimeConsumptionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) V2ExtranetSitesConsumptionOverviewPostRequest(v2ExtranetSitesConsumptionOverviewPostRequest V2ExtranetSitesConsumptionOverviewPostRequest) ApiV2ExtranetServiceOvertimeConsumptionPostRequest {
	r.v2ExtranetSitesConsumptionOverviewPostRequest = &v2ExtranetSitesConsumptionOverviewPostRequest
	return r
}

func (r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) Execute() (*V2ExtranetServiceOvertimeConsumptionPost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetServiceOvertimeConsumptionPostExecute(r)
}

/*
V2ExtranetServiceOvertimeConsumptionPost Method for V2ExtranetServiceOvertimeConsumptionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetServiceOvertimeConsumptionPostRequest
*/
func (a *DefaultAPIService) V2ExtranetServiceOvertimeConsumptionPost(ctx context.Context) ApiV2ExtranetServiceOvertimeConsumptionPostRequest {
	return ApiV2ExtranetServiceOvertimeConsumptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetServiceOvertimeConsumptionPost200Response
func (a *DefaultAPIService) V2ExtranetServiceOvertimeConsumptionPostExecute(r ApiV2ExtranetServiceOvertimeConsumptionPostRequest) (*V2ExtranetServiceOvertimeConsumptionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetServiceOvertimeConsumptionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetServiceOvertimeConsumptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/service-overtime-consumption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetSitesConsumptionOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetSitesConsumptionOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetSitesConsumptionOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetSitesConsumptionOverviewPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetSitesConsumptionOverviewPostRequest *V2ExtranetSitesConsumptionOverviewPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetSitesConsumptionOverviewPostRequest) Authorization(authorization string) ApiV2ExtranetSitesConsumptionOverviewPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetSitesConsumptionOverviewPostRequest) V2ExtranetSitesConsumptionOverviewPostRequest(v2ExtranetSitesConsumptionOverviewPostRequest V2ExtranetSitesConsumptionOverviewPostRequest) ApiV2ExtranetSitesConsumptionOverviewPostRequest {
	r.v2ExtranetSitesConsumptionOverviewPostRequest = &v2ExtranetSitesConsumptionOverviewPostRequest
	return r
}

func (r ApiV2ExtranetSitesConsumptionOverviewPostRequest) Execute() (*V2ExtranetSitesConsumptionOverviewPost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetSitesConsumptionOverviewPostExecute(r)
}

/*
V2ExtranetSitesConsumptionOverviewPost Method for V2ExtranetSitesConsumptionOverviewPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetSitesConsumptionOverviewPostRequest
*/
func (a *DefaultAPIService) V2ExtranetSitesConsumptionOverviewPost(ctx context.Context) ApiV2ExtranetSitesConsumptionOverviewPostRequest {
	return ApiV2ExtranetSitesConsumptionOverviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetSitesConsumptionOverviewPost200Response
func (a *DefaultAPIService) V2ExtranetSitesConsumptionOverviewPostExecute(r ApiV2ExtranetSitesConsumptionOverviewPostRequest) (*V2ExtranetSitesConsumptionOverviewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetSitesConsumptionOverviewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetSitesConsumptionOverviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/sites-consumption-overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetSitesConsumptionOverviewPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetSitesConsumptionOverviewPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetSitesConsumptionOverviewPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetSitesUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1ExtranetSitesUsagePostRequest *V1ExtranetSitesUsagePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetSitesUsagePostRequest) Authorization(authorization string) ApiV2ExtranetSitesUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetSitesUsagePostRequest) V1ExtranetSitesUsagePostRequest(v1ExtranetSitesUsagePostRequest V1ExtranetSitesUsagePostRequest) ApiV2ExtranetSitesUsagePostRequest {
	r.v1ExtranetSitesUsagePostRequest = &v1ExtranetSitesUsagePostRequest
	return r
}

func (r ApiV2ExtranetSitesUsagePostRequest) Execute() (*V1ExtranetSitesUsagePost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetSitesUsagePostExecute(r)
}

/*
V2ExtranetSitesUsagePost Method for V2ExtranetSitesUsagePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetSitesUsagePostRequest
*/
func (a *DefaultAPIService) V2ExtranetSitesUsagePost(ctx context.Context) ApiV2ExtranetSitesUsagePostRequest {
	return ApiV2ExtranetSitesUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1ExtranetSitesUsagePost200Response
func (a *DefaultAPIService) V2ExtranetSitesUsagePostExecute(r ApiV2ExtranetSitesUsagePostRequest) (*V1ExtranetSitesUsagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1ExtranetSitesUsagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetSitesUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/sites-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1ExtranetSitesUsagePostRequest == nil {
		return localVarReturnValue, nil, reportError("v1ExtranetSitesUsagePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1ExtranetSitesUsagePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetTotalUsagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2ExtranetLanSegmentsUsageTopPostRequest *V2ExtranetLanSegmentsUsageTopPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetTotalUsagePostRequest) Authorization(authorization string) ApiV2ExtranetTotalUsagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetTotalUsagePostRequest) V2ExtranetLanSegmentsUsageTopPostRequest(v2ExtranetLanSegmentsUsageTopPostRequest V2ExtranetLanSegmentsUsageTopPostRequest) ApiV2ExtranetTotalUsagePostRequest {
	r.v2ExtranetLanSegmentsUsageTopPostRequest = &v2ExtranetLanSegmentsUsageTopPostRequest
	return r
}

func (r ApiV2ExtranetTotalUsagePostRequest) Execute() (*V2ExtranetTotalUsagePost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetTotalUsagePostExecute(r)
}

/*
V2ExtranetTotalUsagePost Method for V2ExtranetTotalUsagePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetTotalUsagePostRequest
*/
func (a *DefaultAPIService) V2ExtranetTotalUsagePost(ctx context.Context) ApiV2ExtranetTotalUsagePostRequest {
	return ApiV2ExtranetTotalUsagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetTotalUsagePost200Response
func (a *DefaultAPIService) V2ExtranetTotalUsagePostExecute(r ApiV2ExtranetTotalUsagePostRequest) (*V2ExtranetTotalUsagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetTotalUsagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetTotalUsagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranet/total-usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2ExtranetLanSegmentsUsageTopPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2ExtranetLanSegmentsUsageTopPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2ExtranetLanSegmentsUsageTopPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ExtranetsMonitoringConsumersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1PolicyRouteTagSetsPost200Response *V1PolicyRouteTagSetsPost200Response
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ExtranetsMonitoringConsumersPostRequest) Authorization(authorization string) ApiV2ExtranetsMonitoringConsumersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ExtranetsMonitoringConsumersPostRequest) V1PolicyRouteTagSetsPost200Response(v1PolicyRouteTagSetsPost200Response V1PolicyRouteTagSetsPost200Response) ApiV2ExtranetsMonitoringConsumersPostRequest {
	r.v1PolicyRouteTagSetsPost200Response = &v1PolicyRouteTagSetsPost200Response
	return r
}

func (r ApiV2ExtranetsMonitoringConsumersPostRequest) Execute() (*V2ExtranetsMonitoringConsumersPost200Response, *http.Response, error) {
	return r.ApiService.V2ExtranetsMonitoringConsumersPostExecute(r)
}

/*
V2ExtranetsMonitoringConsumersPost Method for V2ExtranetsMonitoringConsumersPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ExtranetsMonitoringConsumersPostRequest
*/
func (a *DefaultAPIService) V2ExtranetsMonitoringConsumersPost(ctx context.Context) ApiV2ExtranetsMonitoringConsumersPostRequest {
	return ApiV2ExtranetsMonitoringConsumersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ExtranetsMonitoringConsumersPost200Response
func (a *DefaultAPIService) V2ExtranetsMonitoringConsumersPostExecute(r ApiV2ExtranetsMonitoringConsumersPostRequest) (*V2ExtranetsMonitoringConsumersPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ExtranetsMonitoringConsumersPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ExtranetsMonitoringConsumersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/extranets-monitoring/consumers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1PolicyRouteTagSetsPost200Response == nil {
		return localVarReturnValue, nil, reportError("v1PolicyRouteTagSetsPost200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1PolicyRouteTagSetsPost200Response
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationGetallEnterpriseIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationGetallEnterpriseIdGetRequest) Authorization(authorization string) ApiV2IntegrationGetallEnterpriseIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationGetallEnterpriseIdGetRequest) Execute() (*V2IntegrationGetallEnterpriseIdGet200Response, *http.Response, error) {
	return r.ApiService.V2IntegrationGetallEnterpriseIdGetExecute(r)
}

/*
V2IntegrationGetallEnterpriseIdGet Method for V2IntegrationGetallEnterpriseIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId Enterprise id
 @return ApiV2IntegrationGetallEnterpriseIdGetRequest
*/
func (a *DefaultAPIService) V2IntegrationGetallEnterpriseIdGet(ctx context.Context, enterpriseId int64) ApiV2IntegrationGetallEnterpriseIdGetRequest {
	return ApiV2IntegrationGetallEnterpriseIdGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
	}
}

// Execute executes the request
//  @return V2IntegrationGetallEnterpriseIdGet200Response
func (a *DefaultAPIService) V2IntegrationGetallEnterpriseIdGetExecute(r ApiV2IntegrationGetallEnterpriseIdGetRequest) (*V2IntegrationGetallEnterpriseIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2IntegrationGetallEnterpriseIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationGetallEnterpriseIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/getall/{enterpriseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationIntegrationIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	integrationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationIntegrationIdDeleteRequest) Authorization(authorization string) ApiV2IntegrationIntegrationIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationIntegrationIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2IntegrationIntegrationIdDeleteExecute(r)
}

/*
V2IntegrationIntegrationIdDelete Method for V2IntegrationIntegrationIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId ID of the integration to be deleted
 @return ApiV2IntegrationIntegrationIdDeleteRequest
*/
func (a *DefaultAPIService) V2IntegrationIntegrationIdDelete(ctx context.Context, integrationId int64) ApiV2IntegrationIntegrationIdDeleteRequest {
	return ApiV2IntegrationIntegrationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2IntegrationIntegrationIdDeleteExecute(r ApiV2IntegrationIntegrationIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationIntegrationIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/{integrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationId"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationIntegrationIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	integrationId int64
	v2IntegrationIntegrationIdPutRequest *V2IntegrationIntegrationIdPutRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationIntegrationIdPutRequest) Authorization(authorization string) ApiV2IntegrationIntegrationIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationIntegrationIdPutRequest) V2IntegrationIntegrationIdPutRequest(v2IntegrationIntegrationIdPutRequest V2IntegrationIntegrationIdPutRequest) ApiV2IntegrationIntegrationIdPutRequest {
	r.v2IntegrationIntegrationIdPutRequest = &v2IntegrationIntegrationIdPutRequest
	return r
}

func (r ApiV2IntegrationIntegrationIdPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2IntegrationIntegrationIdPutExecute(r)
}

/*
V2IntegrationIntegrationIdPut Method for V2IntegrationIntegrationIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId integration id
 @return ApiV2IntegrationIntegrationIdPutRequest
*/
func (a *DefaultAPIService) V2IntegrationIntegrationIdPut(ctx context.Context, integrationId int64) ApiV2IntegrationIntegrationIdPutRequest {
	return ApiV2IntegrationIntegrationIdPutRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2IntegrationIntegrationIdPutExecute(r ApiV2IntegrationIntegrationIdPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationIntegrationIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/{integrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationId"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2IntegrationIntegrationIdPutRequest == nil {
		return localVarReturnValue, nil, reportError("v2IntegrationIntegrationIdPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2IntegrationIntegrationIdPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2IntegrationPostRequest *V2IntegrationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationPostRequest) Authorization(authorization string) ApiV2IntegrationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationPostRequest) V2IntegrationPostRequest(v2IntegrationPostRequest V2IntegrationPostRequest) ApiV2IntegrationPostRequest {
	r.v2IntegrationPostRequest = &v2IntegrationPostRequest
	return r
}

func (r ApiV2IntegrationPostRequest) Execute() (*V2IntegrationPost200Response, *http.Response, error) {
	return r.ApiService.V2IntegrationPostExecute(r)
}

/*
V2IntegrationPost Method for V2IntegrationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2IntegrationPostRequest
*/
func (a *DefaultAPIService) V2IntegrationPost(ctx context.Context) ApiV2IntegrationPostRequest {
	return ApiV2IntegrationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2IntegrationPost200Response
func (a *DefaultAPIService) V2IntegrationPostExecute(r ApiV2IntegrationPostRequest) (*V2IntegrationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2IntegrationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2IntegrationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2IntegrationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2IntegrationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	enterpriseId int64
	integrationId int64
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest) Authorization(authorization string) ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2IntegrationTestEnterpriseIdIntegrationIdGetExecute(r)
}

/*
V2IntegrationTestEnterpriseIdIntegrationIdGet Method for V2IntegrationTestEnterpriseIdIntegrationIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterpriseId Enterprise id
 @param integrationId Integration id
 @return ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest
*/
func (a *DefaultAPIService) V2IntegrationTestEnterpriseIdIntegrationIdGet(ctx context.Context, enterpriseId int64, integrationId int64) ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest {
	return ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		enterpriseId: enterpriseId,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2IntegrationTestEnterpriseIdIntegrationIdGetExecute(r ApiV2IntegrationTestEnterpriseIdIntegrationIdGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2IntegrationTestEnterpriseIdIntegrationIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/integration/test/{enterpriseId}/{integrationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"enterpriseId"+"}", url.PathEscape(parameterValueToString(r.enterpriseId, "enterpriseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationId"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringBfdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringBfdPostRequest *V2MonitoringBfdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringBfdPostRequest) Authorization(authorization string) ApiV2MonitoringBfdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringBfdPostRequest) V2MonitoringBfdPostRequest(v2MonitoringBfdPostRequest V2MonitoringBfdPostRequest) ApiV2MonitoringBfdPostRequest {
	r.v2MonitoringBfdPostRequest = &v2MonitoringBfdPostRequest
	return r
}

func (r ApiV2MonitoringBfdPostRequest) Execute() (*V2MonitoringBfdPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringBfdPostExecute(r)
}

/*
V2MonitoringBfdPost Method for V2MonitoringBfdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringBfdPostRequest
*/
func (a *DefaultAPIService) V2MonitoringBfdPost(ctx context.Context) ApiV2MonitoringBfdPostRequest {
	return ApiV2MonitoringBfdPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringBfdPost200Response
func (a *DefaultAPIService) V2MonitoringBfdPostExecute(r ApiV2MonitoringBfdPostRequest) (*V2MonitoringBfdPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringBfdPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringBfdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/bfd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringBfdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringBfdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringBfdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringBgpPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringBgpPostRequest *V2MonitoringBgpPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringBgpPostRequest) Authorization(authorization string) ApiV2MonitoringBgpPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringBgpPostRequest) V2MonitoringBgpPostRequest(v2MonitoringBgpPostRequest V2MonitoringBgpPostRequest) ApiV2MonitoringBgpPostRequest {
	r.v2MonitoringBgpPostRequest = &v2MonitoringBgpPostRequest
	return r
}

func (r ApiV2MonitoringBgpPostRequest) Execute() (*V2MonitoringBgpPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringBgpPostExecute(r)
}

/*
V2MonitoringBgpPost Method for V2MonitoringBgpPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringBgpPostRequest
*/
func (a *DefaultAPIService) V2MonitoringBgpPost(ctx context.Context) ApiV2MonitoringBgpPostRequest {
	return ApiV2MonitoringBgpPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringBgpPost200Response
func (a *DefaultAPIService) V2MonitoringBgpPostExecute(r ApiV2MonitoringBgpPostRequest) (*V2MonitoringBgpPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringBgpPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringBgpPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/bgp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringBgpPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringBgpPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringBgpPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsBandwidthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsBandwidthPostRequest *V1MonitoringCircuitsBandwidthPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsBandwidthPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsBandwidthPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsBandwidthPostRequest) V1MonitoringCircuitsBandwidthPostRequest(v1MonitoringCircuitsBandwidthPostRequest V1MonitoringCircuitsBandwidthPostRequest) ApiV2MonitoringCircuitsBandwidthPostRequest {
	r.v1MonitoringCircuitsBandwidthPostRequest = &v1MonitoringCircuitsBandwidthPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsBandwidthPostRequest) Execute() (*V1MonitoringCircuitsBandwidthPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsBandwidthPostExecute(r)
}

/*
V2MonitoringCircuitsBandwidthPost Method for V2MonitoringCircuitsBandwidthPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsBandwidthPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsBandwidthPost(ctx context.Context) ApiV2MonitoringCircuitsBandwidthPostRequest {
	return ApiV2MonitoringCircuitsBandwidthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsBandwidthPost200Response
func (a *DefaultAPIService) V2MonitoringCircuitsBandwidthPostExecute(r ApiV2MonitoringCircuitsBandwidthPostRequest) (*V1MonitoringCircuitsBandwidthPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsBandwidthPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsBandwidthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsBandwidthPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsBandwidthPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsBandwidthPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsSummaryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsSummaryPostRequest *V2MonitoringCircuitsSummaryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsSummaryPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsSummaryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsSummaryPostRequest) V2MonitoringCircuitsSummaryPostRequest(v2MonitoringCircuitsSummaryPostRequest V2MonitoringCircuitsSummaryPostRequest) ApiV2MonitoringCircuitsSummaryPostRequest {
	r.v2MonitoringCircuitsSummaryPostRequest = &v2MonitoringCircuitsSummaryPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsSummaryPostRequest) Execute() (*V2MonitoringCircuitsSummaryPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsSummaryPostExecute(r)
}

/*
V2MonitoringCircuitsSummaryPost Method for V2MonitoringCircuitsSummaryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsSummaryPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsSummaryPost(ctx context.Context) ApiV2MonitoringCircuitsSummaryPostRequest {
	return ApiV2MonitoringCircuitsSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringCircuitsSummaryPost200Response
func (a *DefaultAPIService) V2MonitoringCircuitsSummaryPostExecute(r ApiV2MonitoringCircuitsSummaryPostRequest) (*V2MonitoringCircuitsSummaryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringCircuitsSummaryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsSummaryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsSummaryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsSummaryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsUtilizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringCircuitsUtilizationPostRequest *V2MonitoringCircuitsUtilizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsUtilizationPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsUtilizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsUtilizationPostRequest) V2MonitoringCircuitsUtilizationPostRequest(v2MonitoringCircuitsUtilizationPostRequest V2MonitoringCircuitsUtilizationPostRequest) ApiV2MonitoringCircuitsUtilizationPostRequest {
	r.v2MonitoringCircuitsUtilizationPostRequest = &v2MonitoringCircuitsUtilizationPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsUtilizationPostRequest) Execute() (*V2MonitoringCircuitsUtilizationPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsUtilizationPostExecute(r)
}

/*
V2MonitoringCircuitsUtilizationPost Method for V2MonitoringCircuitsUtilizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsUtilizationPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsUtilizationPost(ctx context.Context) ApiV2MonitoringCircuitsUtilizationPostRequest {
	return ApiV2MonitoringCircuitsUtilizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringCircuitsUtilizationPost200Response
func (a *DefaultAPIService) V2MonitoringCircuitsUtilizationPostExecute(r ApiV2MonitoringCircuitsUtilizationPostRequest) (*V2MonitoringCircuitsUtilizationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringCircuitsUtilizationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsUtilizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/utilization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringCircuitsUtilizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringCircuitsUtilizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringCircuitsUtilizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringCircuitsVisualizationPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1MonitoringCircuitsVisualizationPostRequest *V1MonitoringCircuitsVisualizationPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringCircuitsVisualizationPostRequest) Authorization(authorization string) ApiV2MonitoringCircuitsVisualizationPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringCircuitsVisualizationPostRequest) V1MonitoringCircuitsVisualizationPostRequest(v1MonitoringCircuitsVisualizationPostRequest V1MonitoringCircuitsVisualizationPostRequest) ApiV2MonitoringCircuitsVisualizationPostRequest {
	r.v1MonitoringCircuitsVisualizationPostRequest = &v1MonitoringCircuitsVisualizationPostRequest
	return r
}

func (r ApiV2MonitoringCircuitsVisualizationPostRequest) Execute() (*V1MonitoringCircuitsVisualizationPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringCircuitsVisualizationPostExecute(r)
}

/*
V2MonitoringCircuitsVisualizationPost Method for V2MonitoringCircuitsVisualizationPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringCircuitsVisualizationPostRequest
*/
func (a *DefaultAPIService) V2MonitoringCircuitsVisualizationPost(ctx context.Context) ApiV2MonitoringCircuitsVisualizationPostRequest {
	return ApiV2MonitoringCircuitsVisualizationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1MonitoringCircuitsVisualizationPost200Response
func (a *DefaultAPIService) V2MonitoringCircuitsVisualizationPostExecute(r ApiV2MonitoringCircuitsVisualizationPostRequest) (*V1MonitoringCircuitsVisualizationPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1MonitoringCircuitsVisualizationPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringCircuitsVisualizationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/circuits/visualization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1MonitoringCircuitsVisualizationPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1MonitoringCircuitsVisualizationPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1MonitoringCircuitsVisualizationPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetEdgeStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetEdgeStatusGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetEdgeStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetEdgeStatusGetRequest) Execute() (*V2MonitoringExtranetEdgeStatusGet200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetEdgeStatusGetExecute(r)
}

/*
V2MonitoringExtranetEdgeStatusGet Method for V2MonitoringExtranetEdgeStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetEdgeStatusGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetEdgeStatusGet(ctx context.Context) ApiV2MonitoringExtranetEdgeStatusGetRequest {
	return ApiV2MonitoringExtranetEdgeStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetEdgeStatusGet200Response
func (a *DefaultAPIService) V2MonitoringExtranetEdgeStatusGetExecute(r ApiV2MonitoringExtranetEdgeStatusGetRequest) (*V2MonitoringExtranetEdgeStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetEdgeStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetEdgeStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/edge-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetLogDetailsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringExtranetLogDetailsPostRequest *V2MonitoringExtranetLogDetailsPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetLogDetailsPostRequest) Authorization(authorization string) ApiV2MonitoringExtranetLogDetailsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetLogDetailsPostRequest) V2MonitoringExtranetLogDetailsPostRequest(v2MonitoringExtranetLogDetailsPostRequest V2MonitoringExtranetLogDetailsPostRequest) ApiV2MonitoringExtranetLogDetailsPostRequest {
	r.v2MonitoringExtranetLogDetailsPostRequest = &v2MonitoringExtranetLogDetailsPostRequest
	return r
}

func (r ApiV2MonitoringExtranetLogDetailsPostRequest) Execute() (*V2MonitoringExtranetLogDetailsPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetLogDetailsPostExecute(r)
}

/*
V2MonitoringExtranetLogDetailsPost Method for V2MonitoringExtranetLogDetailsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetLogDetailsPostRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetLogDetailsPost(ctx context.Context) ApiV2MonitoringExtranetLogDetailsPostRequest {
	return ApiV2MonitoringExtranetLogDetailsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetLogDetailsPost200Response
func (a *DefaultAPIService) V2MonitoringExtranetLogDetailsPostExecute(r ApiV2MonitoringExtranetLogDetailsPostRequest) (*V2MonitoringExtranetLogDetailsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetLogDetailsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetLogDetailsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/log-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringExtranetLogDetailsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringExtranetLogDetailsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringExtranetLogDetailsPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetServiceStatusDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetServiceStatusDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) Execute() (*V2MonitoringExtranetServiceStatusDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetServiceStatusDetailsGetExecute(r)
}

/*
V2MonitoringExtranetServiceStatusDetailsGet Method for V2MonitoringExtranetServiceStatusDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetServiceStatusDetailsGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusDetailsGet(ctx context.Context) ApiV2MonitoringExtranetServiceStatusDetailsGetRequest {
	return ApiV2MonitoringExtranetServiceStatusDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetServiceStatusDetailsGet200Response
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusDetailsGetExecute(r ApiV2MonitoringExtranetServiceStatusDetailsGetRequest) (*V2MonitoringExtranetServiceStatusDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetServiceStatusDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetServiceStatusDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/service-status/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetServiceStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetServiceStatusGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetServiceStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetServiceStatusGetRequest) Execute() (*V2MonitoringExtranetServiceStatusGet200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetServiceStatusGetExecute(r)
}

/*
V2MonitoringExtranetServiceStatusGet Method for V2MonitoringExtranetServiceStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetServiceStatusGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusGet(ctx context.Context) ApiV2MonitoringExtranetServiceStatusGetRequest {
	return ApiV2MonitoringExtranetServiceStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetServiceStatusGet200Response
func (a *DefaultAPIService) V2MonitoringExtranetServiceStatusGetExecute(r ApiV2MonitoringExtranetServiceStatusGetRequest) (*V2MonitoringExtranetServiceStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetServiceStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetServiceStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/service-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetSiteStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetSiteStatusGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetSiteStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetSiteStatusGetRequest) Execute() (*V2MonitoringExtranetServiceStatusDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetSiteStatusGetExecute(r)
}

/*
V2MonitoringExtranetSiteStatusGet Method for V2MonitoringExtranetSiteStatusGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetSiteStatusGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetSiteStatusGet(ctx context.Context) ApiV2MonitoringExtranetSiteStatusGetRequest {
	return ApiV2MonitoringExtranetSiteStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetServiceStatusDetailsGet200Response
func (a *DefaultAPIService) V2MonitoringExtranetSiteStatusGetExecute(r ApiV2MonitoringExtranetSiteStatusGetRequest) (*V2MonitoringExtranetServiceStatusDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetServiceStatusDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetSiteStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/site-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringExtranetStatusDetailsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) Authorization(authorization string) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringExtranetStatusDetailsGetRequest) Execute() (*V2MonitoringExtranetStatusDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringExtranetStatusDetailsGetExecute(r)
}

/*
V2MonitoringExtranetStatusDetailsGet Method for V2MonitoringExtranetStatusDetailsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringExtranetStatusDetailsGetRequest
*/
func (a *DefaultAPIService) V2MonitoringExtranetStatusDetailsGet(ctx context.Context) ApiV2MonitoringExtranetStatusDetailsGetRequest {
	return ApiV2MonitoringExtranetStatusDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringExtranetStatusDetailsGet200Response
func (a *DefaultAPIService) V2MonitoringExtranetStatusDetailsGetExecute(r ApiV2MonitoringExtranetStatusDetailsGetRequest) (*V2MonitoringExtranetStatusDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringExtranetStatusDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringExtranetStatusDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/extranet/status-details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringIkeErrorHistoryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringIkeErrorHistoryPostRequest *V2MonitoringIkeErrorHistoryPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringIkeErrorHistoryPostRequest) Authorization(authorization string) ApiV2MonitoringIkeErrorHistoryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringIkeErrorHistoryPostRequest) V2MonitoringIkeErrorHistoryPostRequest(v2MonitoringIkeErrorHistoryPostRequest V2MonitoringIkeErrorHistoryPostRequest) ApiV2MonitoringIkeErrorHistoryPostRequest {
	r.v2MonitoringIkeErrorHistoryPostRequest = &v2MonitoringIkeErrorHistoryPostRequest
	return r
}

func (r ApiV2MonitoringIkeErrorHistoryPostRequest) Execute() (*V2MonitoringIkeErrorHistoryPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringIkeErrorHistoryPostExecute(r)
}

/*
V2MonitoringIkeErrorHistoryPost Method for V2MonitoringIkeErrorHistoryPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringIkeErrorHistoryPostRequest
*/
func (a *DefaultAPIService) V2MonitoringIkeErrorHistoryPost(ctx context.Context) ApiV2MonitoringIkeErrorHistoryPostRequest {
	return ApiV2MonitoringIkeErrorHistoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringIkeErrorHistoryPost200Response
func (a *DefaultAPIService) V2MonitoringIkeErrorHistoryPostExecute(r ApiV2MonitoringIkeErrorHistoryPostRequest) (*V2MonitoringIkeErrorHistoryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringIkeErrorHistoryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringIkeErrorHistoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/ike-error-history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringIkeErrorHistoryPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringIkeErrorHistoryPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringIkeErrorHistoryPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringInterfacePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringInterfacePostRequest *V2MonitoringInterfacePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringInterfacePostRequest) Authorization(authorization string) ApiV2MonitoringInterfacePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringInterfacePostRequest) V2MonitoringInterfacePostRequest(v2MonitoringInterfacePostRequest V2MonitoringInterfacePostRequest) ApiV2MonitoringInterfacePostRequest {
	r.v2MonitoringInterfacePostRequest = &v2MonitoringInterfacePostRequest
	return r
}

func (r ApiV2MonitoringInterfacePostRequest) Execute() (*V2MonitoringInterfacePost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringInterfacePostExecute(r)
}

/*
V2MonitoringInterfacePost Method for V2MonitoringInterfacePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringInterfacePostRequest
*/
func (a *DefaultAPIService) V2MonitoringInterfacePost(ctx context.Context) ApiV2MonitoringInterfacePostRequest {
	return ApiV2MonitoringInterfacePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringInterfacePost200Response
func (a *DefaultAPIService) V2MonitoringInterfacePostExecute(r ApiV2MonitoringInterfacePostRequest) (*V2MonitoringInterfacePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringInterfacePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringInterfacePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringInterfacePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringInterfacePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringInterfacePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringIpsecPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringIpsecPostRequest *V2MonitoringIpsecPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringIpsecPostRequest) Authorization(authorization string) ApiV2MonitoringIpsecPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringIpsecPostRequest) V2MonitoringIpsecPostRequest(v2MonitoringIpsecPostRequest V2MonitoringIpsecPostRequest) ApiV2MonitoringIpsecPostRequest {
	r.v2MonitoringIpsecPostRequest = &v2MonitoringIpsecPostRequest
	return r
}

func (r ApiV2MonitoringIpsecPostRequest) Execute() (*V2MonitoringIpsecPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringIpsecPostExecute(r)
}

/*
V2MonitoringIpsecPost Method for V2MonitoringIpsecPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringIpsecPostRequest
*/
func (a *DefaultAPIService) V2MonitoringIpsecPost(ctx context.Context) ApiV2MonitoringIpsecPostRequest {
	return ApiV2MonitoringIpsecPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringIpsecPost200Response
func (a *DefaultAPIService) V2MonitoringIpsecPostExecute(r ApiV2MonitoringIpsecPostRequest) (*V2MonitoringIpsecPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringIpsecPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringIpsecPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringIpsecPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringIpsecPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringIpsecPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringOspfPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringOspfPostRequest *V2MonitoringOspfPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringOspfPostRequest) Authorization(authorization string) ApiV2MonitoringOspfPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringOspfPostRequest) V2MonitoringOspfPostRequest(v2MonitoringOspfPostRequest V2MonitoringOspfPostRequest) ApiV2MonitoringOspfPostRequest {
	r.v2MonitoringOspfPostRequest = &v2MonitoringOspfPostRequest
	return r
}

func (r ApiV2MonitoringOspfPostRequest) Execute() (*V2MonitoringOspfPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringOspfPostExecute(r)
}

/*
V2MonitoringOspfPost Method for V2MonitoringOspfPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringOspfPostRequest
*/
func (a *DefaultAPIService) V2MonitoringOspfPost(ctx context.Context) ApiV2MonitoringOspfPostRequest {
	return ApiV2MonitoringOspfPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringOspfPost200Response
func (a *DefaultAPIService) V2MonitoringOspfPostExecute(r ApiV2MonitoringOspfPostRequest) (*V2MonitoringOspfPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringOspfPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringOspfPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/ospf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringOspfPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringOspfPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringOspfPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringPolicyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringPolicyPostRequest *V2MonitoringPolicyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringPolicyPostRequest) Authorization(authorization string) ApiV2MonitoringPolicyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringPolicyPostRequest) V2MonitoringPolicyPostRequest(v2MonitoringPolicyPostRequest V2MonitoringPolicyPostRequest) ApiV2MonitoringPolicyPostRequest {
	r.v2MonitoringPolicyPostRequest = &v2MonitoringPolicyPostRequest
	return r
}

func (r ApiV2MonitoringPolicyPostRequest) Execute() (*V2MonitoringPolicyPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringPolicyPostExecute(r)
}

/*
V2MonitoringPolicyPost Method for V2MonitoringPolicyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringPolicyPostRequest
*/
func (a *DefaultAPIService) V2MonitoringPolicyPost(ctx context.Context) ApiV2MonitoringPolicyPostRequest {
	return ApiV2MonitoringPolicyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringPolicyPost200Response
func (a *DefaultAPIService) V2MonitoringPolicyPostExecute(r ApiV2MonitoringPolicyPostRequest) (*V2MonitoringPolicyPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringPolicyPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringPolicyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringPolicyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringPolicyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringPolicyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringQueueInstantPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringQueueInstantPostRequest *V2MonitoringQueueInstantPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringQueueInstantPostRequest) Authorization(authorization string) ApiV2MonitoringQueueInstantPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringQueueInstantPostRequest) V2MonitoringQueueInstantPostRequest(v2MonitoringQueueInstantPostRequest V2MonitoringQueueInstantPostRequest) ApiV2MonitoringQueueInstantPostRequest {
	r.v2MonitoringQueueInstantPostRequest = &v2MonitoringQueueInstantPostRequest
	return r
}

func (r ApiV2MonitoringQueueInstantPostRequest) Execute() (*V2MonitoringQueueInstantPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringQueueInstantPostExecute(r)
}

/*
V2MonitoringQueueInstantPost Method for V2MonitoringQueueInstantPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringQueueInstantPostRequest
*/
func (a *DefaultAPIService) V2MonitoringQueueInstantPost(ctx context.Context) ApiV2MonitoringQueueInstantPostRequest {
	return ApiV2MonitoringQueueInstantPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringQueueInstantPost200Response
func (a *DefaultAPIService) V2MonitoringQueueInstantPostExecute(r ApiV2MonitoringQueueInstantPostRequest) (*V2MonitoringQueueInstantPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringQueueInstantPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringQueueInstantPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/queue-instant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringQueueInstantPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringQueueInstantPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringQueueInstantPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringQueuePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringQueuePostRequest *V2MonitoringQueuePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringQueuePostRequest) Authorization(authorization string) ApiV2MonitoringQueuePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringQueuePostRequest) V2MonitoringQueuePostRequest(v2MonitoringQueuePostRequest V2MonitoringQueuePostRequest) ApiV2MonitoringQueuePostRequest {
	r.v2MonitoringQueuePostRequest = &v2MonitoringQueuePostRequest
	return r
}

func (r ApiV2MonitoringQueuePostRequest) Execute() (*V2MonitoringQueuePost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringQueuePostExecute(r)
}

/*
V2MonitoringQueuePost Method for V2MonitoringQueuePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringQueuePostRequest
*/
func (a *DefaultAPIService) V2MonitoringQueuePost(ctx context.Context) ApiV2MonitoringQueuePostRequest {
	return ApiV2MonitoringQueuePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringQueuePost200Response
func (a *DefaultAPIService) V2MonitoringQueuePostExecute(r ApiV2MonitoringQueuePostRequest) (*V2MonitoringQueuePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringQueuePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringQueuePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringQueuePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringQueuePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringQueuePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSegmentRouteCountsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v1DevicesBringupPostRequest *V1DevicesBringupPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSegmentRouteCountsPostRequest) Authorization(authorization string) ApiV2MonitoringSegmentRouteCountsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSegmentRouteCountsPostRequest) V1DevicesBringupPostRequest(v1DevicesBringupPostRequest V1DevicesBringupPostRequest) ApiV2MonitoringSegmentRouteCountsPostRequest {
	r.v1DevicesBringupPostRequest = &v1DevicesBringupPostRequest
	return r
}

func (r ApiV2MonitoringSegmentRouteCountsPostRequest) Execute() (*V2MonitoringSegmentRouteCountsPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringSegmentRouteCountsPostExecute(r)
}

/*
V2MonitoringSegmentRouteCountsPost Method for V2MonitoringSegmentRouteCountsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringSegmentRouteCountsPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSegmentRouteCountsPost(ctx context.Context) ApiV2MonitoringSegmentRouteCountsPostRequest {
	return ApiV2MonitoringSegmentRouteCountsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringSegmentRouteCountsPost200Response
func (a *DefaultAPIService) V2MonitoringSegmentRouteCountsPostExecute(r ApiV2MonitoringSegmentRouteCountsPostRequest) (*V2MonitoringSegmentRouteCountsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSegmentRouteCountsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSegmentRouteCountsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/segment-route-counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v1DevicesBringupPostRequest == nil {
		return localVarReturnValue, nil, reportError("v1DevicesBringupPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v1DevicesBringupPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest *V2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) Authorization(authorization string) ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) V2MonitoringSiteCircuitsBandwidthSiteIdPostRequest(v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest V2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest {
	r.v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest = &v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
	return r
}

func (r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) Execute() (*V2MonitoringSiteCircuitsBandwidthSiteIdPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringSiteCircuitsBandwidthSiteIdPostExecute(r)
}

/*
V2MonitoringSiteCircuitsBandwidthSiteIdPost Method for V2MonitoringSiteCircuitsBandwidthSiteIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSiteCircuitsBandwidthSiteIdPost(ctx context.Context, siteId int64) ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest {
	return ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2MonitoringSiteCircuitsBandwidthSiteIdPost200Response
func (a *DefaultAPIService) V2MonitoringSiteCircuitsBandwidthSiteIdPostExecute(r ApiV2MonitoringSiteCircuitsBandwidthSiteIdPostRequest) (*V2MonitoringSiteCircuitsBandwidthSiteIdPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSiteCircuitsBandwidthSiteIdPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSiteCircuitsBandwidthSiteIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/site-circuits/bandwidth/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.siteId < 0 {
		return localVarReturnValue, nil, reportError("siteId must be greater than 0")
	}
	if r.v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSiteCircuitsBandwidthSiteIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSiteTwampSiteIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2MonitoringSiteTwampSiteIdPostRequest *V2MonitoringSiteTwampSiteIdPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSiteTwampSiteIdPostRequest) Authorization(authorization string) ApiV2MonitoringSiteTwampSiteIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSiteTwampSiteIdPostRequest) V2MonitoringSiteTwampSiteIdPostRequest(v2MonitoringSiteTwampSiteIdPostRequest V2MonitoringSiteTwampSiteIdPostRequest) ApiV2MonitoringSiteTwampSiteIdPostRequest {
	r.v2MonitoringSiteTwampSiteIdPostRequest = &v2MonitoringSiteTwampSiteIdPostRequest
	return r
}

func (r ApiV2MonitoringSiteTwampSiteIdPostRequest) Execute() (*V2MonitoringSiteTwampSiteIdPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringSiteTwampSiteIdPostExecute(r)
}

/*
V2MonitoringSiteTwampSiteIdPost Method for V2MonitoringSiteTwampSiteIdPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2MonitoringSiteTwampSiteIdPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSiteTwampSiteIdPost(ctx context.Context, siteId int64) ApiV2MonitoringSiteTwampSiteIdPostRequest {
	return ApiV2MonitoringSiteTwampSiteIdPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2MonitoringSiteTwampSiteIdPost200Response
func (a *DefaultAPIService) V2MonitoringSiteTwampSiteIdPostExecute(r ApiV2MonitoringSiteTwampSiteIdPostRequest) (*V2MonitoringSiteTwampSiteIdPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSiteTwampSiteIdPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSiteTwampSiteIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/site-twamp/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.siteId < 0 {
		return localVarReturnValue, nil, reportError("siteId must be greater than 0")
	}
	if r.v2MonitoringSiteTwampSiteIdPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSiteTwampSiteIdPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSiteTwampSiteIdPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSystemGenericPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringSystemGenericPostRequest *V2MonitoringSystemGenericPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSystemGenericPostRequest) Authorization(authorization string) ApiV2MonitoringSystemGenericPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSystemGenericPostRequest) V2MonitoringSystemGenericPostRequest(v2MonitoringSystemGenericPostRequest V2MonitoringSystemGenericPostRequest) ApiV2MonitoringSystemGenericPostRequest {
	r.v2MonitoringSystemGenericPostRequest = &v2MonitoringSystemGenericPostRequest
	return r
}

func (r ApiV2MonitoringSystemGenericPostRequest) Execute() (*V2MonitoringSystemGenericPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringSystemGenericPostExecute(r)
}

/*
V2MonitoringSystemGenericPost Method for V2MonitoringSystemGenericPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringSystemGenericPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSystemGenericPost(ctx context.Context) ApiV2MonitoringSystemGenericPostRequest {
	return ApiV2MonitoringSystemGenericPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringSystemGenericPost200Response
func (a *DefaultAPIService) V2MonitoringSystemGenericPostExecute(r ApiV2MonitoringSystemGenericPostRequest) (*V2MonitoringSystemGenericPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSystemGenericPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSystemGenericPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/system/generic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringSystemGenericPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSystemGenericPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSystemGenericPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringSystemPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringSystemGenericPostRequest *V2MonitoringSystemGenericPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringSystemPostRequest) Authorization(authorization string) ApiV2MonitoringSystemPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringSystemPostRequest) V2MonitoringSystemGenericPostRequest(v2MonitoringSystemGenericPostRequest V2MonitoringSystemGenericPostRequest) ApiV2MonitoringSystemPostRequest {
	r.v2MonitoringSystemGenericPostRequest = &v2MonitoringSystemGenericPostRequest
	return r
}

func (r ApiV2MonitoringSystemPostRequest) Execute() (*V2MonitoringSystemGenericPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringSystemPostExecute(r)
}

/*
V2MonitoringSystemPost Method for V2MonitoringSystemPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringSystemPostRequest
*/
func (a *DefaultAPIService) V2MonitoringSystemPost(ctx context.Context) ApiV2MonitoringSystemPostRequest {
	return ApiV2MonitoringSystemPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringSystemGenericPost200Response
func (a *DefaultAPIService) V2MonitoringSystemPostExecute(r ApiV2MonitoringSystemPostRequest) (*V2MonitoringSystemGenericPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringSystemGenericPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringSystemPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringSystemGenericPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringSystemGenericPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringSystemGenericPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MonitoringTwampPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2MonitoringTwampPostRequest *V2MonitoringTwampPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2MonitoringTwampPostRequest) Authorization(authorization string) ApiV2MonitoringTwampPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2MonitoringTwampPostRequest) V2MonitoringTwampPostRequest(v2MonitoringTwampPostRequest V2MonitoringTwampPostRequest) ApiV2MonitoringTwampPostRequest {
	r.v2MonitoringTwampPostRequest = &v2MonitoringTwampPostRequest
	return r
}

func (r ApiV2MonitoringTwampPostRequest) Execute() (*V2MonitoringTwampPost200Response, *http.Response, error) {
	return r.ApiService.V2MonitoringTwampPostExecute(r)
}

/*
V2MonitoringTwampPost Method for V2MonitoringTwampPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MonitoringTwampPostRequest
*/
func (a *DefaultAPIService) V2MonitoringTwampPost(ctx context.Context) ApiV2MonitoringTwampPostRequest {
	return ApiV2MonitoringTwampPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MonitoringTwampPost200Response
func (a *DefaultAPIService) V2MonitoringTwampPostExecute(r ApiV2MonitoringTwampPostRequest) (*V2MonitoringTwampPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MonitoringTwampPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2MonitoringTwampPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/monitoring/twamp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2MonitoringTwampPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MonitoringTwampPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2MonitoringTwampPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationCreatePostRequest *V2NotificationCreatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationCreatePostRequest) Authorization(authorization string) ApiV2NotificationCreatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationCreatePostRequest) V2NotificationCreatePostRequest(v2NotificationCreatePostRequest V2NotificationCreatePostRequest) ApiV2NotificationCreatePostRequest {
	r.v2NotificationCreatePostRequest = &v2NotificationCreatePostRequest
	return r
}

func (r ApiV2NotificationCreatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationCreatePostExecute(r)
}

/*
V2NotificationCreatePost Method for V2NotificationCreatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationCreatePostRequest
*/
func (a *DefaultAPIService) V2NotificationCreatePost(ctx context.Context) ApiV2NotificationCreatePostRequest {
	return ApiV2NotificationCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationCreatePostExecute(r ApiV2NotificationCreatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationCreatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationCreatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationCreatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationDeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationDeletePostRequest *V2NotificationDeletePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationDeletePostRequest) Authorization(authorization string) ApiV2NotificationDeletePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationDeletePostRequest) V2NotificationDeletePostRequest(v2NotificationDeletePostRequest V2NotificationDeletePostRequest) ApiV2NotificationDeletePostRequest {
	r.v2NotificationDeletePostRequest = &v2NotificationDeletePostRequest
	return r
}

func (r ApiV2NotificationDeletePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationDeletePostExecute(r)
}

/*
V2NotificationDeletePost Method for V2NotificationDeletePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationDeletePostRequest
*/
func (a *DefaultAPIService) V2NotificationDeletePost(ctx context.Context) ApiV2NotificationDeletePostRequest {
	return ApiV2NotificationDeletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationDeletePostExecute(r ApiV2NotificationDeletePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationDeletePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationDeletePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationDeletePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationEnabledisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationEnabledisablePostRequest *V2NotificationEnabledisablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationEnabledisablePostRequest) Authorization(authorization string) ApiV2NotificationEnabledisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationEnabledisablePostRequest) V2NotificationEnabledisablePostRequest(v2NotificationEnabledisablePostRequest V2NotificationEnabledisablePostRequest) ApiV2NotificationEnabledisablePostRequest {
	r.v2NotificationEnabledisablePostRequest = &v2NotificationEnabledisablePostRequest
	return r
}

func (r ApiV2NotificationEnabledisablePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationEnabledisablePostExecute(r)
}

/*
V2NotificationEnabledisablePost Method for V2NotificationEnabledisablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationEnabledisablePostRequest
*/
func (a *DefaultAPIService) V2NotificationEnabledisablePost(ctx context.Context) ApiV2NotificationEnabledisablePostRequest {
	return ApiV2NotificationEnabledisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationEnabledisablePostExecute(r ApiV2NotificationEnabledisablePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationEnabledisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/enabledisable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationEnabledisablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationEnabledisablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationEnabledisablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationUpdatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationUpdatePostRequest *V2NotificationUpdatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationUpdatePostRequest) Authorization(authorization string) ApiV2NotificationUpdatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationUpdatePostRequest) V2NotificationUpdatePostRequest(v2NotificationUpdatePostRequest V2NotificationUpdatePostRequest) ApiV2NotificationUpdatePostRequest {
	r.v2NotificationUpdatePostRequest = &v2NotificationUpdatePostRequest
	return r
}

func (r ApiV2NotificationUpdatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationUpdatePostExecute(r)
}

/*
V2NotificationUpdatePost Method for V2NotificationUpdatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationUpdatePostRequest
*/
func (a *DefaultAPIService) V2NotificationUpdatePost(ctx context.Context) ApiV2NotificationUpdatePostRequest {
	return ApiV2NotificationUpdatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationUpdatePostExecute(r ApiV2NotificationUpdatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationUpdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notification/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationUpdatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationUpdatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationUpdatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationlistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationlistPostRequest) Authorization(authorization string) ApiV2NotificationlistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationlistPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2NotificationlistPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2NotificationlistPostRequest) Execute() (*V2NotificationlistPost200Response, *http.Response, error) {
	return r.ApiService.V2NotificationlistPostExecute(r)
}

/*
V2NotificationlistPost Method for V2NotificationlistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationlistPostRequest
*/
func (a *DefaultAPIService) V2NotificationlistPost(ctx context.Context) ApiV2NotificationlistPostRequest {
	return ApiV2NotificationlistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2NotificationlistPost200Response
func (a *DefaultAPIService) V2NotificationlistPostExecute(r ApiV2NotificationlistPostRequest) (*V2NotificationlistPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2NotificationlistPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationlistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistCreatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2AllowlistCreatePostRequest *V2AllowlistCreatePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistCreatePostRequest) Authorization(authorization string) ApiV2NotificationmutelistCreatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistCreatePostRequest) V2AllowlistCreatePostRequest(v2AllowlistCreatePostRequest V2AllowlistCreatePostRequest) ApiV2NotificationmutelistCreatePostRequest {
	r.v2AllowlistCreatePostRequest = &v2AllowlistCreatePostRequest
	return r
}

func (r ApiV2NotificationmutelistCreatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistCreatePostExecute(r)
}

/*
V2NotificationmutelistCreatePost Method for V2NotificationmutelistCreatePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2NotificationmutelistCreatePostRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistCreatePost(ctx context.Context) ApiV2NotificationmutelistCreatePostRequest {
	return ApiV2NotificationmutelistCreatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationmutelistCreatePostExecute(r ApiV2NotificationmutelistCreatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistCreatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2AllowlistCreatePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2AllowlistCreatePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2AllowlistCreatePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	alertId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest) Authorization(authorization string) ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistDeletebyalertidAlertIdDeleteExecute(r)
}

/*
V2NotificationmutelistDeletebyalertidAlertIdDelete Method for V2NotificationmutelistDeletebyalertidAlertIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertId Alert id of the alert to delete allowlist/mutelist for
 @return ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistDeletebyalertidAlertIdDelete(ctx context.Context, alertId string) ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest {
	return ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		alertId: alertId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationmutelistDeletebyalertidAlertIdDeleteExecute(r ApiV2NotificationmutelistDeletebyalertidAlertIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistDeletebyalertidAlertIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/deletebyalertid/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	entityId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest) Authorization(authorization string) ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistDeletebyentityidEntityIdDeleteExecute(r)
}

/*
V2NotificationmutelistDeletebyentityidEntityIdDelete Method for V2NotificationmutelistDeletebyentityidEntityIdDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityId Entity id of the alert to delete allowlist/mutelist for
 @return ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistDeletebyentityidEntityIdDelete(ctx context.Context, entityId string) ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest {
	return ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		entityId: entityId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2NotificationmutelistDeletebyentityidEntityIdDeleteExecute(r ApiV2NotificationmutelistDeletebyentityidEntityIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistDeletebyentityidEntityIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/deletebyentityid/{entityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", url.PathEscape(parameterValueToString(r.entityId, "entityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2NotificationmutelistRuleIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	ruleId string
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2NotificationmutelistRuleIdGetRequest) Authorization(authorization string) ApiV2NotificationmutelistRuleIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2NotificationmutelistRuleIdGetRequest) Execute() (*V2AllowlistRuleIdGet200Response, *http.Response, error) {
	return r.ApiService.V2NotificationmutelistRuleIdGetExecute(r)
}

/*
V2NotificationmutelistRuleIdGet Method for V2NotificationmutelistRuleIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleId Alert id of the alert to retrieve allowlist/mutelist for
 @return ApiV2NotificationmutelistRuleIdGetRequest
*/
func (a *DefaultAPIService) V2NotificationmutelistRuleIdGet(ctx context.Context, ruleId string) ApiV2NotificationmutelistRuleIdGetRequest {
	return ApiV2NotificationmutelistRuleIdGetRequest{
		ApiService: a,
		ctx: ctx,
		ruleId: ruleId,
	}
}

// Execute executes the request
//  @return V2AllowlistRuleIdGet200Response
func (a *DefaultAPIService) V2NotificationmutelistRuleIdGetExecute(r ApiV2NotificationmutelistRuleIdGetRequest) (*V2AllowlistRuleIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2AllowlistRuleIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2NotificationmutelistRuleIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/notificationmutelist/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2ParentalertlistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2ParentalertlistPostRequest) Authorization(authorization string) ApiV2ParentalertlistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2ParentalertlistPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2ParentalertlistPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2ParentalertlistPostRequest) Execute() (*V2ChildalertlistPost200Response, *http.Response, error) {
	return r.ApiService.V2ParentalertlistPostExecute(r)
}

/*
V2ParentalertlistPost Method for V2ParentalertlistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2ParentalertlistPostRequest
*/
func (a *DefaultAPIService) V2ParentalertlistPost(ctx context.Context) ApiV2ParentalertlistPostRequest {
	return ApiV2ParentalertlistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2ChildalertlistPost200Response
func (a *DefaultAPIService) V2ParentalertlistPostExecute(r ApiV2ParentalertlistPostRequest) (*V2ChildalertlistPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2ChildalertlistPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2ParentalertlistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/parentalertlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2RuleEnabledisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	v2RuleEnabledisablePostRequest *V2RuleEnabledisablePostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2RuleEnabledisablePostRequest) Authorization(authorization string) ApiV2RuleEnabledisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2RuleEnabledisablePostRequest) V2RuleEnabledisablePostRequest(v2RuleEnabledisablePostRequest V2RuleEnabledisablePostRequest) ApiV2RuleEnabledisablePostRequest {
	r.v2RuleEnabledisablePostRequest = &v2RuleEnabledisablePostRequest
	return r
}

func (r ApiV2RuleEnabledisablePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2RuleEnabledisablePostExecute(r)
}

/*
V2RuleEnabledisablePost Method for V2RuleEnabledisablePost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2RuleEnabledisablePostRequest
*/
func (a *DefaultAPIService) V2RuleEnabledisablePost(ctx context.Context) ApiV2RuleEnabledisablePostRequest {
	return ApiV2RuleEnabledisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V2RuleEnabledisablePostExecute(r ApiV2RuleEnabledisablePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2RuleEnabledisablePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/rule/enabledisable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2RuleEnabledisablePostRequest == nil {
		return localVarReturnValue, nil, reportError("v2RuleEnabledisablePostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2RuleEnabledisablePostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2RulelistPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2RulelistPostRequest) Authorization(authorization string) ApiV2RulelistPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2RulelistPostRequest) Body(body map[string]interface{}) ApiV2RulelistPostRequest {
	r.body = &body
	return r
}

func (r ApiV2RulelistPostRequest) Execute() (*V2RulelistPost200Response, *http.Response, error) {
	return r.ApiService.V2RulelistPostExecute(r)
}

/*
V2RulelistPost Method for V2RulelistPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2RulelistPostRequest
*/
func (a *DefaultAPIService) V2RulelistPost(ctx context.Context) ApiV2RulelistPostRequest {
	return ApiV2RulelistPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2RulelistPost200Response
func (a *DefaultAPIService) V2RulelistPostExecute(r ApiV2RulelistPostRequest) (*V2RulelistPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2RulelistPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2RulelistPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/rulelist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2SiteSiteIdDetailPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2DeviceDeviceIdTopologyPostRequest *V2DeviceDeviceIdTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2SiteSiteIdDetailPostRequest) Authorization(authorization string) ApiV2SiteSiteIdDetailPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2SiteSiteIdDetailPostRequest) V2DeviceDeviceIdTopologyPostRequest(v2DeviceDeviceIdTopologyPostRequest V2DeviceDeviceIdTopologyPostRequest) ApiV2SiteSiteIdDetailPostRequest {
	r.v2DeviceDeviceIdTopologyPostRequest = &v2DeviceDeviceIdTopologyPostRequest
	return r
}

func (r ApiV2SiteSiteIdDetailPostRequest) Execute() (*V2SiteSiteIdDetailPost200Response, *http.Response, error) {
	return r.ApiService.V2SiteSiteIdDetailPostExecute(r)
}

/*
V2SiteSiteIdDetailPost Method for V2SiteSiteIdDetailPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2SiteSiteIdDetailPostRequest
*/
func (a *DefaultAPIService) V2SiteSiteIdDetailPost(ctx context.Context, siteId int64) ApiV2SiteSiteIdDetailPostRequest {
	return ApiV2SiteSiteIdDetailPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2SiteSiteIdDetailPost200Response
func (a *DefaultAPIService) V2SiteSiteIdDetailPostExecute(r ApiV2SiteSiteIdDetailPostRequest) (*V2SiteSiteIdDetailPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2SiteSiteIdDetailPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2SiteSiteIdDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/site/{siteId}/detail"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2DeviceDeviceIdTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2DeviceDeviceIdTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2DeviceDeviceIdTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2SiteSiteIdLanSegmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2NotificationlistPostRequest *V2NotificationlistPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2SiteSiteIdLanSegmentsPostRequest) Authorization(authorization string) ApiV2SiteSiteIdLanSegmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2SiteSiteIdLanSegmentsPostRequest) V2NotificationlistPostRequest(v2NotificationlistPostRequest V2NotificationlistPostRequest) ApiV2SiteSiteIdLanSegmentsPostRequest {
	r.v2NotificationlistPostRequest = &v2NotificationlistPostRequest
	return r
}

func (r ApiV2SiteSiteIdLanSegmentsPostRequest) Execute() (*V2DeviceDeviceIdLanSegmentsPost200Response, *http.Response, error) {
	return r.ApiService.V2SiteSiteIdLanSegmentsPostExecute(r)
}

/*
V2SiteSiteIdLanSegmentsPost Method for V2SiteSiteIdLanSegmentsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2SiteSiteIdLanSegmentsPostRequest
*/
func (a *DefaultAPIService) V2SiteSiteIdLanSegmentsPost(ctx context.Context, siteId int64) ApiV2SiteSiteIdLanSegmentsPostRequest {
	return ApiV2SiteSiteIdLanSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2DeviceDeviceIdLanSegmentsPost200Response
func (a *DefaultAPIService) V2SiteSiteIdLanSegmentsPostExecute(r ApiV2SiteSiteIdLanSegmentsPostRequest) (*V2DeviceDeviceIdLanSegmentsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DeviceDeviceIdLanSegmentsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2SiteSiteIdLanSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/site/{siteId}/lan-segments"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2NotificationlistPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2NotificationlistPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2NotificationlistPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2SiteSiteIdTopologyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	siteId int64
	v2DeviceDeviceIdTopologyPostRequest *V2DeviceDeviceIdTopologyPostRequest
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2SiteSiteIdTopologyPostRequest) Authorization(authorization string) ApiV2SiteSiteIdTopologyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2SiteSiteIdTopologyPostRequest) V2DeviceDeviceIdTopologyPostRequest(v2DeviceDeviceIdTopologyPostRequest V2DeviceDeviceIdTopologyPostRequest) ApiV2SiteSiteIdTopologyPostRequest {
	r.v2DeviceDeviceIdTopologyPostRequest = &v2DeviceDeviceIdTopologyPostRequest
	return r
}

func (r ApiV2SiteSiteIdTopologyPostRequest) Execute() (*V2DeviceDeviceIdTopologyPost200Response, *http.Response, error) {
	return r.ApiService.V2SiteSiteIdTopologyPostExecute(r)
}

/*
V2SiteSiteIdTopologyPost Method for V2SiteSiteIdTopologyPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId 
 @return ApiV2SiteSiteIdTopologyPostRequest
*/
func (a *DefaultAPIService) V2SiteSiteIdTopologyPost(ctx context.Context, siteId int64) ApiV2SiteSiteIdTopologyPostRequest {
	return ApiV2SiteSiteIdTopologyPostRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return V2DeviceDeviceIdTopologyPost200Response
func (a *DefaultAPIService) V2SiteSiteIdTopologyPostExecute(r ApiV2SiteSiteIdTopologyPostRequest) (*V2DeviceDeviceIdTopologyPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2DeviceDeviceIdTopologyPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2SiteSiteIdTopologyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/site/{siteId}/topology"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.v2DeviceDeviceIdTopologyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2DeviceDeviceIdTopologyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.v2DeviceDeviceIdTopologyPostRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2VersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	body *map[string]interface{}
}

// Bearer token. Format: Bearer &lt;your_token_here&gt;
func (r ApiV2VersionPostRequest) Authorization(authorization string) ApiV2VersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiV2VersionPostRequest) Body(body map[string]interface{}) ApiV2VersionPostRequest {
	r.body = &body
	return r
}

func (r ApiV2VersionPostRequest) Execute() (*V2VersionPost200Response, *http.Response, error) {
	return r.ApiService.V2VersionPostExecute(r)
}

/*
V2VersionPost Method for V2VersionPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2VersionPostRequest
*/
func (a *DefaultAPIService) V2VersionPost(ctx context.Context) ApiV2VersionPostRequest {
	return ApiV2VersionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2VersionPost200Response
func (a *DefaultAPIService) V2VersionPostExecute(r ApiV2VersionPostRequest) (*V2VersionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2VersionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V2VersionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["jwtAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
